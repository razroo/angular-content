\maketitle{}
\section{ Interfaces and Unions }

In GraphQL, and more in particular, because we are working on things from the
UI side of things, a Union type gives us the ability for one field to contain
more than one field. The best way to really think of it, is in terms of
Typescript. A union type would be:
\begin{lstlisting}
  type Book {
    title: String
  }

  type Author {
    name: String
  }

  type Result = Book | Author;

  type Query {
    search: [Result]
  }
\end{lstlisting}

As we can see, it is telling us that it can be one, of the other with regards
to data type. So instead of returning irrelevant data, we only return the data
we need. This is beneficial for a number of reasons.
\begin{enumerate}
  \item It lightens payloads
  \item Allows for succint sorting, on front end. I.e. do not have to sort from
  the backend.
\end{enumerate}

\subsection{ Using Unions with Apollo }
This is where at this time, things start to get really interesting. Using Apollo
with unions/interfaces starts to become tricky. In particular, the client has
no idea what is going on from the server side of things. Once we have different
sorts of data for a singular query coming back based on the type of data
avaialable, Apollo Client will just assume it is a certain type if it returns
all data for a specific type.

Apollo made the decision to use something called the
IntrospectionFragmentMatcher. It will look something like this:
\begin{lstlisting}
const fragmentMatcher = new IntrospectionFragmentMatcher({
  introspectionQueryResultData: {
    __schema: {
      types: [
        {
          kind: 'INTERFACE',
          name: 'User',
          possibleTypes: [
            { name: 'User' },
            { name: 'UserWithReason' },
            { name: 'UserWithRound' },
            { name: 'UserWithBid' },
          ],
        },
      ],
    },
  },
});
\end{lstlisting}

It tells Apollo Client for Angular that it expect the above types in the
interface for User.
