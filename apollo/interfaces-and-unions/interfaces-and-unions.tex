\maketitle{}
\section{ Interfaces and Unions }

In GraphQL, and more in particular, because we are working on things from the
UI side of things, a Union type gives us the ability for one field to contain
more than one field. The best way to really think of it, is in terms of
Typescript. A union type would be:
\begin{lstlisting}
  type Book {
    title: String
  }

  type Author {
    name: String
  }

  type Result = Book | Author;

  type Query {
    search: [Result]
  }
\end{lstlisting}

As we can see, it is telling us that it can be one, of the other with regards
to data type. So instead of returning irrelevant data, we only return the data
we need. This is beneficial for a number of reasons.
\begin{enumerate}
  \item It lightens payloads
  \item Allows for succint sorting, on front end. I.e. do not have to sort from
  the backend.
\end{enumerate}

\subsection{ Using Unions with Apollo Client }
This is where at this time, things start to get really interesting. Using Apollo
with unions/interfaces starts to become tricky. In particular, the client has
no idea what is going on from the server side of things. Once we have different
sorts of data for a singular query coming back based on the type of data
avaialable, Apollo Client will just assume it is a certain type if it returns
all data for a specific type.

Apollo made the decision to use something called the
IntrospectionFragmentMatcher. It will look something like this:
\begin{lstlisting}
const fragmentMatcher = new IntrospectionFragmentMatcher({
  introspectionQueryResultData: {
    __schema: {
      types: [
        {
          kind: 'INTERFACE',
          name: 'User',
          possibleTypes: [
            { name: 'User' },
            { name: 'UserWithReason' },
            { name: 'UserWithRound' },
            { name: 'UserWithBid' },
          ],
        },
      ],
    },
  },
});
\end{lstlisting}

It tells Apollo Client for Angular that it expects the above types in the
interface for User. Where it starts to get really interesting is that Apollo
Client requires for IntrospectionFragmentMatcher to be used regardless. So, in
their documentation they reccomend that a script be used at build time, that
creates a JSON file. This JSON file should then be used in the
IntrospectionFragmentMatcher. This is very cumbersome, because if backend
decides to throw something in for an already existing interface, it will cause
the backend to break for that query.

I would like to repeat this once again, if you do not have an
IntrospectionFragmentMatcher set up in your app, and backend adds union, or
interface types, it will cause that data to break, and it will return an empty
object.

\mybox{
  It should be noted, that one might immediately think, why not go ahead and
pull in the data for possibleTypes at runtime, and then use that for the
IntrospectionFragmentMatcher? The difficult part about it, is that the way
apollo works for the IntrospectionFragmentMatcher, is that it requires it to be
passed into the cache. The cache is created on page load, and then having to
update after cache is loaded, well you already missed the boat. So within the
context of Apollo Client for Angular, the only way to load in possible types
is to go along with the way documentation reccomends it.
}

\subsection{ What to Know Ahead of Time }
What would be really helpful to know ahead of time, is that this is an issue
that can only be solved by DevOps. It requires that back end and front end are
built at the same time. That way, they both get pushed only once the new script
is there. In this sitution, there really is no way about it. Having a mono repo
architecture across your company will greatly alleviate this process.
\footnote{I have created this issue to bring awareness to this issue, but
nothing so far https://github.com/apollographql/apollo-client/issues/4202 }
