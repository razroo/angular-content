
\section{ Unit Testing Component using Apollo }

Unit testing an app which has a DOM, is always a very difficult process. For
instance, one can be familiar with how a certain technology should be stubbed.
However, how one goes ahead and does so, is unique to that specific technology.
With regards to UI, frameworks currently tend to change very quickly. In
addition, thrre are many different frameworks, many of which use different
testing frameworks. It goes without saying, if I have a chance to learn
something and document it with regards to unit testing, it would be my honor to
do so.

In particular, with regards to the Angular Apollo Client. Until recently
(pre v1.1.0), using Apollo in an Angular App, was a very cumbersome ordeal.
In particular, there was no testing module. One would have to spin it up
themselves. However, now that we are dealing with v1.1.0, there is an official
testing suite set up.

\subsection { Re-visiting Component using Apollo }
First let's look at your standard Angular component generated by the Angular
CLI.

\begin{lstlisting}
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'ill-color-picker',
  templateUrl: './ill-color-picker.component.html',
  styleUrls: ['./ill-color-picker.component.scss']
})
export class IllColorPickerComponent implements OnInit {

  constructor() { }

  ngOnInit() {
  }

}
\end{lstlisting}

\subsection { Integrate Apollo with Component }

\begin{lstlisting}

+ import { Apollo } from 'apollo-angular';

+  ngOnInit() {
+    this.apollo
+      .query({
+        query: gql`
+          colors
+        `,
+      })
+      .subscribe((initialData: any) => {
+      });
+  }
\end{lstlisting}

\subsection { Unit testing Apollo }
First let's analyze what your generic Angular CLI generated spec will look like:
\begin{lstlisting}
import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { IllColorPickerComponent } from './ill-color-picker.component';

describe('IllColorPickerComponent', () => {
  let component: IllColorPickerComponent;
  let fixture: ComponentFixture<IllColorPickerComponent>;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ IllColorPickerComponent ]
    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(IllColorPickerComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

\end{lstlisting}

\subsection { Adding Apollo Testing Module }

\begin{lstlisting}
import {ApolloTestingModule} from 'apollo-angular/testing';
//..
+ ApolloTestingModule,
//..
\end{lstlisting}

The Apollo Testing Module will hijack the actual Apollo Module, and make it so
that there is no error in particular with regards to creating an apollo client.

\subsection { Hijacking the Component's GraphQL Request }
After we have imported our ApolloTestingModule within the app, we now need to
make it so that our GraphQL requests go straight to our fake backend request.
If we do not, of course, the colors GraphQL request will attempt to go the
default apollo link, making unit testing dependent on our GraphQL server.

\subsubsection { Initializing the ApolloTestingBackend }
\begin{lstlisting}
+ import {ApolloTestingBackend} from 'apollo-angular/testing/backend';

+ const mock = new ApolloTestingBackend();
\end{lstlisting}

ApolloTestingBackend works by keeping a list of all open operations.
As operations come in, they're added to the list. Users can assert that specific
operations were made and then flush them. In the end, a verify() method asserts
that no unexpected operations were made.
\footnote{This particular description can be found in: https://github.com/apollographql/apollo-angular/blob/master/packages/apollo-angular/testing/src/backend.ts}

\subsubsection { Initializing the Apollo Link }

\begin{lstlisting}
+ import {ApolloLink} from 'apollo-link';

+ const link = new ApolloLink(op => mock.handle(op));
\end{lstlisting}

An Apollo Link as the documentation mentions, is a function that takes an
operation and returns an observable. We are simply trying to repeat the process.
In particular for the execute function.

\subsubsection { Initializing the Operation }
\begin{lstlisting}
+ const buildOperationForLink = (
+    document: DocumentNode,
+    variables: any,
+  ) => {
+    return {
+      query: document,
+      variables,
+      operationName: getOperationName(document) || undefined,
+      context: {},
+    };
+  };

+ const operation = buildOperationForLink(query, {});
\end{lstlisting}

\subsubsection { Running the Execute Function }
\begin{lstlisting}
+ import {ApolloLink, execute} from 'apollo-link';

+ execute(link, operation as any).subscribe(result => (response = result));
\end{lstlisting}

The execute function will take link which is a mock link, as well as use our
operation(i.e. GraphQL query) and return an observable that we can now use to
get back our result.
