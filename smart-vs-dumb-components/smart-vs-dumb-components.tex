\maketitle{}
\section{ Smart Vs Dumb Components }

In any UI framework, following a smart component, and dumb component
architecture, is going to be a good idea with regards to re-usability.  It will
completely change the way(if it hasn't already), the way you go ahead and build
your components. It is one of those design patterns that you will ineviabtly
learn how to do on your own, but why take the hard way(i.e. reading this chapter)
when you have chance to just read this chapter. If you are already familiar,
feel free to keep reading, I worked hard to make sure there is something to
learn as well.

\subsection{ A Dumb Component - Defined }
A dumb component many times can be thought of as a child component. Think of it
as this component is going to be re-used is many different places. How can we
make it's logic as generic enough so that can happen? Simply put, the dumb
component will receive it's data from it's parent component. Wherein the parent
component will be responsible for retreiving the data. The question then becomes
framework specific, how can we pass events up from the dumb component, to it's
parent smart component. In addition, how can we pass down data from the parent
component to the child component.
So the only two concerns when creating a dumb component is:
\begin{enumerate}
  \item Event Binding
  \item Propery Binding
\end{enumerate}

\subsection{ A Smart Component - Defined }
A smart component inversely, will be responsible for creating the data, to be
passed down to the dumb component. In addition, it will hook into the events
for the specific dumb component, and make sure to make data calls at that time
as well.

\subsection{ Where does State Come In? }
One of the grayer areas when it comes to dumb vs. smart components, is state
management. I personally have found putting a re-usable state in a dumb
component to be extremely useful. State is to be made re-usable by keeping all
unique sets of data nested one level deep. This is done by making the
storeSelectName dynamic. We will discuss this in detail in another chapter.

\subsection{Creating a Dumb Component in Practice}
In an Angular setting there are two decorator functions that the framework
offers out of the box that will help in this regard. They are @Input and
@Output.

\subsection{@Input in Detail}
@Input if you are not already familiar, is Angular's way of passing down data
from parent to child. So just a quick example of how data would be passed down
from a smart component to a dumb component would be as follows: 
