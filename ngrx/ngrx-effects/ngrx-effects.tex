\maketitle{}
\section{ Ngrx Effects }

\subsection{Ngrx Effects - A Primer}
Ngrx effects can be one of the more ambigious parts of the ngrx stack. They are
by definitition something that is supposed to happen when something else has
happened. It will listen for a particular action, and true to Ngrx, return an
observable. In this observable one will have the option to do whatever they want
as well as publish(return) to the action stream.

The line, however, can be blurred, however, as to what the difference is between
an ngrx/effect and a ngrx/store. It is therefore important to distinguish for
architectural reasons. In addition, it can be difficult to determine the
different use cases wherein someone would use an effect. It can indeed be a
slippery slope wherein when to use an effect.

\subsubsection{ Code Example }
\begin{lstlisting}
@Effect({ dispatch: false })
 userDeleted$ = this.dataPersistence.fetch(
   UserActivitiesTypes.UserDeleted,
   {
     run: (action: UserDeleted, state: UserStateModelState) => {
       this.snackBar.open('User Deleted', 'Ok', {
         duration: 2000,
         verticalPosition: 'top',
       });

       return null;
     },

     onError: (action: ActivityDeleted, error) => {
       console.error('Error', error);
     },
   }
 );
\end{lstlisting}

This code example, is a great example as to when someone might use an effect.
As we can see here, we have an action that is being triggered for when a user is
deleted. We then have an effect who's sole purpose to have a snack bar open
when action is called.

\subsubsection{ When to Use an Effect }
As we discussed earlier, knowing when to use an effect can be a tricky thing to
decipher. Think of it as having the ability to do the following:
\begin{enumerate}
  \item Hook into State.
  \item Ability to do whatever when action is called.
  \item Publish an action back into the state management cycle.
\end{enumerate}

In our scenario, for deleting a user we had two effects:

We called a GraphQL service to delete a user. We then retrieve the result
returned by the GraphQL service, and trigger another effect, which is our
snackbar effect. Yes, this logic can potentially be handled by our view layer
within our component. In addition, we can use the service directly. However,
having all of this logic encapsulated in our effect makese everything very
clean.
