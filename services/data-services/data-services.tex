\maketitle{}
\section{ Data Services - Directory Structure }

In an @ngrx/store setting, a very large part of an app's services, will be
directed towards handling data directly. For instance, let's say you have a
GraphQL user query that get's a current user's data. The service would look
something like this:
\begin{lstlisting}
import { Injectable } from '@angular/core';

import { Observable, from } from 'rxjs';
import { pluck } from 'rxjs/operators';
import { Apollo } from 'apollo-angular';

@Injectable({ providedIn: 'root' })
export class UserService {
  getUser(): Observable<User> {
    const user$ = this.apollo.query({ query: GetCurrentUser });

    return from(user$).pipe(pluck('data', 'getCurrentUser'));
  }
  constructor(private apollo: Apollo) {}
}
\end{lstlisting}

Of course, the amount of queries that need to be used for any data type, is
numerous. It's a rough guess, but odds are that 80\% of services within any
Angular app, will have these sort of services. These services will be used by a
number of effects. In addition, they will contain their own respective unit
tests.

\subsection{ Setting the Landscape }
As of Angular 6, it offers a metadata option called providedIn. In short, if
providedIn is set to 'root', it will only be used when used. Most notably it
allows us to bypass the need of using a module, and creates a tree-shakable
version \footnote{https://angular.io/guide/dependency-injection-providers\#creating-tree-shakable-providers}.
Therefore, the bundler will be able to tell if this service is being used in a
particular module. If it is not, service will not be bundled with particular
module. This allows us to be very liberal with our services and put them in a
central location. (Of course we would be able to do this with a module, but
it make's it more architecturally appealing without the need of using a
module)

\subsection{ Data Services Folder/File Structure }
\input{./services/data-services/data-services-tree-structure}
