\maketitle{}
\section{ Writing E2E Tests }

In addition to our Unit Testing, another very important element of our app is
End to End Testing. However, before we go ahead into the specifics of E2E
testing, and discuss some of the finer details of a well architected protractor,
environment, let's look into what constitutes a good QA environment.

\subsection{ Automation Engineering }
In an ideal QA environment, there will be a QA team layered on top of the
Backend and Frontend Team. Their QA tests, however, will not be integrated into
the environment of the aforementioned teams. Instead they will be in their own
environment, and most likely running their tests in two environments: Dev, and
productiong.

In particular, they should follow something called smoke testing.

\mybox{\subsubsection{Smoke Testing}
Smoke Testing is preliminary testing to reveal simple failures severe enough to,
for example, reject a prospective software release. Smoke tests are a subset of
test cases that cover the most important functionality of a component or system,
used to aid assessment if main functions of the software appear to work
correctly. When used to determine if a computer program should be subjected to
further, more fine-grained testing, a smoke test may be called an intake test
}

\subsection{ Automation Engineering - The Cross Over }
Part of the question then becomes if automation engineering is creating their
own integration tests for your app, it is essentially a bunch of E2E tests. So,
why should UI go ahead and create their own tests, if QA is already creating
them? Here are a couple of answers:
\begin{enumerate}
  \item The earliest point in the lifecycle that QA will be able to test is in
  Dev. If UI Engineering does not create their own E2E tests, then failures in
  Dev, will then be sent back to UI, severly halting the workflow.
  \item Redundancy. There might be different parts of the app that engineering
  is uniquely acute to testing. In addition, there might be other parts of the
  app wherin QA might be uniquely equiped to test. A great real life example of
  this is the following. We were integrating uploading files in the app for the
  first time, as well as sending emails. Being the developer who worked with
  both, I was acutely aware of odd file size of some of the documents being
  uploaded was 0. So I did some testing to make sure none of the files has a
  file size of 0, and lo and behold, our app was riddled with them. That was
  something that QA would have never really thought of doing, simply because I
  had more access to the data.
  \item Discipline. I think that it is important for UI engineering to get into
  the discipline of how their work will affect the actual user experience.
  Having UI Engineering actually write some of those tests is important.

\end{enumerate}
