\maketitle{}
\section{ Spies }

Spy's are an integral part of any unit testing suite. For those familiar, you
might think of it as something that doesn't neccesarily deserve it's own
chapter. However, spies help simplify the unit test suite to such a great
extent, that not discussing the finer detais of how it should work, almost
seems like a crime.

\subsection{ A Primer }
First and foremost, spies are actually one of the finer points of unit testing.
Personally, when I started writing them professionally for Verizon, spies were one of the more difficult things for me to understand. I found the name
particularly confusing. A spy?! You mean I am spying on a function that I
already know about? Wait, so you mean I am giving my unit tests the ability to
tell if function has run, or what it has been called with? Also, it gives me the
ability to hijack it with a different function, or call through as is? Wow, I
can't think of any name to call that? Ok, now I understand why it was called a
spy.

\subsubsection{ Spy User Example }

\begin{lstlisting}
describe('', () => {
  const userId = '123';
  it('should call the userFacade.getUsers function, when getusers' +
  'is called', () => {
    spyOn(userFacade, 'getUsers');
    component.getUsers(userId);
    expect(userFacade.getUsers).toHaveBeenCalledWith(userId);
  });
});
\end{lstlisting}

The above is a classic example of what a real world spy would do. Here, we just
want to just make sure that the facade is indeed being called when the
appropriate component function is run.

\mybox{
In a real world scenario, it would also be responsible of us to test, and make
sure that the component function was indeed called. There are two ways that
something like this can be done. One is that we can targer the dom within our
unit test. We can also choose to make this part of the unit test within Cypress.
I like the idea of seperating any integration testing into Cypress. It would
allow us to keep our component unit test shallow, without the need of having
any component integration involved.
}

\subsection{ Two Methods of Declaring Spies }
It would seem that there are two schools of thought when it comes to how one should
place the spy. Some place the spy within the actual beforeEach statement. This
simplifies the use of doing so. The other approach, is to apply the spy inside of
every it block that has use of it. While I do not think it is a huge deal to have
one approach over, the other, I do see the benefit of placing the spy in every
it block that uses it. Why? Generally, in an enterprise Angular application,
there will be a very small amount of spy's that will be set out throughout the
application. So, adopting a always put a spy in a beforeEach, can be:
\begin{enumerate}
  \item Irresponsible for performance reasons (from a code perspective. I would still gladly call you my friend).
  \item Totilitarian in nature of adoption. However, due to the fact that not
  all tests require spies, it can be confusing.
\end{enumerate}

So, it would make sense that putting spies in individual it blocks will make the
most sense.

\subsection{ Strategy for Using Spies }
Spies work particularly well with function composition. The attempt of this book
is not to overlap with common unit testing principles, such as functions should
be kept small. It is to introduce to those that might be less familiar with how
to use spies, how it should be used. In particular, let's imagine we had a large
function. This function applies sorting, and filtering. 
