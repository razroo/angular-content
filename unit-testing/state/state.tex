
\chapter{ Unit Testing State }

Testing state potentially can be a grueling process. You will have to create a
module for state. You will then have to inject appropriate data that you expect
from the store. Within our reccomended Facade architecture, this problem is
already alleviated. Why? Because, being that the store is located within our
facade, we can simply provide it with an empty object. When we end up using
the facade within our components, the injected store never even makes it's
way through, because it is mocked out. Therefore, it never becomes more
complicated than this.

\begin{lstlisting}
describe('UserFacade', () => {
  let facade: UserFacade;
  let store: Store<any>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [StoreModule.forRoot({})],
      providers: [
        UserFacade,
      ],
    });

    facade = TestBed.get(UserFacade);

    store = TestBed.get(Store);
    spyOn(store, 'dispatch');
  });
\end{lstlisting}

\mybox{For this reason, and many others, using the facade pattern within
Angular, just makes so much sense. Feel free to check out the chapter on
facades, for the full rundown on why this pattern just makes so much sense
within an Angular setting.}
