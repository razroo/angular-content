\maketitle{}
\section{ Unit Testing Subscriptions }

One of the more complicated things within an Angular architecture, is unit
testing subscriptions. There are many scenarios within a UI application, wherein
an observable cannot be passed directly to the html, for use with the async pipe.
We have mentioned in a previous chapter the need of using the takeUntil operator,
and that is not the intent here to discuss. What is the intent here, is to
discuss how to unit test scenarios where functionality is happening within
subscribe block.

\subsection{Scenarios}
Just for clarity sake, I would like to bring up some scenarios where unit
testing is important within an Angular setting.
\begin{enumerate}
  \item We are using subscribe data for a form. So that if data does exist, we
  can use the native Angular api for forms, and reset the form with data
  given by backend. However, we have the data by backend, has nested data
  when it is present. When it is not present, it is null. There are therefore
  some safeguards that need to be done by the front end inside of the subscribe
  block for those outlier use cases.
  \item Backend does not intend to filter for a certain scenario, as it is a one
  off dashboard, for some clients. It is up to front end to filter based on
  limited backend data.
  \item We have multiple projects for a user that they can use in their
  application. Data for the page will need to change when user selects a
  different project id. As a result, we will need to wrap data within the
  projectId we are using.
\end{enumerate}

\maketitle{}
\subsection{ Mocking a Facade }
Within our facade architecture\footnote{Which we have discussed thoroughly
through out book}, we will be injecting the facade into our Angular
component/class. This allows us to mock the facade within our unit test, and
control how we can interact with it within the unit test. In particular, we
will always be passing in a observable, when is able to be modified. However,
what we can do, is change the dynamics of how it becomes an observable.

Let's imagine that within our component we have a facade for the user.
\begin{lstlisting}
constructor(private userFacade: UserFacade) {}

ngOnInit() {
  this.userFacade.user$.pipe(
    takeUntil(this.destroyed$);
  )
  .subscribe(user => {
    this.user = user;
    this.form.reset(user);
  });
}
\end{lstlisting}

Here, we are mimicking the 1st scenario we spoke about, wherein we need the data
for the form reset we are using within the app. Let's say that we want to test,
that the data is indeed being passed over the user, and form reset. In addition,
want to set a safe guard, so that if a developer in the future accidently
deletes any of the lines of code:
\begin{verbatim}
this.user = user;
this.form.reset(user);
\end{verbatim}

The unit tests will complain. So let's move over to the unit test.

\subsection{ Unit Test }

\begin{lstlisting}
@Injectable()
class UserFacadeMock {
  userSubject$ = new BehaviorSubject({...userMock});
  user$ = userSubject$.asObservable();
}

describe('ComponentClass', () => {
  let component: ComponentClass;
  let fixture: ComponentFixture<ComponentClass>;
  let userFacade: UserFacadeMock;

  beforeEach(async(() => {
    Testbed.configureTestingModule({
      declaration: [ComponentClass],
      provides: [
       {
         provide: UserFacade,
         userClass: UserFacadeMock,
       }
      ]
    }).compileComponents();
  }));

  beforeEach( async( () => {
    fixture = TestBed.createComponent(ComponentClass);
    component = fixture.componentInstance;
    fixture.detectChanges();

    userFacade = TestBed.get(UserFacade);
  });
});
\end{lstlisting}

As we can see in the above we have layed out the structure for our unit tests,
so that we can now control the value of user, by triggering the subject. Let's
write that unit test we meant to get around to:
\begin{lstlisting}
it('should properly pass in values from the subscribe block, to the' +
'component.user and component.form.reset', () => {
  const mockUserData: User = {...userMock};
  spyOn(component.form, `reset');
  userFacade.userSubject$.next({...mockUserData});
  expect(component.user).toEqual({...mockUserData});
  expect(component.form.reset).toHaveBeenCalledWith({...mockUserData});
});
\end{lstlisting}

\subsection{Dis-secting What We've Done}
Looking back at what we've done, by hijacking the UserFacade injected into our
component, and supplying it with a subject, we have given our unit tests full
freedom to test how it wishes what is being done inside of the subscribe block.

\mybox{You might question, as to why it is that we do not directly change
the observable to be a subject? This will cause type annotation errors, which
is easier solved by simply creating a subject, and returning it as observable
for the respective facade method}
