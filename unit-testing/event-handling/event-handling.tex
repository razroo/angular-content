\maketitle{}
\section{ Unit Testing - Event Handling and Text}
In my mind, anything which is considered as architecture is something which
isn't immediately considered as obvious. One aspect of unit testing that tends
to be overlooked, is unit testing event handling. For instance, let's say we
have a filter toggle, wherein we only want the filter to show when a user clicks
on it. This is something which we can trigger from unit tests, without the need
to have go through integration testing. In addition, certain areas of our app
are very sensitive when it comes to text. Focusing on these two alone, allows
our app's integrity to be head and shoulders above the rest.

\subsection{ Angular's best Utility Testing Suite }

TODO

\subsection{ Unit Testing - Event Handling }
Going back to our previous example of a filter toggle, let's jump right in and
see what a filter toggle unit test might look like:

\begin{lstlisting}
const filterToggle = fixture.nativeElement.querySelector(
  '.filter-toggle'
);
filterToggle.click();
expect(component.showFilter).toBeTruthy();
filterToggle.click();
expect(component.showFilter).toBeFalsy();
\end{lstlisting}

We are using querySelector to target the first .filter-toggle html class
(assuming there is only one on the page). Being that our default view is false,
we are using the component.showFilter to make sure that value is truthy when
clicked on. Moving on, when clicked on again, we want to make sure that element
is hidden. \marginpar{consider revision of code, it should target actual element
in addition to code}

We have now completely though the power of unit testing, determined whether, or
not an element is going to show up.

\subsection{ Unit Testing - Determining Text }
With regards to text, let's say that we want to test the entire component at a
specific time period, and want to make sure it contains three different words:
\begin{lstlisting}
it('should show buyer company names', () => {
  expect(fixture.nativeElement.innerText).toContain('Apple');
  expect(fixture.nativeElement.innerText).toContain('Microsoft');
  expect(fixture.nativeElement.innerText).toContain('Google');
});
\end{lstlisting}

Text might seem intuitive. However, there is the option to target text at
different areas of time, and to make sure what one is looking is the correct
format at a given time. Doing something like this takes experience to get it
right. However, assuming you didn't know beforehand, you now know that you have
the option to target text at a specific time.
