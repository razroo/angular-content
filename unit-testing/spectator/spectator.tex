\maketitle{}
\section{ Spectator for Unit Testing  }

There are many quirks that surround angular unit testing. For instance, let's
assume we have a very basic unit test:

\begin{lstlisting}
import { TestBed, async, ComponentFixture} from `@angular/core/testing';
import { ButtonComponent } from `./button.component';
import { Component, DebugElement } from `@angular/core';
import { By } from `@angular/platform-browser';

describe('ButtonComponent', () => {
  let fixture: ComponentFixture<ButtonComponent>;
  let instance: ButtonComponent;
  let debugElement: DebugElement;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [
        ButtonComponent
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(ButtonComponent);
    debugElement = fixture.debugElement;
    instance = fixture.componentInstance;
  });

  it('should set the class name according to the [className] input', () => {
    instance.className = 'danger';
    fixture.detectChanges();
    const button = debugElement.query(By.css('button')).nativeElement as HTMLButtonElement;
    expect(button.classList.contains('danger')).toBeTruthy();
    expect(button.classList.contains('success')).toBeTruthy();
  });
});
\end{lstlisting}

This sample unit test has a quirk that is specific to Angular. Each time we have
to go ahead and create a TestBed, as well as a fixture, and include the
component.

\subsection{Eliminating }
If we were to use spectator, we can do the following:

\begin{lstlisting}
import { ButtonComponent } from `./button.component';
import { Specator, createTestComponentFactory } from `@angular/core';

describe('ButtonComponent', () => {
  let spectator: Spectator<ButtonComponent;
  const createComponent = createTestComponentFactory(ButtonComponent);

  it('should set the class name according to the [className] input', () => {
    spectator = createComponent;
    spectator.setInput('className', 'danger');
    expect(specator.query('button')).toHaveClass('danger');
    expect(specator.query('button')).not.toHaveClass('success');
  });
});
\end{lstlisting}

Using Spectator, we no longer have to create a Testbed and a fixture. Behind
the scenes, spectator will handle all of these things behind the scenes. In
addition, we are able to use the toHaveClass method, to check whether, or not
a class exists.

\subsection{ Triggering Events }

\begin{lstlisting}
describe('Highlight Directive', () => {
  let host: SpectatorWithHost<HighlightDirective>;

  const createHost = createHostComponentFactory(HighlightDirective);

  it('should change the background color', () => {
    host = createHost(`<div highlight>Testing Hightlight Directive</div>`);

    host.dispatchMouseEvent(host.element, 'mouseover');

    expect(host.element).toHaveStyle({
      backgroundColor: '#fafafa'
    });

    host.dispatchMoustEvent(host.element, 'mouseout');

    expect(host.element).toHaveStyle({
      backgroundColor: '#ffffff'
    });
  });
});
\end{lstlisting}
