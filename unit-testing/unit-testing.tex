\maketitle{}
\section{ Unit Testing }

Unit testing has always been a hot topic. It's because it really isn't so well
understood amongst many software engineers. In addition, I know of many managers
who look as unit testing as icing on the cake, and perhaps they are right.

However, what unit testing allows us to do, is assure the code we are implementing
is correct. That it is self documenting, and that we have the confidence moving
forward knowing that this will work the way it needs.

Unit testing really is a beast, and is really hard to manage. It's because it
isn't directly related to quality assurance, and can easily go under the radar,
as the app will go on without it. However, everytime that I have communicated
with management the bottom line. Research has been done on unit testing, and that
the application will be harder to manage long term, without it, they understand.

Bring the above point up to them, and hopefully you can have unit testing as a
part of your application.

At this point in our application, the only thing that we have created that
deserves to be unit tested, are the reducers. Let's go ahead and unit test those:

\begin{lstlisting}
describe('Functionality for the ChooseSizeUpdated reducer', () => {
  const chooseSizeData = {
    columns: 20,
    rows: 20,
    pixelSize: 20
  }
  it('should update the chooseSize store as is approprate', () => {
    const action: ChooseSizeUpdated = new ChooseSizeUpdated(chooseSizeData);
    const actual = chooseSizeReducer(initialState, action);
    expect(actual).toEqual(chooseSizeData);
  });
});
\end{lstlisting}

The above is an example of what a sample unit test for a reducer would look like
in the chooseSizeUpdated reducer.

Note: Add in section going over best conventions with regards to unit testing.

\maketitle{}
\subsection{ Unit Testing as a Discipline }

Unit testing is difficult, because it is a different discipline. In particular,
the above unit testing that we made, is a great example of poor unit testing.
We simply tested to make sure that all fields properly made their way over.

However, there are a number of considerations to keep in mind:
\begin{enumerate}
  \item What happens if we insert a string, instead of a number?
  \item Is there any limit on the number of rows, or columns?
  \item Should there be a limit on pixel size?
  \item Should there be a 1:1 ratio between rows and columns, or vice versa?
\end{enumerate}

\subsection{ The Irony of a Product Engineer }
One might think that the above requirments, are to be pro-offered by the Product
and to be tested by QA. However, at the end of the day, if these issues exist,
it will mean that the software you created will be lackluster. [This indeed
extends to other parts of the app, however, we are currently focusing on
unit testing]. Therefore, try to take ownership as an engineer. There are
different levels of intelligence, but amongst many other things, software
engineers are a truly analytical bunch.

\subsection{ First Principles Thinking }

\begin{verbatim}
  Q: What would we like to get out of the choose size form?
  A: We would like to specify number of rows, number of columns, and pixel size.

  Q: Being that these are numbers, do we have any way of preventing
  the user from entering in any value other than an number?
  A: The input will only allow numbers.
  Q: Ok, do you see any value in setting up logic, so that if it is not a
  number, then it will throw an error?
  A: No, because there will never be a situation wherein they can not put in a
  number.
  Q: In that case, should we take a snapshot and make sure input fields are
  indeed of the type number. If not then it should error.

  Q: Now that we have established that these are always numbers, is there any
  limit on the size of this grid.
  A: Not really, I can see it as just being what the window size.
  Q: Hmm, I find that interesting, so you are saying that it can be any size.
  A: Yes for this iteration.
  Q: Okay, but it will be specific to window size.
  A: Yes.
  Q: Ok, so let's go ahead and create unit test, that it should have an
  error, that based on window size, if value is greater, it should automatically
  have it go to the height window size. In addition, there should be test that
  specifies as such.

  Q: Now that we have established that these we constrained window, is there any
  limit on the ratio between column size, and row size?
  A: No.
  Q: Is there any way that we can create a unit test, to just say that it
  passes, if there is a difference in ratio, between, then should not error out?
  A: Yes, need to figure this out though. Not sure how to do off hand.

  Q: Now that we have established that there are no constraints, what else is
  there for us to test. We have covered window size, ratio, input type, what
  about a max pixel Size?
  A: Hmm, why would we care about that?
  Q: Not sure, good point.

  Q: Hmm, that being said, should we only allow pixel size that is within the
  frame of the row and column size? For instance, let's say we have 20 rows, and
  20 columns, should the pixel size be something that perfectly divides into
  400?
  A: Not sure, it would be a lot of overhead at this point.
  Q: Almost feel like we should automatically control pixel size based on column
  and row size.
  A: Ok, out of scope, let's not.

  Q: Anything else?
  A: Not that I can think of.

  //End of Scene - dev takes a bow
\end{verbatim}


Now that we have identified, that our unit test in this fashion really isn't a
good unit test, what would be a good way of approaching these in a scientific
fashion?
