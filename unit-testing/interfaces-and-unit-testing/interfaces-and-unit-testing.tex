\maketitle{}
\section{ Interfaces and Unit Testing }
In unit testing it can be very difficult to keep in sync the mocked data you
are using, with actual data used within app's actual live UI. The easiest, and
most efficient way of doing this is creating interfaces. The part where it
becomes tricky, is that generally data is used in multiple places. For instance,
we might have state that is contained in a separate component, wherein the data
originates from. In addition, the data might also be used in some other component
as well as service.

\subsection{ In Sync Data - Interface Architecture }
An interface at it's core is responsible for making sure that data follows a
pre-described schema. The part, however, that is unintuitive in an Angular
setting, is what happens when you have services, components, state, and spec
files all vying for the same data. Do we use one interface for all of them,
or different one's for each file group. If we do end up using on interface, one
sort of data structure is it that we will use for all of these files

\subsubsection{ Interface Architecture - The Dillema }
As we discussed in the previous paragraph, in an Angular application, there will
be services, components, state and spec files vying for the same data. The
dillema when it comes to interfaces, however, is that they need data in
different ways. I would like to layout this data in detail.

Let's imagine that we have a data-table that we need to specify data:
\begin{itemize}
  \item Service - Used to determine status of checkbox logic. It only needs to
  know length of data, and actual data is irrelevant. Respective spec, only
  needs to be aware of similar data.
  \item Component - Needs to know actual data, so that it can pass along
  observable stream component html. Respective spec needs to be aware of data.
  \item State - Depnding on the reducer, or effect, it might need all of the
  data, or none of it. Respective spec will need to familiar of similar data.
\end{itemize}

\subsection{ In Sync Data - The Solution }
As one can see, it is actually counter-intuitive to create a singular interface
for one's service, state, component(s), and their respective specs. However, if
one does not use the same singular spec for all of them, one runs the risk of
them getting out of sync with each other. The data inside of the object might
make all the difference when it coems to causing unit tests to fail.

The solution is as follows. There should be a singular interface that exists
for the root of the following files:
\begin{enumerate}
  \item Services[Includes spec files]
  \item State[includes spec files]
  \item GraphQL(Interfaces not used, but influenced by, and therefore important
  to be in the same directory)
  \item Module(Interface not used for)
\end{enumerate}

This, however, requires that all the files be tightly coupled together. In order
to do this, we must create a folder/file structure.

\subsection{ Data Access - Folder Structure }
Let's say we are creating an Overview page. The data structure will look as
follows:
\begin{forest}
  [overview
    [src
      [lib
        [services
          [\/choose-size.service.ts,file]
          [\/choose-size.service.spec.ts,file]
        ]
        [graphql
          [\/choose-size.fragments.ts,file]
          [\/choose-size.queries.spec.ts,file]
          [\/choose-size.mutations.ts,file]
        ]
        [+state
          [\/choose-size.actions.ts,file]
          [\/choose-size.effects.spec.ts,file]
          [\/choose-size.effects.ts,file]
          [\/choose-size.facade.ts,file]
          [\/choose-size.init.ts,file]
          [\/choose-size.reducer.spec.ts,file]
          [\/choose-size.reducer.ts,file]
        ]
        [\/choose-size.interfaces.ts,file]
        [\/data-access-choose-size.module.spec.ts,file]
        [\/data-access-choose-size.module.ts,file]
      ]
      [\/index.ts,file]
      [\/test.ts,file]
    ]
    [\/karma.conf.js,file]
    [\/tsconfig.lib.json,file]
    [\/tsconfig.spec.json,file]
    [\/tslint.json,file]
  ]
\end{forest}

Using this folder/file structure, we can enforce there being a single interface
used across all files within our app that are using data. This will ensure that
even though we mock all data within specs, as well as all services being used
within our components.

\subsection{ Example of How Interface Might Be Used in Real Time }
Now that we have our folder/file structure in place, we can prove how having a
singular interface can be used to make sure all of our files are in sync.

\begin{lstlisting}
export interface GridForm {
  column: string;
  row: string;
  pixelSize: string;
}
\end{lstlisting}

\subsubsection{ Service for Pulling in Pre-Populated Grid Form }
In our service, we will use the interface to determine what sort of data we
expect to be pulled in.

\begin{lstlisting}
getGridForm(projectId: string): Observable<GridForm> {
  const query = GridFormQuery;
  const variables = {
    projectId
  };

  const form$ = this.apollo.query<GridForm>({ query, variables });

  return from(buyers$).pipe(pluck('data'));
}
\end{lstlisting}

\subsubsection{ Service Spec for Pulling in Pre-Populated Grid Form }
In the spec for our service, we will have one consistent piece of data that will
be used throughout the service spec:
\begin{lstlisting}
const gridForm: GridForm = {
  column: "20";
  row: "20";
  pixelSize: "20";
};
\end{lstlisting}

Here we are using the interface to make sure that the mocked data used with the
service stays true to the data that is expected to be returned. If the data
ever changes in actual app, the interface will be there to make sure our specs
data mocks are up to data as well.

\subsubsection{ Reducer for populating state with appropriate Grid }
For simplicity sake within our app, we are going to take the data as is, and
pass it directly into our store to be used within app:
\begin{lstlisting}
export function gridFormReducer(
  state: GridForm,
  action: BuyerAction
): GridForm {
  switch (action.type) {
    case BuyerTypes.FormLoaded: {
      return {
        ...state
      };
    }
  }
}
\end{lstlisting}

Here we have the interface telling our app that all data within our reducer
must consist of the three items we have specified in our GridForm interface.

\subsubsection{ Reducer Spec for populating state with appropriate Grid }
\begin{lstlisting}
  const gridForm: GridForm = {
    column: "20";
    row: "20";
    pixelSize: "20";
  };

  describe('gridFormLoaded action', () => {
    it('should populate the buyer entities and ids', () => {
      const action = new FormLoaded(gridForm);
      const state = gridFormReducer(initialState, action);

      expect(state).toEqual(gridForm);
    });
  });
\end{lstlisting}

Here we have a very simply unit test that once again has the same data that is
used across the app. By having an interface and using it for the data within the
interface we can make sure that the data for the reducer spec is up to date with
actual app.

\subsubsection{ Effect for populating state with appropriate Grid }
\begin{lstlisting}
@Effect()
loadGridForm$ = this.dataPersistence.fetch(BuyerTypes.LoadGridForm, {
  run: (action: LoadGridForm, state: GridForm) => {
    const projectId = this.projectFacade.getProjectIdFromState(state);

    return this.service
      .getGridForm(action.payload, projectId)
      .pipe(map((gridForm: GridForm) => new GridFormLoaded(gridForm)));
  },

  onError: (action: LoadGridForm, error) => {
    console.error('Error', error);
  },
});
\end{lstlisting}

In our effect, using the facade pattern \footnote{it is calling the effect,
pulling in data, and then having the appropriate action fired off, for saying
data is loaded}. In our param for state, the most data heavy part of our effect,
we are once again using the same interface.

\subsubsection{ Effect Spec for populating state with appropriate Grid }
\begin{lstlisting}
const gridForm: GridForm = {
  column: "20";
  row: "20";
  pixelSize: "20";
};

const projectId = '123';

describe('loadBuyers$', () => {
  beforeEach(() => {
    spyOn(service, 'getGridForm').and.returnValue(of(gridForm));
  });

  it('should work', () => {};
    const action = new LoadBuyers();
    const completion = new BuyersLoaded(gridForm);

    actions$ = hot('-a', { a: action });
    const expected$ = cold('-c', { c: completion });

    expect(effects.loadGridForm$).toBeObservable(expected$);
    expect(service.getGridForm).toHaveBeenCalledWith(projectId);
  });
});
\end{lstlisting}

Here we are once again attaching an interface for gridForm, our data, so that it
is consistent across our application.

\subsubsection{Wrapping Up}
One might think, since we are using the same data across many parts of our
application, that within our interface file, we should do two things. One, create
an interface as we are already doing. Second, generate mock data, so that we
can re-use it across our application. My only concern with this approach, is
that it has the potential to be unintuitive and unweildy. Unintuitive, because
why would someone using an Angular project for the first time expect mocked data
to be in an interface file. Unweildy, because what happens when a particular
subset of data wasn't pulled from the interface file? It can cause data to be
spattered all over the place.
