\maketitle{}
\section{ Interfaces and Unit Testing }
In unit testing it can be very difficult to keep in sync the mocked data you
are using, with actual data used within app's actual live UI. The easiest, and
most efficient way of doing this is creating interfaces. The part where it
becomes tricky, is that generally data is used in multiple places. For instance,
we might have state that is contained in a separate component, wherein the data
originates from. In addition, the data might also be used in some other component
as well as service.

\subsection{ In Sync Data - Interface Architecture }
An interface at it's core is responsible for making sure that data follows a
pre-described schema. The part, however, that is unintuitive in an Angular
setting, is what happens when you have services, components, state, and spec
files all vying for the same data.

\subsubsection{ Interface Architecture - The Dillema }
As we discussed in the previous paragraph, in an Angular application, there will
be services, components, state and spec files vying for the same data. The
dillema when it comes to interfaces, however, is that they need data in
different ways. I would like to layout this data in detail.

Let's imagine that we have a data-table that we need to specify data:
\begin{itemize}
  \item Service - Used to determine status of checkbox logic. It only needs to
  know length of data, and actual data is irrelevant. Respective spec, only
  needs to be aware of similar data.
  \item Component - Needs to know actual data, so that it can pass along
  observable stream component html. Respective spec needs to be aware of data.
  \item State - Depnding on the reducer, or effect, it might need all of the
  data, or none of it. Respective spec will need to familiar of similar data.
\end{itemize}

\subsection{ In Sync Data - The Solution }
As one can see, it is actually counter-intuitive to create a singular interface
for one's service, state, component(s), and their respective specs. However, if
one does not use the same singular spec for all of them, one runs the risk of
them getting out of sync with each other. The data inside of the object might
make all the difference when it coems to causing unit tests to fail.

The solution is as follows. There should be a singular interface that exists
for the root of the following files:
\begin{enumerate}
  \item Services[Includes spec files]
  \item State[includes spec files]
  \item GraphQL(Interfaces not used, but influenced by, and therefore important
  to be in the same directory)
  \item Module(Interface not used for)
\end{enumerate}

This, however, requires that all the files be tightly coupled together. In order
to do this, we must create a folder/file structure.

\subsection{ Data Access - Folder Structure }
Let's say we are creating an Overview page. The data structure will look as
follows:
\begin{forest}
  [overview
    [src
      [lib
        [services
          [\/choose-size.service.ts,file]
          [\/choose-size.service.spec.ts,file]
        ]
        [graphql
          [\/choose-size.fragments.ts,file]
          [\/choose-size.queries.spec.ts,file]
          [\/choose-size.mutations.ts,file]
        ]
        [+state
          [\/choose-size.actions.ts,file]
          [\/choose-size.effects.spec.ts,file]
          [\/choose-size.effects.ts,file]
          [\/choose-size.facade.ts,file]
          [\/choose-size.init.ts,file]
          [\/choose-size.reducer.spec.ts,file]
          [\/choose-size.reducer.ts,file]
        ]
        [\/choose-size.interfaces.ts,file]
        [\/data-access-choose-size.module.spec.ts,file]
        [\/data-access-choose-size.module.ts,file]
      ]
      [\/index.ts,file]
      [\/test.ts,file]
    ]
    [\/karma.conf.js,file]
    [\/tsconfig.lib.json,file]
    [\/tsconfig.spec.json,file]
    [\/tslint.json,file]
  ]
\end{forest}

Using this folder/file structure, we can enforce there being a single interface
used across all files within our app that are using data. 
