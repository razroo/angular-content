\chapter{ RxJS and Facades }
In the chapter on state management we discussed the value of implementing facades within your ngrx/store archtiecture. Within an ngrx/store setting it is incredibly valuable, because it allows us to to tie in all stores into a singular file. 

\section{Recap on the Facade Pattern}
I want this piece of information to be as authentic as possible. Therefore, I would like to present the facade pattern in the way that I first learnt how to do so. There is a fundemental book on computer science called "Design Patterns: Elements of Re-usable Object-Oriented Software". It's a bit of classic in software, and I would say analogous to, "How to Win Friends and Influence People" by Dale Carnegie from within the business world. In there, it discussed the idea of the facade pattern is to(paraphrasing): 
\begin{enumerate}
  \item Implements a singular interface that contains multiple interfaces. Those interfaces work through the singular interface.
  \begin{enumerate}
    \item This helps readability by making the name more straight to the point. For instance, in our scenario, \lstinline{UpdateTodo}, vs. \lstinline{this.store.dispatch(new TodoUpdated(TodoPayload))}. 
    \item Usability by removing need of dependencies, and truncated form of functonality. For instance, in our scenario, we using \lstinline{UpdateTodo}, there is no need to include dependency for store. In addition, developer can now just type in \lstinline{UpdateTodo} instead 
  \end{enumerate}
  \item Provide context specific interface. This is non relevant within an ngrx setting, as state by default is generally very, very specific.
  \item Serve as a launching point for a broader re-factor, or a tightly coupled system, in favor a more loosely coupled code. For instance, in our scenario, by tying all of our state underneath a singular facade, if at a later date we want to swap out the tech needed to manage state, we can do that by simple changing the logic within a particular location. 
\end{enumerate}

\section{Recap: Ngrx + facades}
Just to re-iterate, let's say that we have a todo app, and we create a todo.facade.ts file:

\begin{lstlisting}[caption=todo.facade.ts]
@Injectable({})
class TodoFacade {
  constructor(private store: Store<any>) {}

  todos$: Observable<Todo[]> = this.store.pipe(select(getTodos));
  idOfTodos$: Observable<Todo[]> = this.store.pipe(select(getTodosIds));
  loaded$: Observable<boolean> = this.store.pipe(select(getTodosLoading));

  UpdateTodo(TodoPayload): void {
    this.store.dispatch(new TodoUpdated(TodoPayload));
  }
}  
\end{lstlisting}

Our facade within an ngrx/store setting is doing three unique things.
\begin{enumerate}
  \item Handling the store constructor for us. (With regards to unit testing this makes life alot easier.)
  \item Allows us to have to only put selector in one location(our facade), and trickle it down to all other areas. 
  \item Create a simpler to use interface for our actions, that can be re-used time and time again. Especially if we decide to change the logic, or dynanimics of how action works, we only have to update in one particular area. 
\end{enumerate}

\section{Progressing Idea of Facades over to RxJS}
Similarly, the idea of facades is incredibly valuable within RxJs. Let's imagine the most heavily used RxJS use case(atleast the most heavily used one I've come across). Perhaps, because there isn't a single appliation that doesn't use it, "Search".

Some of the business use cases with our particular company search includes: 
\begin{enumerate}
  \item Search by typing text into search bar(let's say here searching for companies)
  \item Route between search, company, or company details view 
  \item Company details
\end{enumerate}

Our particular RxJS code 
\begin{lstlisting}[caption=search-companies.compoennt.ts]
@Component({
  selector: 'search-companies',
  templateUrl: './search-companies.component.html',
  styleUrls: ['./search-companies.component.scss']
})
export class SearchCompaniesComponent implements OnInit {
  companies$: Observable<Company[]>;
  searchCriteria = new FormControl();

  constructor(private companyService: CompanyService) {}

  ngOnInit() {
    // Observable stream to input control values
    const searchBy$ = this.searchTerm.valueChanges;
    
    this.companies$ = searchBy$.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      startWith(''),      
      switchMap((criteria:string) => {
        const request$ = this.companyService.searchCompanies(criteria);
        return !criteria.length ? of([]) : request$          
      })
    );
  }
}  
\end{lstlisting}

Let's diessect our RxJS code: 
\begin{enumerate}
  \item \lstinline{debounceTime(300)} - Only after 300 milliseconds, will the request go through. If the user decides to type once again, within 300 milliseconds, the 300 millisecond count time, restarts again. 
  \item \lstinline{distinctUntilChanged()} - Let's say the string the user inputs is "Apple". Then they decide to delete the e "Appl", but then add it again, "Apple", this will not trigger the http request. This is because, this is the exact same word that it was initially. 
  \item \lstinline{startWith('')} - Not completely neccesary, but will make sure that is an empty string everytime we initialize this page again. 
  \item \lstinline{switchMap} - Powerful, because it has an internal project function, which allows us to break from the observables and use our "transformed" value. Here we are passing it to the service, which calls our compnayService, based on search criteria user passed in. 
\end{enumerate}

Obviously the logic here is contained within the 