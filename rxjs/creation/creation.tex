\chapter{RxJS Common Creation Operators}
Just to re-iterate, one of the more novel parts of this book, is that when we 
introduce a new concept we tie that into the actual enterprise scenario, 
wherein this is repeated. Allowing for one to use code directly in one'e 
application, without having to think about it too much how it is used. 

The common RXJS creation operators are: 
\begin{enumerate}
  \item from
  \item fromEvent
  \item of
\end{enumerate}

\section{from}
A common scenario when using from, is that you would like to return an http 
request, and turn that into an observable. Razroo has a very opinionated 
architecture, and we follow through with that architecture throughout the 
book. We realize that every scenario may not be able to follow the ideal
architecture. However, let's assume that you are using three very integral
libraries: 
\begin{enumerate}
  \item GraphQL 
  \item Apollo Client
  \item ngrx/store
\end{enumerate}

\lstinline{from} will be used in a scenario wherein you are trying to convert 
an apollo query into an observable, 

\begin{lstlisting}[caption=posts.service.ts]
getPosts(): Observable<Post[]> {
  const posts$ = this.apollo.query({ query: GetPosts });

  return from(posts$).pipe(pluck('data', 'posts'));
}
\end{lstlisting}

so that it can be passed into your ngrx/store:

\begin{lstlisting}[caption=posts.effects.ts]
@Effect() loadPosts$ = this.dataPersistence.fetch(
  PostsActionTypes.LoadPosts,
  {
    run: (action: LoadPosts, state: PostsPartialState) => {
      return this.postsService.getPosts().pipe(
        map((posts: Post[]) => new PostsLoaded(posts))
      );
    },
    onError: (action: LoadPosts, error) => {
      console.error('Error', error);
      return new PostsLoadError(error);
    }
  }
);
\end{lstlisting}

\section{fromEvent}
Whole \lstinline{fromEvent} is a common operator in RxJS, I would argue that within 
an Angular setting, it is not a common operator. There is truly no scenario within 
Angular wherein \lstinline{fromEvent} makes sense. Instead use the core Angular 
even handlers within your template: 

\begin{lstlisting}[caption=user-form.input.ts]
<button (click)="submitForm()">
\end{lstlisting}

\begin{lstlisting}[caption=user-form.component.ts]

submitForm(userData: User) {
  this.userFormFacade.submitForm(userData);
}
\end{lstlisting}

\section{of}
\lstinline{of} while similar in purpose to of, will convert a value to an 
observable. However, the main difference between the two, can be seen here
in this snipper of code:
\begin{lstlisting}
// the subscribe here, will emit all of the data at once  
// [1, 2, 3]
Observable.of([1, 2, 3]).subscribe(x => console.log(x));  

// the subscribe here, will iterate through data one at a time
Observable.from([1, 2, 3]).subscribe(x => console.log(x));  
// 1
// 2
// 3
\end{lstlisting} 

\lstinline{from} for the most part is preferabble, as data will usually 
be contained in an array, and \lstinline{from} sidesteps the need of 
tapping into the array, doing something like this:
\begin{verbatim}
console.log(data[0]);
\end{verbatim}

From my personal experience, \lstinline{of} becomes invaluable when it comes 
to mocking data within your unit tests. For instance, doing something such as
the following: 
\begin{lstlisting}
const postMock = {
  id: '123',
  title: 'test title',
  featureImage: 'sample feature image',
  created_at: '2019-08-05T07:49:11.405Z' 
}

const postMock$ = of(postMock);
\end{lstlisting}

This is the most efficient solution is this scenario for mocking data, and 
comes up quite frequently within your app, and something to be aware of. 

