\chapter{ Debugging Rxjs }
One of the more difficult things to master when learning RxJS, is learning how to debug a stream. Within regular Javascript/Typescript, debugging is relatively easy. I find myself going to two differet methods when following this approach: 
\begin{enumerate}
  \item console.log
  \item source when dev tool
\end{enumerate}

\section{Using Console.log}
In a regular Typescript/Javascript setting a \lstinline{console.log} is a relatively simple concept. We show(,or log out), whatever the current status is of our code at a given time. So for instance, let's say that we wanted to create a piece of code that takes the first and last name, and combines(proper software term is concantenates) them together. Something like this: 
\begin{lstlisting}[caption=console in action]
combinedName(firstName: string, lastName: string): string {
  return firstName + lastName;
}
\end{lstlisting}

So the developer, due to the low level of the logic of this function, mistakenly forgets to add a white space in between. He decides to console out the function, before applying the logic directly to the application, to make sure it works as expected. So the developer does something like this(assuming we are talking about a method within a service): 
\begin{lstlisting}
console.log(this.combinedName('James', 'Harden));
\end{lstlisting}

The developer is expecting it to look like 'James Harden', but instead the developer finds out that it is 'JamesHarden'. The developer immediately realizes that there is a missing white space in between the two words, and edits the function, so that it works as expected: 

\begin{lstlisting}
combinedName(firstName: string, lastName: string): string {
  return firstName + ' ' + lastName;
} 
\end{lstlisting}
He then goes back, and refreshes the page where the \lstinline{console.log} was,and finds out that it now looks like: 
\begin{verbatim}
'James Harden'  
\end{verbatim}

\mybox{In practice, something like this should ideally be tested using unit tests. However, many enterprise applications unfortunately are not built in the optimal fashion for various reasons.}

\section{Using Source Within Developer Tool}
The only other tool that I usually have within my tool belt to dissect an error immediately is the developer tools within chrome. Any time that there is an error, there is a unique signature that your code will throw out. In a modern day application, this will happen even if it isn't unique to your application. So the console.log --> source tool will simly display the error whenever it happens. 

\section{Debugging within RxJS - The Dilemma}
The immediate issue with debugging RxJS from a traditional setting, is that it's only the final result that can be debugged. So you might have a stream of numerous chained events: 
\begin{lstlisting}
this.companies$ = searchBy$.pipe(
  debounceTime(300),
  distinctUntilChanged(),
  startWith(''),      
  switchMap((criteria:string) => {
    const request$ = this.companyService.searchCompanies(criteria);
    return !criteria.length ? of([]) : request$          
  })
);  
\end{lstlisting}

In the above, only in the switchMap, or in a subscribe will we be able to tap into the result that we are looking for. For instance, let's go through the potential bugs that might happen with the above stream: 

\begin{enumerate}
  \item The result might not appear because it is within the \lstinline{debounceTime}
  \item It might not have changed from the previous result i.e. \lstinline{distinctUntilChanged} and therefore is not triggered.
  \item The \lstinline{companyService.searchCompanies} request might be erroring out, or there might be some internal logic to the \lstinline{companyService.searchCompanies} request making something error out.
\end{enumerate}

So of course we need a similar way to console out, similar it works in non RxJS. 

\section{Using Tap}