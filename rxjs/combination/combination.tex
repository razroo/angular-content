\chapter{Combination}

\section{combineLatest}
Combine latest allows us to combine multiple observables into one, and have 
the subscribe emit when either of them are called. A common enterprise 
example, is let's say that we have a form. The form gives us a search bar,
but we would like to have our search bar, search against a drop down as well. 

\begin{lstlisting}[caption=search-form.component.ts]
export class AppComponent implements OnInit, OnDestroy {
  private destroyed$ = new Subject<void>();

  get searchText() {
    return this.form.get('searchText');
  }

  get searchFor() {
    return this.form.get('searchFor');
  }

  form: FormGroup;

  constructor(formBuilder: FormBuilder) {
    this.form = formBuilder.group({
      searchText: null,
      searchFor: null,
    });
  }

  ngOnInit() {
    const searchText$ = this.searchText.valueChanges;
    const searchFor$ = this.searchFor.valueChanges;

    // combineLatest emits when any of the source observables
    // emits (provided that they have all emitted once to
    // begin with). that's why the console.logs start appearing
    // after values are selected for both form controls
    combineLatest(searchText$, searchFor$)
      .pipe(takeUntil(this.destroyed$))
      .subscribe(([searchText, searchFor]) => {
        console.log('searchText', searchText);
        console.log('searchFor', searchFor);

        // make a call to an API whenever either observable
        // emits
        // this.apiService.loadData(searchText, searchFor)
      })
  }

  ngOnDestroy() {
    this.destroyed$.next();
    this.destroyed$.complete();
  }
} 
\end{lstlisting}

\section{concat}
One very useful use of concat within an enterprise setting, is that if you 
have all of the data you need available. However, you would like to make 
sure that they emit in proper order of each other. Using the following: 
\begin{lstlisting}[caption=concat-example.ts]
import { concat } from 'rxjs/operators';

concat(printLog1, printLog2, printLog3); 
// printLog1 emits, then printLog2, and then printLog3
\end{lstlisting}

In a realistic scenario, this will come up in a situation such as we would like to

\begin{lstlisting}[caption=search-bar.component.ts]
export class AppComponent {
  searchStream$ = new BehaviorSubject('');

  constructor(private productsService: ProductsService) {}

  obs$ = this.searchStream$.pipe(
    debounceTime(200),
    distinctUntilChanged(),
    switchMap((query) => 
      concat(
        of({ type: 'start'}),
        this.productsService.getByFilter(query).pipe(map(value => ({ type: 'finish', value })))
      ))
  );
}   
\end{lstlisting}

\section{merge}
Merge allows us to "merge" multiple observables into one singular observable. A
great re-occuring real world example, is to group multiple events into single 
observable. For instance, if we are trying to create a music player:
\begin{lstlisting}[caption=player-buttons.component.ts]
const start$ = fromEvent(this.startButton.nativeElement, 'click').pipe(mapTo(true));
const pause$ = fromEvent(this.pauseButton.nativeElement, 'click').pipe(mapTo(false));
const reset$ = fromEvent(this.resetButton.nativeElement, 'click').pipe(mapTo(null));

this.playerButtons$ = merge(start$, pause$, reset$, stateChange$).pipe(
  switchMap(val => {
    if(val === null) // reset 
    else if(val) // start
    else // stop
  }
);
\end{lstlisting}

Here, by merging all of our events within a single observable, it tidies up our
code base, and allows us to deal with all of our events in a singular fashion.

\section{startWith}
There is a really old tweet by Andre Saltz, that is no longer available for some 
reason. Regardless, the tweet goes something along these lines: 
\begin{quote}
\say{You rarely want \lstinline{combineLatest()}, unless mixed with \lstinline{startWith()}}
\end{quote}

\lstinline{startWith}, as the name implies, is a way to tell your observable 
to start with a paticular value. With the advent of \lstinline{behaviorSubject}
which allows you to supply the initial value, or the alternative scenario 
of data being retrieved from the backend, with the use of Angular's 
\lstinline{async} pipe, wherein the initial value is superfluous. 

However, there is one scenario wherein the \lstinline{startWith} pipe does get
used alot within an Angular setting. That is in conjuction with 
\lstinline{combineLatest}. However, even in this scenario, I would like to argue
that \lstinline{behaviorSubject} get's used more. \footnote{To see why not to 
use startWith and go with behaviorSubject, check the addendum}

\section{withLatestFrom}
\lstinline{withLatestFrom} will combine two observables with each other. However,
only when the value changes for the primary observable, will the subscribe be 
triggered. If the secondary observable value changes, the subscribe will not be 
triggered. 

Let's use an common example that will occur within the enterprise architecture 
set up by Razroo. Let's say that you are using \lstinline{ngrx/store}, and
that you would like to make determine whether, or not a blog post exists 
already. 

\begin{lstlisting}
color$.pipe(withLatestFrom(logo$))
  .subscribe(([color, logo]) => console.log(`${color} shirt with ${logo}`));
\end{lstlisting}

\section{zip}

\begin{lstlisting}[caption=yin-yang.component.ts]
const yin   = Rx.Observable.of('peanut butter', 'wine','rainbows')
const yang  = Rx.Observable.of('jelly', 'cheese', 'unicorns')

const combo = Rx.Observable.zip(yin, yang)

combo.subscribe( arr => console.log(arr) )
// peanut butter, jelly
// wine, cheese
// rainbows, unicorns  
\end{lstlisting}

Haven't really found a common scenario for using this within an Angular 
setting.