\chapter{Combination}

\section{combineLatest}
Combine latest allows us to combine multiple observables into one, and have 
the subscribe emit when either of them are called. A common enterprise 
example, is let's say that we have a form. The form gives us a search bar,
but we would like to have our search bar, search against a drop down as well. 

\begin{lstlisting}[caption=search-form.component.ts]
export class AppComponent implements OnInit, OnDestroy {
  private destroyed$ = new Subject<void>();

  get searchText() {
    return this.form.get('searchText');
  }

  get searchFor() {
    return this.form.get('searchFor');
  }

  form: FormGroup;

  constructor(formBuilder: FormBuilder) {
    this.form = formBuilder.group({
      searchText: null,
      searchFor: null,
    });
  }

  ngOnInit() {
    const searchText$ = this.searchText.valueChanges;
    const searchFor$ = this.searchFor.valueChanges;

    // combineLatest emits when any of the source observables
    // emits (provided that they have all emitted once to
    // begin with). that's why the console.logs start appearing
    // after values are selected for both form controls
    combineLatest(searchText$, searchFor$)
      .pipe(takeUntil(this.destroyed$))
      .subscribe(([searchText, searchFor]) => {
        console.log('searchText', searchText);
        console.log('searchFor', searchFor);

        // make a call to an API whenever either observable
        // emits
        // this.apiService.loadData(searchText, searchFor)
      })
  }

  ngOnDestroy() {
    this.destroyed$.next();
    this.destroyed$.complete();
  }
} 
\end{lstlisting}

\section{concat}
One very useful use of concat within an enterprise setting, is that if you 
have all of the data you need available. However, you would like to make 
sure that they emit in proper order of each other. Using the following: 
\begin{lstlisting}[caption=concat-example.ts]
import { concat } from 'rxjs/operators';

concat(printLog1, printLog2, printLog3); 
// printLog1 emits, then printLog2, and then printLog3
\end{lstlisting}

In a realistic scenario, this will come up in a situation such as we would like to

\begin{lstlisting}[caption=search-bar.component.ts]
export class AppComponent {
  searchStream$ = new BehaviorSubject('');

  constructor(private productsService: ProductsService) {}

  obs$ = this.searchStream$.pipe(
    debounceTime(200),
    distinctUntilChanged(),
    switchMap((query) => 
      concat(
        of({ type: 'start'}),
        this.productsService.getByFilter(query).pipe(map(value => ({ type: 'finish', value })))
      ))
  );
}   
\end{lstlisting}

\section{merge}
Merge allows us to "merge" multiple observables into one singular observable. A
great re-occuring real world example, is to group multiple events into single 
observable. For instance, if we are trying to create a music player:
\begin{lstlisting}[caption=player-buttons.component.ts]
const start$ = fromEvent(this.startButton.nativeElement, 'click').pipe(mapTo(true));
const pause$ = fromEvent(this.pauseButton.nativeElement, 'click').pipe(mapTo(false));
const reset$ = fromEvent(this.resetButton.nativeElement, 'click').pipe(mapTo(null));

this.playerButtons$ = merge(start$, pause$, reset$, stateChange$).pipe(
  switchMap(val => {
    if(val === null) // reset 
    else if(val) // start
    else // stop
  }
);
\end{lstlisting}

Here, by merging all of our events within a single observable, it tidies up our
code base, and allows us to deal with all of our events in a singular fashion.

\section{startWith}

\section{withLatestFrom}

\section{zip}