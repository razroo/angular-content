\chapter{Cold v Hot Observables}
One of the foundational understandings of RxJS, is understanding what the 
difference between cold and hot ovservables is. First and foremost, let's 
keep in mind difference:
\begin{quote}
\say{When the data is produced by the Observable itself, we call it a cold Observable. When the data is produced outside the Observable, we call it a hot Observable.}
\end{quote}

There is a lot to unpack here, so let's disect. 

\section{Cold Observables}
To re-iterate, an observable is called "cold", when the data is produced inside of the observable. An observable is only instantiated, once the
subscribe is called. So, we can have something like this: 

\begin{lstlisting}[caption=observable without subscribe]
import { Subject } from 'rxjs';

const randomVal$ = new Subject().next(Math.random());}
\end{lstlisting}
That will actually create an observable, but it will not be called until we add a \lstinline{subscribe} to the code. 

\begin{lstlisting}[caption=observable with subscribe]
import { Subject } from 'rxjs';

const randomVal$ = new Subject().next(Math.random());}

// Subscribe to run the combined functions
randomVals$.subscribe(x => console.log(x));
\end{lstlisting}

For that reason, it's possible to have it subscribe mutliple times to a singular observable, yet get different results each time. If in the above 
code, we created two subscribes, so that our code now look like this: 
\begin{lstlisting}[caption=observable with two subscribes]
import { Subject } from 'rxjs';

const randomVal$ = new Subject().next(Math.random());}

// Subscribe to run the combined functions
randomVals$.subscribe(x => console.log(x));
// 0.24957144215097515 (random number)
randomVals$.subscribe(x => console.log(x));
// 0.004617340049055896 (random number)
\end{lstlisting}

As we can see in the comments above, each subscribe will give us a new value.

\subsection{Maintaining Same Value for Both Subscribers - Venture into the Land of Hot}
However, let's say that we wanted to maintain the same random value for 
both subscribers. What we would do, it create a constant outside of the 
subject logic, so that it remains for both. 

\begin{lstlisting}[caption=Turning Cold into Hot]
import { Subject } from 'rxjs';

const random = Math.random();
const randomVal$ = new Subject().next(random);}

// Subscribe to run the combined functions
randomVals$.subscribe(x => console.log(x));
// 0.24957144215097515 (random number)
randomVals$.subscribe(x => console.log(x));
// 0.24957144215097515 (random number)
\end{lstlisting}

Here, we have moved the data producer(i.e. \lstinline{Math.random()}) out of observable. So, to go back to our definition of a hot, vs cold observable. Being that this data was produced outside of the observable, our observable now just went from being a cold observable to a hot observable. Viola and yes it is that easy! However, as time goes on, you will have to apply this logic to the scenario to truly understand what is producing the data.

\section{Hot Observables}
So, while we have produced a good example for what a cold vs hot observable is, we have not produced an enterprise example, that really drives it home. The truth is, that actually \lstinline{@ngrx/store} is based on hot observables. In particular when using \lstinline{@ngrx/effects}. 
\begin{lstlisting}
@Effect() loadPosts$ = this.dataPersistence.fetch(
  PostsActionTypes.LoadPosts,
  {
    run: (action: LoadPosts, state: PostsPartialState) => {
      return this.postsService.getPosts().pipe(
        map((posts: Post[]) => new PostsLoaded(posts))
      );
    },
    onError: (action: LoadPosts, error) => {
      console.error('Error', error);
      return new PostsLoadError(error);
    }
  }
);  
\end{lstlisting}

As we can see, we are passing in an action that already exists. In fact, we are using nrwl's utility function \lstinline{dataPersistence} to make sure our data persists. If we dig deep, we will see that it extends this core functionality of \lstinline{ngrx/effects}: 
\begin{lstlisting}[caption=data-persistence.d.ts file from nrwl library]
/**
* @whatItDoes Provides convenience methods for implementing common operations of persisting data.
*/
export declare class DataPersistence<T> {
  store: Store<T>;
  actions: Actions;
  constructor(store: Store<T>, actions: Actions);  
\end{lstlisting}

\begin{lstlisting}[caption=actions.d.ts file from ngrx/effects library]
export declare class Actions<V = Action> extends Observable<V> {
  constructor(source?: Observable<V>);
  lift<R>(operator: Operator<V, R>): Observable<R>;
  static ngInjectableDef: ɵngcc0.ɵɵInjectableDef<Actions<any>>;
}  
\end{lstlisting}

Here we are extending the \lstinline{Observable} class. 

So, as we can see, we are accepting data from an action, thereby making the data produced outside of our effects observable. This is a classic scenario that happens time and time again, that is in truth a hot observable. Knowing this truth is very valuable, especially when it comes to unit testing your code.

\section{Why Make an Observable Hot?}
To re-iterate, and Observable by default is cold. So, why would one want to make an observable hot? This has value in two particular situations: 
\begin{enumerate}
  \item Have multiple subscribers get the same data
  \item New instance of something for each observable creation(e.g. Websocket); By passing it through, and making it as a hot observable, allows our code to be dry.
\end{enumerate}

