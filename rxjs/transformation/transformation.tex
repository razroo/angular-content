\chapter{Transformation}
Transforming in RxJS is the process of modifying a value. It is quite 
a common occurence within RxJS.

\section{bufferTime}
\lstinline{bufferTime} will collect a value until the provided time elapses. 
Once time has ellapsed it will emit values collected during that time as an 
array. (It will not unsubscribe from the observable). A good example of when we
would want to use bufferTime, is if we want to give the user notifications 
within their application. However, we don't want to flood them with 
notifications. In addition, the updates within our application are quite 
frequent, and are updated quite frequently. Think a stock market application.

\begin{lstlisting}
this.notificationService.updates$.pipe(
  bufferTime(5000)
).subscribe(batch => {
  this.notifications = notifications;
});  
\end{lstlisting}

\section{RxJs Higher Order Mapping}
Before we dive into these four values it's important to note that they are 
all similar in one regard. It will subscribe to an inner observable. This 
means that it allows for access to the value, and will create an inner 
observable. This inner observable can then be modified. Why create an inner
observable? Well this get's into something called higher order observables. 
Think about the way classic promises work. Let's say we wanted to modify the 
data nested twice within our observable.
\begin{lstlisting}
this.postService.getPosts().then(data => {
  const blogIds = data.map(data => data.id);
  this.analyticsService.analytics(blogIds).then(analyticsData => {
    this.analyticsData = analyticsData;; 
  });
});  
\end{lstlisting}

In the above code, we have one promise inside of another promise. RxJS allows us
to do all of these within the same stream. It allows for the observable stream
to be more manageable and concise(i.e. avoiding nested subscribes). These are
what would be called higher order observables. 

\section{concatMap}
\lstinline{concatMap} will map values to the inner observable, subscribe and 
emit in order. Emphasis is emit in order, that is what \lstinline{concatMap} 
specializes in. A great way to visualize this, is let's say we wanted to 
create a cascading effect within our application. 

\begin{lstlisting}[caption=data-table.component.ts]
getItems(ids: number[]): Observable<Item> {
  return from(ids).pipe(
     concatMap(id => <Observable<Item>> this.httpClient.get(`item/${id}`))
  );
}
\end{lstlisting}

In the above, the previous observable will emit first, causing a waterfall 
effect within our app. 

\section{map} 
\lstinline{map} will apply a projection to each value in source. For instance: 
\begin{lstlisting}[caption=rxjs map example]
// RxJS v6+
import { from } from 'rxjs';
import { map } from 'rxjs/operators';

//emit (1,2,3,4,5)
const source = from([1, 2, 3, 4, 5]);
//add 10 to each value
const example = source.pipe(map(val => val + 10));
//output: 11,12,13,14,15
const subscribe = example.subscribe(val => console.log(val));
\end{lstlisting}

A common occurence within actual applications is to use map within a 
switchMap, when using an \lstinline{ngrx/effect}. That way, it returns the map
to the \lstinline{switchMap}, and kills any other observables from happening.

\begin{lstlisting}[caption=map example]
@Effect()
loadAllBlogPosts$: Observable<any> = this.actions$.pipe(
  ofType(PokemonActions.loadPokemon),
  switchMap(() =>
    this.postsService.getAll().pipe(
      map(posts => PokemonActions.loadPokemonSuccess({ posts })),
      catchError(message => of(PokemonActions.loadPostsFailed({ message })))
    )
  )
);  
\end{lstlisting}

Here we are mapping and returning an action to our effect. This allows us to 
hook in an effect to our general /lstinline{ngrx/effect} ecosystem.

\section{mergeMap}

\section{scan}

\section{switchMap}
\lstinline{switchMap} (similar to \lstinline{concatMap} and \lstinline{mergeMap}
will create), will create an inner observable. The main difference is that it
will complete the previous inner observable. We can re-use the example we used
for \lstinline{map}. 

\begin{lstlisting}[caption=switchMap example]
@Effect()
loadAllBlogPosts$: Observable<any> = this.actions$.pipe(
  ofType(PokemonActions.loadPokemon),
  switchMap(() =>
    this.postsService.getAll().pipe(
      map(posts => PokemonActions.loadPokemonSuccess({ posts })),
      catchError(message => of(PokemonActions.loadPostsFailed({ message })))
    )
  )
);  
\end{lstlisting}

In this example, whenever a new loadAllBlogPosts is emitted, we no longer 
have a need for the previous stream, so \lstinline{switchMap} is the 
appropriate observable in this scenario. 
