\chapter{Transformation}
Transforming in RxJS is the process of modifying a value. It is quite 
a common occurence within RxJS.

\section{bufferTime}
\lstinline{bufferTime} will collect a value until the provided time elapses. 
Once time has ellapsed it will emit values collected during that time as an 
array. (It will not unsubscribe from the observable). A good example of when we
would want to use bufferTime, is if we want to give the user notifications 
within their application. However, we don't want to flood them with 
notifications. In addition, the updates within our application are quite 
frequent, and are updated quite frequently. Think something along the lines of
a stock market application.

\begin{lstlisting}
this.notificationService.updates$.pipe(
  bufferTime(5000)
).subscribe(batch => {
  this.notifications = notifications;
});  
\end{lstlisting}

\section{RxJs Higher Order Mapping}
Before we dive into these four values it's important to note that they are 
all similar in one regard. It will subscribe to an inner observable. This 
means that it allows for access to the value, and will create an inner 
observable. This inner observable can then be modified. Why create an inner
observable? Well this get's into something called higher order observables. 
Think about the way classic promises work. Let's say we wanted to modify the 
data nested twice within our promise:
\begin{lstlisting}
this.postService.getPosts().then(data => {
  const blogIds = data.map(data => data.id);
  this.analyticsService.analytics(blogIds).then(analyticsData => {
    this.analyticsData = analyticsData;; 
  });
});  
\end{lstlisting}

In the above code, we have one promise inside of another promise. RxJS allows us
to do all of these within the same stream. It allows for the observable stream
to be more manageable and concise(i.e. avoiding nested subscribes). These are
what would be called higher order observables. 

\section{concatMap}
\lstinline{concatMap} will map values to the inner observable, subscribe and 
emit in order. Emphasis is emit in order, that is what \lstinline{concatMap} 
specializes in. A great way to visualize this, is let's say we wanted to 
create a cascading effect within our application. 

\begin{lstlisting}[caption=data-table.component.ts]
getItems(ids: number[]): Observable<Item> {
  return from(ids).pipe(
     concatMap(id => <Observable<Item>> this.httpClient.get(`item/${id}`))
  );
}
\end{lstlisting}

In the above, the previous observable will emit first, causing a visual 
waterfall effect within our app. 

\section{map} 
\lstinline{map} will apply a projection to each value in source. For instance: 
\begin{lstlisting}[caption=rxjs map example]
// RxJS v6+
import { from } from 'rxjs';
import { map } from 'rxjs/operators';

//emit (1,2,3,4,5)
const source = from([1, 2, 3, 4, 5]);
//add 10 to each value
const example = source.pipe(map(val => val + 10));
//output: 11,12,13,14,15
const subscribe = example.subscribe(val => console.log(val));
\end{lstlisting}

A common occurence within actual applications is to use map within a 
switchMap, when using an \lstinline{ngrx/effect}. That way, it returns the map
to the \lstinline{switchMap}, and kills any other observables from happening.

\begin{lstlisting}[caption=map example]
@Effect()
loadAllBlogPosts$: Observable<any> = this.actions$.pipe(
  ofType(PokemonActions.loadPokemon),
  mergeMap(() =>
    this.postsService.getAll().pipe(
      map(posts => PokemonActions.loadPokemonSuccess({ posts })),
      catchError(message => of(PokemonActions.loadPostsFailed({ message })))
    )
  )
);  
\end{lstlisting}

Here we are mapping and returning an action to our effect. This allows us to 
hook in an effect to our general \lstinline{ngrx/effect} ecosystem.

\section{mergeMap}
\lstinline{switchMap} (similar to \lstinline{mergeMap} and \lstinline{concatMap}),
will create an inner observable. The main difference, is that \lstinline{mergeMap},
will merge all observables into one(, as opposed to \lstinline{switchMap}, 
which will cancel all prior observables). 

\begin{lstlisting}[caption=mergeMap example]
  @Effect()
  loadAllBlogPosts$: Observable<any> = this.actions$.pipe(
    ofType(PokemonActions.loadPokemon),
    mergeMap(() =>
      this.postsService.getAll().pipe(
        map(posts => PokemonActions.loadPokemonSuccess({ posts })),
        catchError(message => of(PokemonActions.loadPostsFailed({ message })))
      )
    )
  );  
\end{lstlisting}
\mybox{You might notice that we are using mergeMap for what might be otherwise
thought of using a switchMap for. The reason I like using mergeMap is that 
switchMap doesn't actually do anything in this scenario. Even if we were to 
cancel the inner observable the action and http request has still made it's 
way through. I feel like using mergeMap makes this scenario more transparent 
and is therefore the right thing to use in this scenario.}

\section{scan}

\section{switchMap}
\lstinline{switchMap} (similar to \lstinline{concatMap} and \lstinline{mergeMap}),
will create an inner observable. The main difference is that it will complete 
the previous inner observable, so that only the latest observable is re-used. 

\begin{lstlisting}[caption=search-bar.component.ts]
@Effect()
findAddresses: Observable<any> = this.actions.pipe(
  ofType(LocationActionTypes.FindAddresses),
  map(action => action.partialAddress),
  debounceTime(400),
  distinctUntilChanged(),
  switchMap(partialAddress => this.backend
    .findAddresses(partialAddress)
    .pipe(
      map(results => new FindAddressesFulfilled(results)),
      catchError(error => of(new FindAddressesRejected(error)))
    )
  )
);  
\end{lstlisting}
 
In the example above, we have set up our effect to handle search. It has a 
\begin{enumerate}
  \item \lstinline{debounceTime} so that if user types multiple times within
  a 400 milliseconds, it will only trigger once
  \item \lstinline{distinctUntilChanged} to handle the use case wherein user 
  deletes letters after typing, but returns to same word after deleting
  \item ...and then the magic! \lstinline{switchMap} is used within our app,
  because once a new search is made, prior observables are no longer needed 
  and can be removed. 
\end{enumerate}

It's interesting. While this has value, alternative options could have been 
used, such as \lstinline{concatMap}. Due to the finicky nature of maps, and 
complexity behind it, maps can also be considered as a way of documentation. 
