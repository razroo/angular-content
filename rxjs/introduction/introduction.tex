\chapter{ Introduction to Rxjs }

\section{ What is Reactive Programming}

Rxjs is a library based on the concept of Reactive programming. To re-iterate 
what we mentioned in the chapter on ngrx. A great founding paper discussing 
reactive programming for concurrent programming can be found here. 
\footnote{http://www-sop.inria.fr/members/Gerard.Berry/Papers/Berry-IFIP-89.pdf}

It discusses the benefit of Real Time Progamming a.k.a., reactive programming.
In it, it discusses the two main benefits of Reactive Programming:
\begin{enumerate}
  \item Asynchronous
  \item Detemrinistic
\end{enumerate}

That would be reactive programming in a nutshell. It makes sure, that one 
function happens after another. In addition, by it's definition of being 
a set of pre-made functions, it gives stability around the way we are 
transforming our data in Angular. However, really the most important part 
about Rxjs, still goes to Andre Staltz: 

\begin{quote}
  \say{Reactive Programming raises the level of abstraction of your code so you
   can focus on the interdependence of events that define the business logic...”.}
\end{quote} 
\footnote{This quote can be found in his excellent article on why you should 
consider adopting Reactive programming principles in your app 
https://gist.github.com/staltz/868e7e9bc2a7b8c1f754\#why-should-i-consider-adopting-rp}

The next question becomes how Reactive programming accomplishes the above. I 
could put a diagram here and explain what it does in detail, but for the sake 
of brevity, I am just going to jump into Rxjs code. But first, let's talk 
about the importance of Rxjs in Angular!

\section{ Rxjs's Importance in Angular }
Rxjs has a pretty big place in Angular. I would say that in your average app, 
I would consider it as one of the big three, alongside Typescript, and Ngrx. 
Even though these are independent libaries, when working on enterprise Angular
applications, I personally come across them on a day to day basis. So, while 
they are independent entities to Angular, I very much so consider them as part 
of the Angular framework. 

\section{ The Rxjs Observable }
The core of Rxjs, is the ability to program reactively using observables. Rxjs 
offers the ability to create observables, as well as manipulate them. In 
particular, there are five scenarios to keep in mind, when it comes to creating
an observabe: 
\begin{enumerate}
  \item promise
  \item counter
  \item event
  \item AJAX request
\end{enumerate}

\subsection{ Promise }
Assuming we were using Apollo client to retrieve data from our GraphQL 
requests, rxjs gives us the ability to transfer data we have retrieved into an
observable: 
\begin{lstlisting}
import { from } from 'rxjs';

// Create an Observable out of a promise
const data = from(fetch('/api/endpoint'));
// Subscribe to begin listening for async result
data.subscribe((data) => {
  console.log(data);
});  
\end{lstlisting}

In the above we are using \lstinline{from}, to convert the data we have into a 
an observable. This way, it can be accessed using subscribe. You might be 
wondering what may be the benefit of using an observable over JSON data and 
a promise in this scenario. Well, the benefit would be that if we do plan on 
mutating this data in the near future, then it will be beneficial to have data
available as an observable. In addition, being that other parts of our 
application is using observables, then being able to have them all follow 
the same logic, is beneficial to our application. 

\subsection{Counter}
\begin{lstlisting}
import { interval } from 'rxjs';

// Create an Observable that will publish a value on an interval
const secondsCounter = interval(1000);
// Subscribe to begin publishing values
secondsCounter.subscribe(n =>
  console.log(`It's been ${n} seconds since subscribing!`));
\end{lstlisting}

\subsection{Event}

\begin{lstlisting}
import { fromEvent } from 'rxjs';

const el = document.getElementById('my-element');

// Create an Observable that will publish mouse movements
const mouseMoves = fromEvent(el, 'mousemove');

// Subscribe to start listening for mouse-move events
const subscription = mouseMoves.subscribe((evt: MouseEvent) => {
  // Log coords of mouse movements
  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);

  // When the mouse is over the upper-left of the screen,
  // unsubscribe to stop listening for mouse movements
  if (evt.clientX < 40 && evt.clientY < 40) {
    subscription.unsubscribe();
  }
});
\end{lstlisting}

\subsection{AJAX Request}
\begin{lstlisting}
import { ajax } from 'rxjs/ajax';

// Create an Observable that will create an AJAX request
const apiData = ajax('/api/data');
// Subscribe to create the request
apiData.subscribe(res => console.log(res.status, res.response));
\end{lstlisting}

\section{Operators}

\subsection{Sophisticated Manipulation}
Once an observable has been created, Rxjs provides operators to manipulate 
the data contained within an obserable. The following is a great example. Let's
say that we have an observable. In this observable, we have data for user 
settings. Specifically, there are settings for currency preferences that we 
would like. Within our official schema, it looks something like this: 
\begin{lstlisting}
{
  settings {
    currency: {
      ...
    }
  }
}  
\end{lstlisting}

We would like to make sure that when we subscribe to our data store 
across the application, we would pull in a specific subset of data. We can map 
our data within our \lstinline{ngrx/store} data selector. 

\begin{lstlisting}[caption=settings.selector.ts]
const getPostsCollection = createSelector(
  getAllPostEntities,
  getAllPostIds,
  (entities: any, ids: any) => ids.map(id => entities[id])
);
\end{lstlisting}

Without having to specify what data that is every time, we can map our data 
to a specific data field. Here we are using the \lstinline{ngrx/entity} 
library, as well as the \lstinline{map} method to create a collection of 
entities. Very sophisticated, and allows us to pull in all the data we need
within the observable.

\subsection{Link Operators Together}
Rxjs offers the ability to link operators together. For instance, let's say 
within our entity we wanted to filter out all posts that have a wordCount 
that is greater than 2000. I know it seems like it's a weird key/value to have 
in an api, but just work with me here, ok?! Cool. Alright here we go: 
\begin{lstlisting}
import { filter, map } from 'rxjs/operators';

const nums = of(1, 2, 3, 4, 5);

// Create a function that accepts an Observable.
const squareOddVals = pipe(
  filter((n: number) => n % 2 !== 0),
  map(n => n * n)
);

// Create an Observable that will run the filter and map functions
const squareOdd = squareOddVals(nums);

// Subscribe to run the combined functions
squareOdd.subscribe(x => console.log(x));  
\end{lstlisting}

\mybox{You might be wondering why rxjs called this a pipe?! Well if not 
familiar with already, the concept of a pipe originally comes form Unix. 
It is the ability to pass information from one process to another. For 
instance, if using a the terminal in Unix, something such as the following
ps aux | grep root | pbcopy; would display all processes, grep specifically 
for those tied to root, and then copy that to the clipboard.}

\subsection{No subscribe, No describe}
In case you didn't get that one, it's unit testing joke. But for real, if you 
do not call a subscribe on your pipe, it will never be called. Consider the 
pipe as the function(which under the hood it is), and subscribe effectively
calling the pipe. So, don't forget to call the subscribe. 

\subsection{Common Operators}
One of the biggest complaints that many have about Rxjs, is that it's an 
overly bloated library. A while back, a man by the name of Andre Saltz who is
very so responsible for popularizing observables within Javascript, created a 
library called XStream, to focus just on the operators one needs to use on a 
day to day basis. Primarily, because some people were complaining of the vast 
amount of operators they happened to learn. (One can perhaps complain on the 
bloat that the rxjs library adds, however, rxjs introduced tree shaking in 
verson 5.)

Ironically, what this did is start to create transparency around what would be 
considered a common operator. The Rxjs then went ahead and started creating 
what would be considered common operators. The following are common operators
  
\begin{center}
  \begin{tabular}{@{} l *4c @{}}
    \toprule
    {\color{red}Area} & Operators \\
    \midrule
    Creation & \texttt{from},\texttt{fromEvent}, \texttt{of}\tabularnewline
    Combination & \texttt{combineLatest}, \texttt{concat}, \texttt{merge},
  \texttt{startWith} , \texttt{withLatestFrom},
  \texttt{zip}\tabularnewline
  Filtering & \texttt{debounceTime}, \texttt{distinctUntilChanged},
  \texttt{filter}, \texttt{take}, \texttt{takeUntil}\tabularnewline
  Transformation & \texttt{bufferTime}, \texttt{concatMap}, \texttt{map},
  \texttt{mergeMap}, \texttt{scan}, \texttt{switchMap}\tabularnewline
  Utility & \texttt{tap}\tabularnewline
  Multicasting & \texttt{share}\tabularnewline
  \end{tabular}
\end{center}  