\chapter{ Internationalization and Localization}

If not familiar with already, internationalization is the process of making sure
your app can be used by a worldwide audience. Localization, not to be confused 
with internatilization, is the process of changing app's text, to represent 
locale of user.

Internationalization is one of those things that is generally done farther down
the life cycle of an app. This makes complete sense, as when building a product, 
a team will generally want to build the infrastructure first, based on a 
particular language. Then, it will want to make it so that the app can be based 
on numerous different demographics. However, being aware of the following will 
make internationalization more of a seamless process. 

\section{General Concerns of Internationalization }

\begin{enumerate}
  \item What type of dates, numbers, perxentages and currencies do you want. 
  \item Setting aside text in components, so can be swapped out to the 
  appropriate language. 
  \item Plural words are different in different languages. So it's important 
  have something baked within the framework that does this. 
  \item Alternate text based on scenario(e.g. if person in New York display 
  such and such event, if person in San Francisco display message such and 
  such.)
\end{enumerate}

\section{General Concerns of Localization }
\begin{enumerate}
  \item Creating multiple language versions of app(will get to how that is done)
  \item Extracting Localizable text(not sure exactly what that is).
  \item Building and servimg an app for a given locale. 
\end{enumerate}

\section{Default Locale}
Localization for years, well before Angular, have been using ids for the 
applicaton to understand what the language should be. Angular, as well, has an
extensive list of different languages within it's framework. 

\mybox{Angular's internal framework uses the BCP47 norm. It's very important
to note that if you plan on building on top of Angular's localization framework,
that you use this as your standard within the framework. Specifications for BCP47 
change over time. However, this might not make a difference within your 
application, as this only happens to subset. }

Angular by default will use \lstinline{en-us} thereby once again solidifying 
the United States as the dominating world power. 

\section{i18n pipes}
Angular includes within the framework, the ability to use something called i18n 
pipes. i18n is an abbreviation of word "internationalization". It's perhaps the 
world's most clever abbreviation standing for "i plus eighteen letters, plus the 
letter n". 

\mybox{A DEC employee named Jan Scherpenhuizen was given an email account of 
S12n by a system administrator, since his name was too long to be an account 
name. This approach to abbreviating long names was intended to be humorous and
became generalized at DEC. The convention was applied to "internationalization"
at DEC which was using the numeronym by 1985. Use of the term spread. Searching
the net, we found uses on-line as early as 1989. It was being used on 
/usr/group, which evolved into UniForum. The X Window standards community was 
also using the abbreviation by 1989. Looking in printed texts, the earliest 
reference I could find was in the book Soft Landing in Japan, published by 
American Electronic Association, 1992.

The extension of this naming convention to the terms Localization (l10n), 
Europeanization (e13n), Japanization (j10n), Globalization (g11n), seemed to 
come somewhat after the invention of "i18n". The terms Canonicalization and 
Normalization, defined more recently, also have numeronym forms (c14n and n11n).
}

(Graphic goes here for internationalization)

There is no actual pipe actually called the "i18n" pipe. However, four pipes: 
\begin{enumerate}
  \item \lstinline{DatePipe}
  \item \lstinline{CurrencyPipe}
  \item \lstinline{DecimalPipe}
  \item \lstinline{PercentPipe}
\end{enumerate}

Do use the \lstinline{i18n} internal logic, and will automatically modify 
themselves based on the locale supplied within the app. As mentioned earlier,
Angular will only by default import \lstinline{en-US}. If you want to use other
languages within the app. 

\subsection{Import Locale Data for Other Languages}
If you would like to import data for other languages, import them locally 
within your \lstinline{app.module.ts} file. 

\begin{lstlisting}[caption=app.module.ts]
import { registerLocaleData } from '@angular/common';
import localeFr from '@angular/common/locales/fr';

// the second parameter 'fr' is optional
registerLocaleData(localeFr, 'fr');
\end{lstlisting}

\section{ Understanding Translation Process }
There are four steps to the Angular translation process: 
\begin{enumerate}
  \item It determines what is static text, so that it can be translated.
  \item Uses the internal Angular CLI \lstinline{i18n} command to transfer over 
  determined translatable text to an industry standard translation file. (Need 
  more information as to what this looks like.)
  \item Translates extracted text, into the target language. The dynamics of
  how this works, is that it edits the already existing file, to the targeted 
  language. 
  \item It then merges the translated file into the app, by replacing the 
  original untranslated text, with the new translated text. 
\end{enumerate}

\section{How to Make Content Translatable}
You might be wondering how to make content translatable. Angular intenrally 
allows for cotnent to be marked with the \lstinline{i18n} tag like such: 
\begin{lstlisting}
  <h1 i18n>i18n example</h1>
\end{lstlisting}

\mybox{It is important to note the i18n tag is not an Angular directive. It is 
a custom tag recognized by the Angular compiler, and will be removed once the
Angular compiler does it's magic.}

\subsection{Add a Description and a Meaning}
Angular also offers the ability to add a description and a meaning to the
\lstinline{i18n} tag. 
\begin{lstlisting}[caption=i18n description]
<h1 i18n="i18n tutorial text for internationalization chapter">i18n example</h1>
\end{lstlisting}

We can also add a meaning to the \lstinline{i18n} tag, in additon, to our 
already added description. The interface looks like this 
\lstinline{<meaning | description>}.

\begin{lstlisting}[caption=i18n \lstinline{<meaning | description>} Example]
<h1 i18n="tutorial text|i18n tutorial text for internationalization chapter">i18n example</h1>
\end{lstlisting}

You might be wondering how offering a meaning and description will make a 
difference with regards to the translation of the application. The Angular 
extraction tool preserves both meaning and description in the translation 
source file. When using only a meaning, or a description, the compiler will
preserve the meaning, or description with the compiled text. 

\subsubsection{Comibation of Meaning and Description}
However, the combiation of meaning and description within your app, will produce 
a specific id of a translation. With regards to the combination of meaning and 
description, meaning is the main identifier in this process. Only if the meaning 
is different, will the Angular compiler produce a different id. If, for instance, 
the meaning is the same, but the description is different, the compiler will 
still produce the same id. 

\section{Set a Custom ID for Persistance and Maintenance}
For each file that the Angular translator produces, it will by default attach 
an id to that file as well. It will look something like the following: 
\begin{lstlisting}[caption=example.fr.xlf.html]
<trans-unit id="ba01234d3d68bf669f97b8d96a4c5d8d9559aa3" datatype="html">
\end{lstlisting}

When the text is changed, the extractor tool will generate new text. You 
must then go ahead and manually change the id. \footnote{Not sure if this 
means that the text must be manually updated, or if compiler will do that
for you.} 

\subsection{Setting up Custom ID}
Angular will also allow you to set up a custom id for your translatable text:
\begin{lstlisting}
<h1 i18n="@@sampleText">i18n Sample</h1>
\end{lstlisting}

The custom id persists even when text changes. This allows for maintenance 
and scalability. Perhaps even the ability to hook an id into a content 
management system, and allow for an admin to control translation of different
parts of the application. 

\subsection{Using a Custom ID with a Description and/or Meaning}
There is also the option within the app to use a custom id with the 
description. 
\begin{lstlisting}[caption=custom id with description]
<h1 i18n="i18n tutorial text for internationalization chapter@@sampleText">i18n example</h1>
\end{lstlisting}

In addition, you can add meaning along with description to your custom id:
\begin{lstlisting}[caption=custom id with meaning and description]
<h1 i18n="tutorial text|i18n tutorial text for internationalization chapter@@sampleText">
  i18n example
</h1>
\end{lstlisting}

\mybox{Make sure to use unique custom ids for translation. If two of the same
ids are used for translation, Angular will only use the one which is meant to 
be used within your app. }

\subsection{Translating attributes}
Text can be contained inside of an attribute such as \lstinline{placeholder}, 
or \lstinline{title}. Due to the dynamics of how the \lstinline{i18n} compiler 
works, if you would like to translate the text within an attribute, you will 
have to use the \lstinline{i18n} flavored attribute. It follows the syntax of 
\lstinline{i18n-x} wherein \lstinline{x} is the name of the attribute you want
to translate. 

\begin{lstlisting}
<img [src]="logo" i18n-title title="Razroo logo" />
\end{lstlisting}

\section{ Regular Expressions - Pluralization | Selections }
Different languages treat the plural form of a word different ways. Angular 
offers a plural pipe out of the box. This is combination with \lstinline{i18n}
allows for a very sophisticated method with regards to internatilization. 

\begin{lstlisting}
<span i18n>Updated {minutes, plural, =0 {just now} =1 {one minute ago} other {{{minutes}} minutes ago}}</span>
\end{lstlisting}

The plural pipe, allows for the specification of the following categories: 
\begin{enumerate}
\item =0(or any other number)  
\item zero  
\item one
\item two
\item few
\item many
\item other
\end{enumerate}

In the above code, we are specifying: 
\begin{enumerate}
\item Just now if the numbers of minutes is 0 
\item "one minute ago" if the number of minutes is 1
\item and for every other amount we are specifying "x minutes ago" 
\end{enumerate}

By tagging in the \lstinline{i18n} attribute into our span element, we are 
translating the appropriate text based on the appropriate scenario. 

\subsection{Alternative Text Messages}
In addition to the scenario of plural text, another scenario to keep in mind, 
is when we want to select a certain text based on the variable provided. 

\begin{lstlisting}
<span i18n>The author is {gender, select, male {male} female {female} other {other}}</span>  
\end{lstlisting}

In the above text, based on whether, or not the author is a female, or male, or 
other, we will allow for a specific type of text to be displayed. In addition,
being that we are supplying the \lstinline{i18n} pipe to our app, this text 
will appropriately be changed to the correct text based on a certain localization.

\subsection{Alternative + Plural Combined}
There is also the option is combine plural and alternative text message capabilities 
together. 
\begin{lstlisting}
<span i18n>Updated: {minutes, plural,
=0 {just now}
=1 {one minute ago}
other {{{minutes}} minutes ago by {gender, select, male {male} female {female} other {other}}}}
</span>
\end{lstlisting}

As you can see in the above code, the other section, is combined with code for
select. Absolutely wonderful. 

\section{Translation Source File}
\subsection{Understanding the Angular Translation Process}
First and foremost, before describing how to create a translation source file,
let's discuss the purpose of a translation source file. The idea is, is that 
we have tagged all files that we would like to translate, with the \lstinline{i18n} 
attribute (which really isn't an attribute, and is more a compiler specific 
indicator, but I digress). After the source file is created, we have an xml 
specific file. It will look something like this: 
\begin{lstlisting}[caption=src/locale/messages.xlf]
<trans-unit id="introductionHeader" datatype="html">
  <source>Hello i18n!</source>
  <note priority="1" from="description">An introduction header for this sample</note>
  <note priority="1" from="meaning">User welcome</note>
</trans-unit>
\end{lstlisting}

Now if we would like, for instance, to create a french equivalent file, we would 
create a source file with the \lstinline{fr} suffix. 

\begin{lstlisting}[caption=src/locale/messages.fr.xlf]
<trans-unit id="introductionHeader" datatype="html">
  <source>Hello i18n!</source>
  <note priority="1" from="description">An introduction header for this sample</note>
  <note priority="1" from="meaning">User welcome</note>
</trans-unit>
\end{lstlisting}

\subsection{XLIFF Editor}
This in an enterprise setting, the xlf file is usually sent over to a french
translater, who will then convert the english inside of these french files, to
french. They will use something called an XLIFF Editor, which stands for textit{XML 
Localization Interchange File Format}. The xlf file suffix stands for 
\textit{XML Localization Format}.

\subsection{Create a Translation Source File}
The Angular CLI has an internal mechanism for generating a translation source file.
Simply open a terminal window at the root of the app project and run the 
\lstinline{CLI} command \lstinline{xi18n}.
\begin{verbatim}
ng xi18n 
\end{verbatim}

Personally, I like to create files inside of the app's \lstinline{src/locale} 
folder path. For that let's change the output path using the CLI: 
\begin{verbatim}
ng xi18n --output-path src/locale  
\end{verbatim}

\subsubsection{Generating Different Translation Formats}
The Angular CLI also offers the ability to alter the format of the outputted 
file. 
\begin{enumerate}
  \item XLIFF 1.2 (default)
  \item XLIFF 2
  \item XML Message Bundle (XMB)
\end{enumerate}

Respectively, that would be: 
\begin{verbatim}
ng xi18n  --i18n-format=xlf
ng xi18n  --i18n-format=xlf2
ng xi18n  --i18n-format=xmb  
\end{verbatim}

\subsubsection{Other Notable CLI options}
The CLI also offers the ability to change the name of the translation source 
file using the \lstinline{--outFile} command option
\begin{verbatim}
ng xi18n --out-file source.xlf  
\end{verbatim}

There is also the option to change the base locale of your app, from the 
default \lstinline{US-EN} using the \lstinline{--i18n-locale} command option.
\begin{verbatim}
ng xi18n --i18n-locale fr
\end{verbatim}

\subsection{Translate the source text}
As mentioned earlier, when we were trying to understand the process behind 
creating a source file, we mentiiend that we will be creating translation 
source files. We will then be going ahead and sending those translation 
source files over to a translater. As standard practice Razroo reccomends
a singular folder that can be used for the localization process. We do this 
by using the \lstinline{output-path} option mentioned before:
\begin{verbatim}
ng xi18n --output-path src/locale  
\end{verbatim}

and the file that will be generated will be the \lstinline{messages.xlf} file:

\begin{lstlisting}[caption=src/locale/messages.xlf]
<trans-unit id="introductionHeader" datatype="html">
  <source>Hello i18n!</source>
  <note priority="1" from="description">An introduction header for this sample</note>
  <note priority="1" from="meaning">User welcome</note>
</trans-unit>
\end{lstlisting}

and now after translation, and creating the resepctive french file, it will 
look something like the following: 

\begin{lstlisting}[caption=src/locale/messages.fr.xlf(after translation)]
<trans-unit id="introductionHeader" datatype="html">
  <source>Hello i18n!</source>
  <target>Bonjour i18n !</target>
  <note priority="1" from="description">An introduction header for this sample</note>
  <note priority="1" from="meaning">User welcome</note>
</trans-unit>
\end{lstlisting}

In the above you will notice that we create a target equivalent XML tag. This
is used by the framework internally to say what the source should be translated 
over to. 

\section{Translation Source File that includes plural and select expressions}

\subsection{Translating Plural}
To translate a \lstinline{plural} we only translate the text related values. 

\begin{lstlisting}[caption=src/locale/messages.fr.xlf]
<trans-unit id="5a134dee893586d02bffc9611056b9cadf9abfad" datatype="html">
  <source>{VAR_PLURAL, plural, =0 {just now} =1 {one minute ago} other {<x id="INTERPOLATION" equiv-text="{{minutes}}"/> minutes ago} }</source>
  <target>{VAR_PLURAL, plural, =0 {à l'instant} =1 {il y a une minute} other {il y a <x id="INTERPOLATION" equiv-text="{{minutes}}"/> minutes} }</target>
</trans-unit>  
\end{lstlisting}

\subsection{Translating Select}
Similarly for select: 
\begin{lstlisting}
<span i18n>The author is {gender, select, male {male} female {female} other {other}}</span>  
\end{lstlisting}

The Angular extraction tool, will break the above into two separate parts: 
\begin{lstlisting}[caption=src/locale/messages.fr.xlf]
<trans-unit id="f99f34ac9bd4606345071bd813858dec29f3b7d1" datatype="html">
  <source>The author is <x id="ICU" equiv-text="{gender, select, male {...} female {...} other {...}}"/></source>
  <target>L'auteur est <x id="ICU" equiv-text="{gender, select, male {...} female {...} other {...}}"/></target>
</trans-unit>  
<trans-unit id="eff74b75ab7364b6fa888f1cbfae901aaaf02295" datatype="html">
  <source>{VAR_SELECT, select, male {male} female {female} other {other} }</source>
  <target>{VAR_SELECT, select, male {un homme} female {une femme} other {autre} }</target>
</trans-unit>
\end{lstlisting}

The first \lstinline{<trans-unit>} will contain the text outside of 
\lstinline{select}. The second \lstinline{<trans-unit>} will contain the text
inside of the \lstinline{select} message. The reason that the extraction tool 
will separate it into two separate sections, is because each expression unit is 
separate. (For our \lstinline{plural} expression it was all on it's own. If it 
had text ourside of the \lstinline{plural} expression, it would indeed be 
separated into two parts)

\subsection{Translating a Nested Experssion}
So let's say that we have mixed and matched plural and select as follows: 
\begin{lstlisting}
<span i18n>Updated: {minutes, plural,
=0 {just now}
=1 {one minute ago}
other {{{minutes}} minutes ago by {gender, select, male {male} female {female} other {other}}}}
</span>
\end{lstlisting}

The result will be very similar to before. The extraction tool will separate 
this into two different parts: 
\begin{lstlisting}[caption=src/locale/messages.fr.xlf]
<trans-unit id="972cb0cf3e442f7b1c00d7dab168ac08d6bdf20c" datatype="html">
  <source>Updated: <x id="ICU" equiv-text="{minutes, plural, =0 {...} =1 {...} other {...}}"/></source>
  <target>Mis à jour: <x id="ICU" equiv-text="{minutes, plural, =0 {...} =1 {...} other {...}}"/></target>
</trans-unit>
<trans-unit id="7151c2e67748b726f0864fc443861d45df21d706" datatype="html">
  <source>{VAR_PLURAL, plural, =0 {just now} =1 {one minute ago} other {<x id="INTERPOLATION" equiv-text="{{minutes}}"/> minutes ago by {VAR_SELECT, select, male {male} female {female} other {other} }} }</source>
  <target>{VAR_PLURAL, plural, =0 {à l'instant} =1 {il y a une minute} other {il y a <x id="INTERPOLATION" equiv-text="{{minutes}}"/> minutes par {VAR_SELECT, select, male {un homme} female {une femme} other {autre} }} }</target>
</trans-unit>  
\end{lstlisting}

\section{Merge Translated Files I.E. How to Use With App}
So now that we have our completed translated files, we will need to provide the
Angular compiler with three pieces of information: 
\begin{enumerate}
  \item The translation file(e.g. \lstinline{messages.fr.xlf})
  \item The translation file format(e.g. \lstinline{xlf})
  \item The locale(e.g. \lstinline{fr})
\end{enumerate}

\subsection{AOT v. JIT}
This all depends on how you are compiling your app. Just to re-iterate, there
are two ways of doing this:
\begin{enumerate}
  \item AOT(Which compiles at build time)
  \item JIT(Which compiles at run time)
\end{enumerate}

Depending on how you are running your app, this depends. If you are running 
using AOT, then being that the compilation is being done at build time, you 
will need to specify configurations. If you are using JIT, you will have to 
specify providers with your app, so that it is aware of the translation 
files.

\subsection{Merge Files with AOT Compiler}
With AOT there will be four configurations: 
\begin{enumerate}
  \item \lstinline{i18nFile}: the path to the translation file.
  \item \lstinline{i18nFormat}: the format of the translation file.
  \item \lstinline{i18nLocale}: the locale id.
  \item \lstinline{outputPath}: folder to distribute build.
\end{enumerate}

That you will want to add to your \lstinline{angular.json} file.

\subsection{Configuration for Development Environment}

\begin{lstlisting}[caption=angular.json]
"build": {
  ...
  "configurations": {
    ...
    "fr": {
      "aot": true,
      "outputPath": "dist/my-project-fr/",
      "i18nFile": "src/locale/messages.fr.xlf",
      "i18nFormat": "xlf",
      "i18nLocale": "fr",
      ...
    }
  }
},
"serve": {
  ...
  "configurations": {
    ...
    "fr": {
      "browserTarget": "*project-name*:build:fr"
    }
  }
}  
\end{lstlisting}

You can pass configuration to the \lstinline{ng-serve}, or \lstinline{ng-build}
commans by doing the following: 
\begin{verbatim}
ng serve --configuration=fr
\end{verbatim}

\subsection{Configuration for Production Environment}
For prod, we specify a separate \lstinline{production-fr} build configuration 
in the CLI configuration file: 
\begin{lstlisting}[caption=angular.json]
...
"architect": {
  "build": {
    "builder": "@angular-devkit/build-angular:browser",
    "options": { ... },
    "configurations": {
      "fr": {
        "aot": true,
        "outputPath": "dist/my-project-fr/",
        "i18nFile": "src/locale/messages.fr.xlf",
        "i18nFormat": "xlf",
        "i18nLocale": "fr",
        "i18nMissingTranslation": "error",
      }
    }
  },
  ...
  "serve": {
    "builder": "@angular-devkit/build-angular:dev-server",
    "options": {
      "browserTarget": "my-project:build"
    },
    "configurations": {
      "production": {
        "browserTarget": "my-project:build:production"
      },
      "fr": {
        "browserTarget": "my-project:build:fr"
      }
    }
  }
}  
\end{lstlisting}

\subsection{Merge Files with JIT Compiler}
JIT is an entirely different beast than working with AOT. 
In truth, I prefer AOT because it is much more straightforward. I was debating 
in this chapter at all to mention configurations for JIT. However, as I have 
been in a similar scenario, there will be an app that will be built out with 
JIT, and moving over to AOT, immediately is something which will be very 
difficult, and might prevent the app from being able to move forward. For that
reason, I am jotting down configurations for JIT as well. However, Razroo 
reccomended architecture, is that your app uses \lstinline{AOT} exclusively 
from the beginning. 

\section{Tips and Tricks}
\subsection{Using ng-container with i18n}
While something that might be obvious when thinking about it more, you can use 
\lstinline{ng-container} to remove the requirement of having an html element 
be created when translating text. E.g. 
\begin{lstlisting}
<ng-container i18n>Translate this into multiple languages</ng-container>
\end{lstlisting}

\section{ Architecting Internationalization }
The reason why architecting internationalization can be something that is
something for us to keep in mind, is that it can have an affect on how we might
view the architecture of our application. A data table, for instance, is a great
example. We might want to propose a rigid re-usable data-table. However, once
we introduce internationalization, having data tables that are unique per each
language will be important. Having a re-usable data table that takes care of
information through passing in props can be cumbsersome.

\section{ Smart and Dumb Components }
Creating smart and dumb components, is your most valuable resource when it comes
to internatilization. It will allow you to set up different components based on
certain languages. 
