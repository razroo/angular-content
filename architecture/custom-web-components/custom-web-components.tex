\chapter{ Custom Web Components }
Really, what makes a framework, a framework, is it's ability to tie together the different parts of the application into something larger. This includes services for data requests, files for interfaces/type checking, state management, rendering engine, and the ability to pass inputs and outputs to each other.

One very intelligent piece of architecture that will be getting more press as time goes on, is creating custom web components within you application. This allows for your dumb components to be independent of framework, and to be re-used wherever. 

I would promote this practice by default to use in any application that you work on. All dumb component should be created as a custom web component, so any team can modify it. 

\section{Before We Get To Nx}
Before we get to Nx, I would like to discuss one thing that really at this point bothers me. Nx controls too much of my code. If the team at Nrwl decides to take the direction of paid code, or documentation is lacking, I am screwed over. It really seems like a large price to pay, for tooling that can be created by my own team. 

So while I am going to reccomend using Nx, and I know the people at Nrwl personally. I actually love them to death. Jeff and Viktor are some of my biggest personal inspirations. I really want them to succeed, and that their company balloons into a giant. However, I can't help but feel it irresponsible
so that I don't through the rabbit hole too much. I remember sitting at a company with a very large engineering team, and the fact they weren't educating their own team members on Webpack, Bazel, and creating transparent schematics, almost seemed like a travesty. You are pretty much gaurenteeing that your company will have to use them as consultants to keep you app ticking, if you come across some quirk. 

For me, the eureka moment really came when I started using Web Components. I was like at this point, ok, fine. I will use your app to scaffold ngrx, and generate the initial workspace. However, when I have to use you to actually build my app, that is when it becomes problematic.

So, suffice to say, I am going to attempt to create this solution on my own as well, for this one.

\section{Using Nx}
Granted you are working within the Nx workspace, which once again, I highly reccomend, but please do use with caution.

\subsection{Scaffolding Web Components Lib}
Within Nrwl Nx there is the ability to create a none framework library, which will include all of our framework agnostic code. 

\begin{lstlisting}
ng g lib ui --framework=none  
\end{lstlisting}

This will generate a \lstinline{ui} directory structure, that will something like the folliwing, within your application: 

\begin{forest}
  [libs
    [ui
      [src
        [lib]
        [\/index.ts,file]
      ]
      [\/jest.conf.js, file]
      [\/tsconfig.lib.json, file]
      [\/tsconfig.json, file]
      [\/tsconfig.spec.json, file]
      [\/tslint.json, file]
    ]
    [\/index.ts,file]
    [\/test.ts,file]
  ]
\end{forest}

\subsection{Create An elements.ts File and Export}
Inside of your lib folder, let's create a data-table component. 
\begin{verbatim}
cd libs/ui/src/lib;
mkdir data-table;
\end{verbatim}

Inside of that data table, let's go ahead and create a custom web component. 

\begin{lstlisting}[caption=custom web component]
export class GreetingElement extends HTMLElement {
  public static observedAttributes = ['title'];

  attributeChangedCallback() {
    this.innerHTML = `<h1>Welcome to ${this.title}!</h1>`;
  }
}

customElements.define('happynrwl-greeting', GreetingElement);
\end{lstlisting}

\mybox{A custom web component somewhat interacts like a regular Javascript component and styling is very similar in that regard. Here you can see us using the inner.html code, and other components are similar in this regard.}

\subsection{Reexport in index.ts file}
You will want to go ahead and re-export it in your web-element component. This will simplify that way things work, and allow you to re-use within your app. 

\section{General Architecture of Inserting Web Element}
\subsection{Changing Target}
Because custom web elements are a relativley new technology, it will require the target to be changed to ES2015. 

\subsection{Importing library}
Your app will require importing the library into your web application.

\subsection{Tell Framework To Take Chill Pill}
Every framework will have a specific schema towards it's web application. Custom Web Elements are outside of the regular schema of every framework. So you will have to use the framework's preffered method of "taking a chill pill". I.e. saying the schema for custom web elements is cool, and should not be errored out.

\subsection{Actually Using Element}
Actually going ahead and using element similar to how you would use a component in any regular application. 

\section{Inserting component in Angular App}

\subsection{Change Target}
In our \lstinlne{tsconfig.json} we will go ahead and change the output target to \lstinline{es2015}. Custom web elements are a relatively new technology, and require es2015 by default to be bundled as part of the application. 

\subsection{Change Target}
Within our Angular application we will tell the schema that it should allow for custom elements i.e. \lstinline{CUSTOM_ELEMENTS_SCHEMA}. This is primarily so it will allow for custom elements to be used within the app. 

\subsection{Insert Component in Angualr App}
Inserting a web component within an Angular app, is done in exactly the same fashion that a regular Angular component would be inserted. 

\section{Inserting component in React App}
