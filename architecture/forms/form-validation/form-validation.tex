\chapter{ Form Validation }

One of main reasons why one would choose to use the internal Angular Form 
Group architecture, is the way it eases validation. Angular has a series 
of built in validators, that can be used for the fields in your form. For 
the sake of clarity, and brevity, I would like to jot down the name of current 
Angular Validators here, without going into detail: 
\begin{enumerate}
  \item min
  \item max
  \item required
  \item requiredTrue
  \item email
  \item minlength
  \item maxlength
  \item pattern
  \item nullValidator
  \item compose
  \item composeAsync
\end{enumerate}

I think for the most part, the above validators speak for themselves as to 
what they do, with the exception of \lstinline{compose}. \lstinline{compose}
will allow you to combine multiple validotors, and return an error map for 
them. As you can see, the more popular errors, such as min, and max(for use
with passwords/usernames) and emails, and patterns are what angulars internal 
validators are there for. There is the ability to make custom validators, and 
most likely any app you work on, us going to need it's own custom validatores,
but before we go ahead and do that, let's see how we can integrate this with
out application. 

\section{Integrating Form Validators within Component}
Let's imagine that we have a newsletter component within our application. We 
want to ensure the user uses an email pattern, and it is also required. We write 
the following: 
\begin{lstlisting}
ngOnInit() {
  this.newsletterForm = this.fb.group({
    email: ['',
      Validators.compose([Validators.required, Validators.email])
    ],
  });

  get email() {
    return this.newsletterForm.get('email');
  }
}
\end{lstlisting}

As we can see using the above we have added two native angular validators to
our formControl field email. This is the process wherein we would add Angular 
form validators to our application. 

\section{Integrating Form Validators within HTML Template}
If we would like to integrate our form validators within our app, so that we 
click on the button and they get triggered, we would do the following: 

\begin{lstlisting}[caption=Integrate Form Validation with HTML]
<ng-container *ngIf="email.invalid && (email.dirty || email.touched)">
  <mat-error *ngIf="email.errors.required">Name is required.</mat-error>
  <mat-error *ngIf="email.errors.email">Email is invalid</mat-error>
</ng-container>
\end{lstlisting}

In the above, we are creating a way of displaying the error if it appears. It 
should only appear if a user has actually touched the email field. 

\section{Custom Validators}
As mentioned before, odds are that your application, being that it needs to 
have some unique business case for it to actually make money, will also need 
it's own set of custom validators. In order to create your own set of custom 
validators, you would simply need your own function. That function would then 
be hooked into the validators array. However, it is more efficient if we create
a directive that can be used to automatically create validation for our form. 
In addition, if we create separate function for the directive, it allows us
to re-use the functionality for the directive without directly using the
directive.


