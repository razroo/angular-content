\chapter{ Form Validation }

One of main reasons why one would choose to use the internal Angular Form 
Group architecture, is the way it eases validation. Angular has a series 
of built in validators, that can be used for the fields in your form. For 
the sake of clarity, and brevity, I would like to jot down the name of current 
Angular Validators here, without going into detail: 
\begin{enumerate}
  \item min
  \item max
  \item required
  \item requiredTrue
  \item email
  \item minlength
  \item maxlength
  \item pattern
  \item nullValidator
  \item compose
  \item composeAsync
\end{enumerate}

I think for the most part, the above validators speak for themselves as to 
what they do, with the exception of \lstinline{compose}. \lstinline{compose}
will allow you to combine multiple validotors, and return an error map for 
them. As you can see, the more popular errors, such as min, and max(for use
with passwords/usernames) and emails, and patterns are what angulars internal 
validators are there for. There is the ability to make custom validators, and 
most likely any app you work on, us going to need it's own custom validatores,
but before we go ahead and do that, let's see how we can integrate this with
out application. 

\section{Integrating Form Validators within Component}
Let's imagine that we have a newsletter component within our application. We 
want to ensure the user uses an email pattern, and it is also required. We write 
the following: 
\begin{lstlisting}
ngOnInit() {
  this.newsletterForm = this.fb.group({
    email: ['',
      Validators.compose([Validators.required, Validators.email])
    ],
  });

  get email() {
    return this.newsletterForm.get('email');
  }
}
\end{lstlisting}

As we can see using the above we have added two native angular validators to
our formControl field email. This is the process wherein we would add Angular 
form validators to our application. 

\section{Integrating Form Validators within HTML Template}
If we would like to integrate our form validators within our app, so that we 
click on the button and they get triggered, we would do the following: 

\begin{lstlisting}[caption=Integrate Form Validation with HTML]
<ng-container *ngIf="email.invalid && (email.dirty || email.touched)">
  <mat-error *ngIf="email.errors.required">Name is required.</mat-error>
  <mat-error *ngIf="email.errors.email">Email is invalid</mat-error>
</ng-container>
\end{lstlisting}

In the above, we are creating a way of displaying the error if it appears. It 
should only appear if a user has actually touched the email field. 

\section{Custom Validators}
As mentioned before, odds are that your application, being that it needs to 
have some unique business case for it to actually make money, will also need 
it's own set of custom validators. In order to create your own set of custom 
validators, you would simply need your own function. That function would then 
be hooked into the validators array. However, it is more efficient if we create
a directive that can be used to automatically create validation for our form. 
In addition, if we create separate function for the directive, it allows us
to re-use the functionality for the directive without directly using the
directive.

\subsection{Creating Custom Directive Validator}
Let's create a custom directive validator for numbers. We are using the NX 
workspace. In addition, we are using the Razroo reccomended folder structure. 
A custom directive validator, will go in the common folder for directives. 


\subsubsection{Generate The Directive}
\begin{verbatim}
ng g lib directive --directory=common  
\end{verbatim}

Inside of newly created \lstinline{CommonDirectivesModule}, we will create 
a folder 
\begin{verbatim}
cd libs/common/directives/src/lib/;
mdkir number; 
\end{verbatim}

So now let's navigate to our number folder:
\begin{verbatim}
cd number;  
\end{verbatim}  

and run the appropriate Angular CLI command for generating a directive, 
and exporting it within our \lstinline{CommonDirectivesModule}

\begin{verbatim}
ng g directive number --export  
\end{verbatim}

This will generate the following output inside of the terminal: 
\begin{verbatim}
CREATE libs/common/directives/src/lib/number/number.directive.spec.ts (224 bytes)
CREATE libs/common/directives/src/lib/number/number.directive.ts (144 bytes)
UPDATE libs/common/directives/src/lib/common-directives.module.ts (493 bytes)
\end{verbatim}

\subsubsection{Create The Function for Directive}
Inside of the folder for our number directive, let's also create a number validator file.

\begin{verbatim}
touch validator.ts;
touch validator.spec.ts
\end{verbatim}

Inside of our \lstinline{validate.ts} file, we will go ahead and create logic for numbers.

\begin{lstlisting}[caption=number-validator.ts]
import { AbstractControl, Validators, ValidatorFn } from '@angular/forms';

function isPresent(obj: any): boolean {
  return obj !== undefined && obj !== null;
}

export const number: ValidatorFn = (control: AbstractControl): {[key: string]: boolean} => {
  if (isPresent(Validators.required(control))) return null;

  let v: string = control.value;
  return /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(v) ? null : {'number': true};
}; 
\end{lstlisting}

\subsubsection{Hook In Validator Function to Directive}
We will now go ahead and integrate the number function into our directive. 

\begin{lstlisting}[caption=number.directive.ts]
import { Directive, forwardRef } from '@angular/core';
import { AbstractControl, NG_VALIDATORS, Validator } from '@angular/forms';
import { number } from './validator';

const NUMBER_VALIDATOR: any = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => NumberDirective),
  multi: true
};

@Directive({
  selector: '[razrooNumber]',
  providers: [NUMBER_VALIDATOR]
})
export class NumberDirective implements Validator {
  validate(c: AbstractControl): {[key: string]: any} {
    return number(c);
  }
}  
\end{lstlisting}

We now have the ability to use this as a directive within our application. It 
should be noted that we are doing two unique things within our directive. One 
of them is 

\subsubsection{Hook In Directive to Component Template}
Now, all we need to do, is hook the directive into the template for our 
component. 
