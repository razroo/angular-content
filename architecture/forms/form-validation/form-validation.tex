\chapter{ Form Validation }

One of main reasons why one would choose to use the internal Angular Form 
Group architecture, is the way it eases validation. Angular has a series 
of built in validators, that can be used for the fields in your form. For 
the sake of clarity, and brevity, I would like to jot down the name of current 
Angular Validators here, without going into detail: 
\begin{enumerate}
  \item min
  \item max
  \item required
  \item requiredTrue
  \item email
  \item minlength
  \item maxlength
  \item pattern
  \item nullValidator
  \item compose
  \item composeAsync
\end{enumerate}

I think for the most part, the above validators speak for themselves as to 
what they do, with the exception of \lstinline{compose}. \lstinline{compose}
will allow you to combine multiple validotors, and return an error map for 
them. As you can see, the more popular errors, such as min, and max(for use
with passwords/usernames) and emails, and patterns are what angulars internal 
validators are there for. There is the ability to make custom validators, and 
most likely any app you work on, us going to need it's own custom validatores,
but before we go ahead and do that, let's see how we can integrate this with
out application. 

\section{Integrating Form Validators within Component}
Let's imagine that we have a newsletter component within our application. We 
want to ensure the user uses an email pattern, and it is also required. We write 
the following: 
\begin{lstlisting}
ngOnInit() {
  this.newsletterForm = this.fb.group({
    email: ['',
      Validators.compose([Validators.required, Validators.email])
    ],
  });

  get email() {
    return this.newsletterForm.get('email');
  }
}
\end{lstlisting}

As we can see using the above we have added two native angular validators to
our formControl field email. This is the process wherein we would add Angular 
form validators to our application. 

\section{Integrating Form Validators within HTML Template}
If we would like to integrate our form validators within our app, so that we 
click on the button and they get triggered, we would do the following: 

\begin{lstlisting}[caption=Integrate Form Validation with HTML]
<ng-container *ngIf="email.invalid && (email.dirty || email.touched)">
  <mat-error *ngIf="email.errors.required">Name is required.</mat-error>
  <mat-error *ngIf="email.errors.email">Email is invalid</mat-error>
</ng-container>
\end{lstlisting}

In the above, we are creating a way of displaying the error if it appears. It 
should only appear if a user has actually touched the email field. 

\section{Custom Validators}
As mentioned before, odds are that your application, being that it needs to 
have some unique business case for it to actually make money, will also need 
it's own set of custom validators. In order to create your own set of custom 
validators, you would simply need your own function. That function would then 
be hooked into the validators array. However, it is more efficient if we create
a directive that can be used to automatically create validation for our form. 
In addition, if we create separate function for the directive, it allows us
to re-use the functionality for the directive without directly using the
directive.

\subsection{Creating Custom Directive Validator}
Let's create a custom directive validator for numbers. We are using the NX 
workspace. In addition, we are using the Razroo reccomended folder structure. 
A custom directive validator, will go in the common folder for directives. 


\subsubsection{Generate The Directive}
\begin{verbatim}
ng g lib directive --directory=common  
\end{verbatim}

Inside of newly created \lstinline{CommonDirectivesModule}, we will create 
a folder 
\begin{verbatim}
cd libs/common/directives/src/lib/;
mdkir number; 
\end{verbatim}

So now let's navigate to our number folder:
\begin{verbatim}
cd number;  
\end{verbatim}  

and run the appropriate Angular CLI command for generating a directive, 
and exporting it within our \lstinline{CommonDirectivesModule}

\begin{verbatim}
ng g directive number --export  
\end{verbatim}

This will generate the following output inside of the terminal: 
\begin{verbatim}
CREATE libs/common/directives/src/lib/number/number.directive.spec.ts (224 bytes)
CREATE libs/common/directives/src/lib/number/number.directive.ts (144 bytes)
UPDATE libs/common/directives/src/lib/common-directives.module.ts (493 bytes)
\end{verbatim}

\subsubsection{Create The Function for Directive}
Inside of the folder for our number directive, let's also create a number validator file.

\begin{verbatim}
touch validator.ts;
touch validator.spec.ts
\end{verbatim}

Inside of our \lstinline{validate.ts} file, we will go ahead and create logic for numbers.

\begin{lstlisting}[caption=number-validator.ts]
import { AbstractControl, Validators, ValidatorFn } from '@angular/forms';

function isPresent(obj: any): boolean {
  return obj !== undefined && obj !== null;
}

export const number: ValidatorFn = (control: AbstractControl): {[key: string]: boolean} => {
  if (isPresent(Validators.required(control))) return null;

  let v: string = control.value;
  return /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(v) ? null : {'number': true};
}; 
\end{lstlisting}

\subsubsection{Hook In Validator Function to Directive}
We will now go ahead and integrate the number function into our directive. 

\begin{lstlisting}[caption=number.directive.ts]
import { Directive, forwardRef } from '@angular/core';
import { AbstractControl, NG_VALIDATORS, Validator } from '@angular/forms';
import { number } from './validator';

const NUMBER_VALIDATOR: any = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => NumberDirective),
  multi: true
};

@Directive({
  selector: '[razrooNumber]',
  providers: [NUMBER_VALIDATOR]
})
export class NumberDirective implements Validator {
  validate(c: AbstractControl): {[key: string]: any} {
    return number(c);
  }
}  
\end{lstlisting}

We now have the ability to use this as a directive within our application. It 
should be noted that we are doing two unique things within our directive. 
\begin{enumerate}
  \item \lstinline{Validator} -  Our class is implementing \lstinline{Validator}
  which is the same internal function used for validating a formControl. 
  \item We are providing a value called \lstinline{NUMBER_VALIDATOR}. 
  \lstinline{NUMBER_VALIDATOR} will cause the \lstinline{NG_VALIDATOR} 
  \lstinline{injectionToken}, which is the Angular provided token 
  for custom providers, to use the value of \lstinline{NumberDirective}.
  The internal Angular \lstinline{forwardRef} value is there to make sure 
  that it doesn't error out if no value exists. (More on \lstinline{forwardRef}
  in another chapter.)
\end{enumerate}

\subsubsection{Hook In Directive to Component Template}
Now all we need to do, is hook the directive into the template for our 
component. 

\begin{lstlisting}[caption=newsletter.component.html]
<mat-form-field [formGroup]="newsletterForm" class="email-field" >
  <input matInput razrooNumber formControlName="email" placeholder="Your E-mail" required>
</mat-form-field>

<ng-container *ngIf="email.invalid && (email.dirty || email.touched)">
  <mat-error *ngIf="email.errors.number">Not a number</mat-error>
</ng-container>
\end{lstlisting}

As you can see, all we had to add to our input is the directive for 
\lstinline{razrooNumber}. We can then the appropriate \lstinline{mat-error}
within our application in order to hook into the respective error created for number.
The reason it is number, is that within our number validator, we are returning a 
boolean for number. 

\subsection{A Word on This Approach}
If you were to take a look at the documentation, it offers two approaches.
\begin{enumerate}
  \item Template Driven Custom Validators 
  \item Reactive Custom Validators 
\end{enumerate}

Razroo reccomends this approach for using directives, which is a bit contrary to our 
general suggestion of using Reactive Forms. It is our understanding, that reactive 
forms are extremely valuable, because they group the form as one. Making it 
easily accesible from the Typescript side of things. However, in this
particular aspect, of re-using custom validators, re-using functions as a utility 
function, we feel makes the app more brittle than directives. Primarily, because 
directives are more explicit. 

That being said, with our approach, we are separating the logic of validation from 
the actual directive. Moving forward if your team, or other teams within your 
organization would like to use different approaches, they do have the 
flexibility to do so. 

\section{Cross Field Validation}
When I first came across the term "cross field validation", I was a bit 
confused. I thought of it as a way for different field's validation to 
be dependent on each other. After reading more, I found that "cross 
field" validation is exactly that. We are validating our field based on 
two field's correlation to each other. 

For instance, let's say we are working on a finance application. We only want
the "Business Loan Amount" input field to show, if yearly gross income minus expenses, 
exceeds \$100,000. We would be able to set up the internal Angular form validators,
so that the loan-amount is invalid, if this cross field reference(grosss) is not valid. 

THe one point to keep in mind, is that cross field validation is distinct 
from single form validation in two regards: 
\begin{enumerate}
  \item The validator will be used on two, or more form validators. This 
  means, that we need access to the parent level formControl.
  \item The validator will need to be aware of the specific field that it is
  operating on. Therefore usability will be limited to the app, and most likely
  will not make sense to be re-usable. 
\end{enumerate}

\mybox{It should be noted, that based on the above, being that cross field 
validation tends to be component specific, contrary to our reccomendation above
of using a directive for a single field validation, we would reccomend using a 
function. However, as teams are wont to do, they are going to want to have 
the flexibility to choose how they want to integrate with their app. So we still
will be following the separate directive and validate function approach.}

\subsection{Sample Validator Logic}
For the sake of brevity, we will not go through the steps we did earlier, re: 
proper folder structure, directive generation, and respective function. Just one 
note that I would like to make. We mentioned earlier, that due to cross field 
validators usually being unique to specific business logic, we prefer the use 
reactive form validator functions. Therefore, as opposed to prior single field 
validators going in the \lstinline{common/directives} folder, multiple form 
validators will go in the app specific folder (e.g. \lstinline{razroo/common/directives}).

However, we will go into the validator logic required for multiple \lstinline{formControl} 
values. 

\subsubsection{Creating the Service}

\begin{lstlisting}[caption=loan-amount-validator.ts]
import { Injectable } from '@angular/core';
import { FormGroup, ValidationErrors, ValidatorFn } from '@angular/forms';

@Injectable({
  providedIn: 'root'
})
export class LoanAmountValidatorService {

  constructor() { }

  identityRevealedValidator: ValidatorFn = (formGroup: FormGroup): ValidationErrors | null => {
    const income = formGroup.get('income');
    const expenses = formGroup.get('expenses');

    return income && expenses && income.value - expenses.value > 100000 ? { 'loanAmount': true } : null;
  };
}  
\end{lstlisting}

As we can see in the above code, our logic is now tapping into the entire 
\lstinline{formGroup} control. We are: 
\begin{enumerate}
  \item Targeting every field that we need.
  \item Creating logic, based on those two fields.    
\end{enumerate}

Cross form validation logic integration with our directive, is straightforward and very similar 
to how single form validation works: 

\begin{lstlisting}[caption=loan-amount.directive.ts]
import { Directive } from '@angular/core';
import { AbstractControl, NG_VALIDATORS, ValidationErrors, Validator } from '@angular/forms';
import { LoanAmountValidatorService } from './loan-amount-validator.service';

@Directive({
  selector: '[razrooLoanAmount]',
  providers: [{ provide: NG_VALIDATORS, useExisting: LoanAmountDirective, multi: true }]
})
export class LoanAmountDirective implements Validator {
  constructor(private loanAmountValidatorService: LoanAmountValidatorService) {}

  validate(control: AbstractControl): ValidationErrors {
    return this.loanAmountValidatorService.loanAmountValidator(control)
  }

} 
\end{lstlisting}

\subsubsection{Creating the Directive}

Here we are just pulling in the service, and tucking it into our validate function. So, 
now using our prefferred approach of reactive form validators, for cross field validation, 
integrating it, would be as simple as this:

\begin{lstlisting}[caption=finance-calculator.component.ts]
constructor(private fb: FormBuilder,
            private loanAmountValidatorService: LoanAmountValidatorService) { }

ngOnInit() {
  this.newsletterForm = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
  }, {validators: this.loanAmountValidatorService.loanAmountValidator});
}
\end{lstlisting}

\subsubsection{Creating the error}

Integrating the error within our app, is exactly as we would have done for a
singular field.

\begin{lstlisting}[caption=finance-calculator.component.html]
<ng-container *ngIf="finance.invalid && (finance.dirty || finance.touched)">
  <mat-error *ngIf="finance.errors.loanAmount">Calculator</mat-error>
</ng-container>
\end{lstlisting}

\section{Async Validation}
An async validator, is a validator which returns an observable(promises work too, but 
we do not reccomend using a promise within an Angular setting). One other important 
note, is that the Observable must be finite i.e. end. So adding something like 
\lstinline{first} to the async directive more than works. 

A classic example with async validation is to see if a username is take already. 
In order to give the user instant feedback, we can make an http request everytime
the user types in the input. A validator is a one to one relationship, and is not 
meant to have a lifecycle beyond that of the initial validation. Using state for 
something like this would be overkill. However, we do use GraphQL within our 
application. So, we are going to return an observable, and call first on it. 

\subsection{Integrating Service for Async Validation}
We will create a service for async validation. Being that async validators
need to use the backend, using a directive is out of the question. It would 
be too brittle, and hack to work through our code(too time consuming to talk 
about now). However, do take mine, and the official Angular documentation's 
word for it. I am going to decide in this piece to not discuss the code 
behind service actually making request. Reason is, that use cases wherein 
we would use asynchronous validation, is usually in an enterprise setting, 
and it's one team building it for the entire organization. If I do include, 
will include it to the addendum later on. 

Howevever, how to include within our component would be the following: 
\begin{lstlisting}

\end{lstlisting}

\section{ Performance Concern }
All validators are run after every form value change. As in, when an input 
value is changed, the validator will be run after every letter/number is added. 
Sychronous validators, which are not dependent on the backend, generally do 
not suffer from performance issues in this regard. However, when doing 
something like making an http request after every time a letter is clicked, it 
can be expensive. There is a general reccomended approach of making validators 
run on \lstinline{blur}, or \lstinline{submit} instead. So, let's say in our 
app, we want the http request to only be made if the user clicks off of the 
input, we would do something like the following: 

\begin{lstlisting}[caption=Reactive Forms Using Blur]
new FormControl('', {updateOn: 'blur'});
\end{lstlisting}

\section{A Final Note on Form Validators}
Form validation is an integral part of any application. The wonderful way 
about how Angular does things really shine with the way they approach form 
validation. Form validation is particularly difficult, because due to it's 
repetitive nature, and existing outside of component logic. By following 
the \lstinline{common/directive} architecture for single field validation, and
the \lstinline{<app>/common/service/validators} architecture for cross field 
validation, your organization and app, will be in a very good place to scale.
