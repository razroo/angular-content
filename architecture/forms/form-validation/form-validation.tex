\chapter{ Form Validation }

One of main reasons why one would choose to use the internal Angular Form 
Group architecture, is the way it eases validation. Angular has a series 
of built in validators, that can be used for the fields in your form. For 
the sake of clarity, and brevity, I would like to jot down the name of current 
Angular Validators here, without going into detail: 
\begin{enumerate}
  \item min
  \item max
  \item required
  \item requiredTrue
  \item email
  \item minlength
  \item maxlength
  \item pattern
  \item nullValidator
  \item compose
  \item composeAsync
\end{enumerate}

I think for the most part, the above validators speak for themselves as to 
what they do, with the exception of \lstinline{compose}. \lstinline{compose}
will allow you to combine multiple validotors, and return an error map for 
them. As you can see, the more popular errors, such as min, and max(for use
with passwords/usernames) and emails, and patterns are what angulars internal 
validators are there for. There is the ability to make custom validators, and 
most likely any app you work on, us going to need it's own custom validatores,
but before we go ahead and do that, let's see how we can integrate this with
out application. 

\section{Integrating Form Validators within Component}
Let's imagine that we have a newsletter component within our application. We 
want to ensure the user uses an email pattern, and it is also required. We write 
the following: 
\begin{lstlisting}
ngOnInit() {
  this.newsletterForm = this.fb.group({
    email: ['',
      Validators.compose([Validators.required, Validators.email])
    ],
  });

  get email() {
    return this.newsletterForm.get('email');
  }
}
\end{lstlisting}

As we can see using the above we have added two native angular validators to
our formControl field email. This is the process wherein we would add Angular 
form validators to our application. 

\section{Integrating Form Validators within HTML Template}
If we would like to integrate our form validators within our app, so that we 
click on the button and they get triggered, we would do the following: 

\begin{lstlisting}[caption=Integrate Form Validation with HTML]
<ng-container *ngIf="email.invalid && (email.dirty || email.touched)">
  <mat-error *ngIf="email.errors.required">Name is required.</mat-error>
  <mat-error *ngIf="email.errors.email">Email is invalid</mat-error>
</ng-container>
\end{lstlisting}

In the above, we are creating a way of displaying the error if it appears. It 
should only appear if a user has actually touched the email field. 

\section{Custom Validators}
As mentioned before, odds are that your application, being that it needs to 
have some unique business case for it to actually make money, will also need 
it's own set of custom validators. In order to create your own set of custom 
validators, you would simply need your own function. That function would then 
be hooked into the validators array. However, it is more efficient if we create
a directive that can be used to automatically create validation for our form. 
In addition, if we create separate function for the directive, it allows us
to re-use the functionality for the directive without directly using the
directive.

\subsection{Creating Custom Directive Validator}
Let's create a custom directive validator for numbers. We are using the NX 
workspace. In addition, we are using the Razroo reccomended folder structure. 
A custom directive validator, will go in the common folder for directives. 


\subsubsection{Generate The Directive}
\begin{verbatim}
ng g lib directive --directory=common  
\end{verbatim}

Inside of newly created \lstinline{CommonDirectivesModule}, we will create 
a folder 
\begin{verbatim}
cd libs/common/directives/src/lib/;
mdkir number; 
\end{verbatim}

So now let's navigate to our number folder:
\begin{verbatim}
cd number;  
\end{verbatim}  

and run the appropriate Angular CLI command for generating a directive, 
and exporting it within our \lstinline{CommonDirectivesModule}

\begin{verbatim}
ng g directive number --export  
\end{verbatim}

This will generate the following output inside of the terminal: 
\begin{verbatim}
CREATE libs/common/directives/src/lib/number/number.directive.spec.ts (224 bytes)
CREATE libs/common/directives/src/lib/number/number.directive.ts (144 bytes)
UPDATE libs/common/directives/src/lib/common-directives.module.ts (493 bytes)
\end{verbatim}

\subsubsection{Create The Function for Directive}
Inside of the folder for our number directive, let's also create a number validator file.

\begin{verbatim}
touch validator.ts;
touch validator.spec.ts
\end{verbatim}

Inside of our \lstinline{validate.ts} file, we will go ahead and create logic for numbers.

\begin{lstlisting}[caption=number-validator.ts]
import { AbstractControl, Validators, ValidatorFn } from '@angular/forms';

function isPresent(obj: any): boolean {
  return obj !== undefined && obj !== null;
}

export const number: ValidatorFn = (control: AbstractControl): {[key: string]: boolean} => {
  if (isPresent(Validators.required(control))) return null;

  let v: string = control.value;
  return /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(v) ? null : {'number': true};
}; 
\end{lstlisting}

\subsubsection{Hook In Validator Function to Directive}
We will now go ahead and integrate the number function into our directive. 

\begin{lstlisting}[caption=number.directive.ts]
import { Directive, forwardRef } from '@angular/core';
import { AbstractControl, NG_VALIDATORS, Validator } from '@angular/forms';
import { number } from './validator';

const NUMBER_VALIDATOR: any = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => NumberDirective),
  multi: true
};

@Directive({
  selector: '[razrooNumber]',
  providers: [NUMBER_VALIDATOR]
})
export class NumberDirective implements Validator {
  validate(c: AbstractControl): {[key: string]: any} {
    return number(c);
  }
}  
\end{lstlisting}

We now have the ability to use this as a directive within our application. It 
should be noted that we are doing two unique things within our directive. 
\begin{enumerate}
  \item \lstinline{Validator} -  Our class is implementing \lstinline{Validator}
  which is the same internal function used for validating a formControl. 
  \item We are providing a value called \lstinline{NUMBER_VALIDATOR}. 
  \lstinline{NUMBER_VALIDATOR} will cause the \lstinline{NG_VALIDATOR} 
  \lstinline{injectionToken}, which is the Angular provided token 
  for custom providers, to use the value of \lstinline{NumberDirective}.
  The internal Angular \lstinline{forwardRef} value is there to make sure 
  that it doesn't error out if no value exists. (More on \lstinline{forwardRef}
  in another chapter.)
\end{enumerate}

\subsubsection{Hook In Directive to Component Template}
Now all we need to do, is hook the directive into the template for our 
component. 

\begin{lstlisting}[caption=newsletter.component.html]
<mat-form-field [formGroup]="newsletterForm" class="email-field" >
  <input matInput razrooNumber formControlName="email" placeholder="Your E-mail" required>
</mat-form-field>

<ng-container *ngIf="email.invalid && (email.dirty || email.touched)">
  <mat-error *ngIf="email.errors.number">Not a number</mat-error>
</ng-container>
\end{lstlisting}

As you can see, all we had to add to our input is the directive for 
\lstinline{razrooNumber}. We can then the appropriate \lstinline{mat-error}
within our application in order to hook into the respective error created for number.
The reason it is number, is that within our number validator, we are returning a 
boolean for number. 

\subsection{A Word on This Approach}
If you were to take a look at the documentation, it offers two approaches.
\begin{enumerate}
  \item Template Driven Custom Validators 
  \item Reactive Custom Validators 
\end{enumerate}

Razroo reccomends this approach for using directives, which is a bit contrary to our 
general suggestion of using Reactive Forms. It is our understanding, that reactive 
forms are extremely valuable, because they group the form as one. Making it 
easily accesible from the Typescript side of things. However, in this
particular aspect, of re-using custom validators, re-using functions as a utility 
function, we feel makes the app more brittle than directives. Primarily, because 
directives are more explicit. 

That being said, with our approach, we are separating the logic of validation from 
the actual directive. Moving forward if your team, or other teams within your 
organization would like to use different approaches, they do have the flexibility
to do so. 

\section{Cross Field Validation}
When I first came across the term "cross field validation", I was a bit 
confused. I thought of it as a way for different field's validation to 
be dependent on each other. After reading more, I found that "cross 
field" validation is exactly that. If two, or more validators are true, 
then the form will be valid. If they are both false, then the form will be
invalid.
