\chapter{ Micro Frontends }
Micro frontends is definitely a "buzzword". I consider it most synonymous with the buzzword "the cloud". Simply it means breaking up the application into smaller more manageable parts. So, you might be asking yourself, what makes this different than simply architecting an application well? The answer to that,is that it's not so much folder/file directory, and how you dissect your components, but rather flexibility in bundling and deployment. By allowing for flexible bundling and deployment within app. This accomplishes three things: 
\begin{enumerate}
  \item Increases testability
  \item Increases re-usability
  \item Ability to select multiple frameworks
\end{enumerate}

The truth is that micro-frontends have been around for a really long time. Doing something like this is possible in vanilla Javacript by simply separating micro applications into different folders. A DevOps person would then be able to build these different folders into different javascript bundles. The backend could then at that point in time be responsible for routing, to create a team wide way of accomplishing routing. I've done similar like this in the past. However, I'm not sure if anyone on the team has ever coined this as "micro frontends". I think that we were all struggling so much to keep with the framework we were using, that it never really ever came into focus. 

A large part of the inspiration of micro-frontends, comes from the architecture that has been around with micro-services for quite sometime. 

\section{History of Web Applications}
Now is a good time to discuss the history of web applications, and to understand why it is.

\subsection{Monolith Applications}
In the earlier days, when front ends were relatively new, applications were generally built in a monolith fashion. Applications would be built with a single Java WAR file.

\subsection{Separating Backend and Frontend}
As time went on, backend and frontend would be separated. Html files, and javascript would be separated, and the appropriate data would be inserted using php, or perl tokens, or the like. Every single api was in the php application, and it would be used, by simply inserting the php data needed for that site. 

\subsection{Creating Micoservices}
As time went on, and mobile devices became more popular, including apps, it became more cost efficient for companies to create micro services, that multiple teams could work on. It's important to note that a micro service is not a silver bullet, and won't neccesarily increase the efficiency, and maintainability of your application. However, it has it's place, and greatly resolves scaling issues. 

However, as front ends are growing very large in size, creating micro front ends, it can greatly help us design the architecture of our front end application in a scaleable way.

\section{Recap on Microservices Design Principles}
\begin{enumerate}
  \item High Cohesion 
  \item Autonomous 
Deployed independently 
  \item Business Centric
References a specific area within business 
  \item Resiliency 
If one area of application faults, allows us to degrade just one section of the application. 
  \item Observable 
Centralized logging, and monitoring, we can see what our individual micro front ends are doing.
  \item Automation 
Each micro frontend are independently testable and Deployable. 
\end{enumerate}

\section{Illustration in Code}
A simple way of illustrating how we can create micoservices within Angular, would be as follows. Let's say that we have an application. One of them is a pdf viewer application. The other is the application for analytics. We want our teams to be able to build applications independent of each other. 

\subsection{Adding The Tools We Need}
\begin{verbatim}
ng add @angular/elements
ng add ngx-build-plus
\end{verbatim}

This adds Angular Elements to our app. In addition, we are going to be adding a tool called \lstinline{ngx-build-plus} which allows us to extend the default Angular CLI without injecting. That way, we can continue adding default Angular CLI builds to our app. 

\subsection{General Strategy}
The general strategy is like this. We are going to create miniature using Angular Elements. We are going to then insert these bundled applications into our main Angular application. 

We then will go ahead and route to those specific applications within our application. Ideally using the Angular router. Particularly, because we want it to be robust enough, so that we can go ahead and create router-outlets. 

\section{Difference Of Approach Using Custom Web Components}
The difference between the approach we are using here, and how we approached using custom web components is as follows. When creating micro-frontends, we don't just need access to our custom web components, however, we actually want to build them separately. Once again we do this so that: 
\begin{enumerate}
  \item Increase testability
  \item Increase re-usability
  \item Ability to select multiple frameworks for these specific apps
\end{enumerate}

\section{Leg Work}
