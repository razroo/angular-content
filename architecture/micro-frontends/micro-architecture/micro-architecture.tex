\section{Micro Architecture}
I personally feel that micro architecture has officially made it's way over to front end architecture. This means that it is now important for a UI Engineer, to be aware of what constitutes micro architecture. Martin Fowler, one of my favorites, has an excellent article on what the characteristics of micro-service architecture are. 

[I will admit that I'm a bit new to this micro-service architecture, as I'm starting to break more into backend architecture. However, when I did a deep dive, I started to look for something similar within front end. That is sort what perked my interest, and why I am now writing about it.]

I would like to go through the points mentioned in this article and others I've found as well. However, for the sake of efficiency, only apply those concepts within the confines of micro frontend architecture.

\section{Single Responsibility Principle}
\href{https://en.wikipedia.org/wiki/Robert_C._Martin}{Robert C. Martin}, otherwise known as "Uncle Bob", is best known creating the Agile Manifesto. In addition, he is well known for creating/promoting the SOLID principles. One of the SOLID principles, in fact the first letter stands for the single responsibility principle. The \href{https://en.wikipedia.org/wiki/Single_responsibility_principle}{single responsibility principle} states:

\begin{quote}
  \say{Gather together those things that change for the same reason, and separate those things that change for different reasons.}
\end{quote}

Micro front end architecture is a natural extension of this concept. It takes front ends which serve different purposes, and makes it so that they are developed, deployed, and maintained independently. However, these services can still communicate with each other, thereby gathering those things that change for the same reason.

\section{Micro Frontend Architecture Design Principles}
What a micro frontend would look like:

\subsection{Autonomous Features}
An autonomous feature (in software) means something that can control it's self independently. So an autonomous feature here means a front end that can:
\begin{enumerate}
  \item Independently change 
  \item Independently deploy 
\end{enumerate}
without breaking other front ends. 

What comes out from this, is that in order to independently change and deploy, we will need the following three requirements: 
\begin{enumerate}
  \item Code isolation - We recommend using libraries(e.g. \lstinline{ng g lib product-cart}), to separate micro frontends.
  \item Base app - All of our micro frontends are going to need a base app to hook all of our frontends into each other.
  \item Front End API - Within the context of an enterprise Angular front end application. This means allowing our micro front ends to communicate with eacth other through 
  \begin{enumerate}
    \item The Angular Router
    \item @ngrx/store
    \item services/observables
  \end{enumerate}
  This singular instance, will be piped through the base app, and be triggered through another front end. 
\end{enumerate} 

\subsection{Business Centric}
Each front end address a particular business need of you application.
For instance, let's say that we have an online book store, and that we would like:
\begin{enumerate}
  \item Shopping Cart
  \item Single Book Page
  \item Multiple Book Page
  \item Header
  \item Footer 
\end{enumerate}

Each one of these elements, serves an all around different business purpose within our application. The shopping cart, to give people an option to see everything they've bought so far. The multiple book page, to give the user the ability to see all books we are going to sell. The single book page, to get in depth detail of the book they want to buy. The header, to allow people to properly navigate through our site. The footer to give people an abstract of our information. 

So, based on the fact that each one of these elements contains a different business use, we would build them into their own application(,or once again it's own library, as we will do).

\begin{enumerate}
  \item Code isolation
  \item Base app
  \item Simple feature API
  \begin{enumerate}
    \item Communication with Other Features
    \item Communication with Base App
    \item Communication via services
  \end{enumerate}
\end{enumerate}

\section{Micro Architecture Design Principles}
\begin{enumerate}
  \item High Cohesion 
Deployed independently 
  \item Business Centric
References a specific area within business 
  \item Resiliency 
If one area of application faults, allows us to degrade just one section of the application. 
  \item Observable 
Centralized logging, and monitoring, we can see what our individual micro front ends are doing.
  \item Automation 
Each micro frontend are independently testable and Deployable. 
\end{enumerate}

\section{Team Ownership}
This part can be a bit controversial, and I can definitely see some companies having opposition to this, being that the ecosystem isn't yet fully ready for something like this. However, the idea is, is that now we have a micro frontend,we can actually create an entire "slice" of our product, end to end by one team. This means that a single member, will be expected to contribute to front end, backend and the database. Arguably, this is beneficial for two reasons: 
\begin{enumerate}
  \item Simplifies communication. No need to talk to database, or devops, because they are the devops. 
  \item Simplifies co-ordination. No reason to talk to backend, or database specialist, because they are the specialist. 
  \item Changes happen quicker - Due to expeditious communication.
  \item Improved performance - The developer get's to see how optimization they made on database, or back end, affects the performance on the front end. 
\end{enumerate}