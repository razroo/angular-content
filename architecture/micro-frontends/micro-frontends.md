---
title: Micro Frontends
---
Micro frontends is definitely a "buzzword".

I consider it most synonymous with the buzzword "the cloud". To put it
simply, a micro-frontend is when you break the application into smaller
more manageable parts. So, you might be asking yourself, what makes this
different than simply architecturing an application well? The answer to
that is that it's not so much folder/file directory and how you dissect
your components - but rather flexibility in bundling and deployment. By
allowing for flexible bundling and deployment within app.

This accomplishes three things:

1. Increases testability
2. Increases re-usability
3. Ability to select multiple frameworks

## Micro Frontends are actually already in the wild!

The truth is that micro-frontends have been around for a really long
time. Doing something like this is possible in vanilla JavaScript is
possible, by simply separating micro applications into different JS
bundles. When the page goes to a specific route, it will call this
unique JS bundle. Incredible simple in practice. I've also seen
application get somewhat fancy, wherein routing was generated by the
backend, via devOps. The js bundle would be given a different id every
time, and therefore made sure prior js version would be removed. It was
a relatively painless way for the JS team to create micro front ends.

However, I'm not sure if anyone on the team has ever coined this as
"micro frontends". In addition, doing something like this was a real
pain, and the flexibility was really only there on a single route.

So, why is there is now a push for micro frontends architecture, and why
is it now coming into the forefront? For this, we have to understand a
bit more of the history of web applications.

## History of Web Applications

Let's dive into that really quickly.

### Monolith Applications

In the earlier days, when front ends were relatively new, applications
were generally built in a monolith fashion. Applications would be built
with a single Java WAR file. Your backend code, and and front end code,
were contained in a single file.

### Separating Backend and Frontend

As time went on, backend and frontend would be separated. Html files,
and javascript would be separated. The appropriate data would be
inserted using php, or perl tokens, or the like. Every single api was in
the php application, and it would be used, by simply inserting the php
data needed for that site. However, the whole of the backend would be in
a single php application.

### Creating Micoservices

As time went on, and mobile devices became more popular(i.e. apps), it
became more cost efficient for companies to create micro services.
Primarily, so that multiple teams could work on it. It's important to
note that a micro service is not a silver bullet, and won't neccesarily
increase the efficiency, and maintainability of your application.
However, it has it's place, and greatly resolves scaling issues. So
mutliple backend applications would be built by either different teams,
or singular teams. These would then be able to be deployed in a REST
Service fashion, allowing different clients, such as mobile, or desktop,
to consule.

### Applying Microservice Architecture to Microfrontends

However, as front ends are growing very large in size, and it is
becoming increasinly easy to do so, due to the frameworks readily
available, large teams are required to work on a single application.
It's much easier to break up those teams, give them a singular component
library to work off of, and then have them work in their own clusters.

However, in my personal opinion, micro-frontends are not ready yet for
prime time. There is no open source framework that I can point to, that
would allow for this to be easily done. Or rather, this can be done, but
having a development tool that would allow for this to be done,

Within frameworks yes, and that is a large step. However, it can be a
bit awkward to try and shove on bundle of a particular framework into
another. In particular, because state management, should ideally be
global. Doing this across multiple frameworks, is very difficult at this
point in time.

## Illustration in Code

A simple way of illustrating how we can create micoservices within
Angular, would be as follows. Let's say that we have an application. One
of them is a pdf viewer application. The other is the application for
analytics. We want our teams to be able to build applications
independent of each other.

### Adding The Tools We Need

```
ng add @angular/elements
ng add ngx-build-plus
```

This adds Angular Elements to our app. In addition, we are going to be
adding a tool called `ngx-build-plus` which allows us to extend the
default Angular CLI without injecting. That way, we can continue adding
default Angular CLI builds to our app.

### General Strategy

The general strategy is like this. We are going to create miniature
using Angular Elements. We are going to then insert these bundled
applications into our main Angular application.

We then will go ahead and route to those specific applications within
our application. Ideally using the Angular router. Particularly, because
we want it to be robust enough, so that we can go ahead and create
router-outlets.

## Difference Of Approach Using Custom Web Components

The difference between the approach we are using here, and how we
approached using custom web components is as follows. When creating
micro-frontends, we don't just need access to our custom web components,
however, we actually want to build them separately. Once again we do
this so that:

1. Increase testability
2. Increase re-usability
3. Ability to select multiple frameworks for these specific apps

## Router Dillema

The main dillema within our Angular applications, is the fact that
angular routers consist of two parts:

1. forRoot
2. forChild

Within our web components, or our Angular Elements rather, our forRoot
will be reserved for our root component specifically. If we want to use
web components within our app, forChild won't work either, because these
are all micro front ends. In fact using something like Angular Router
for our application, is a bit of an anti-pattern, because the whole
point is to create a framework agnostic architecture. So, what should we
use within our Angular application.