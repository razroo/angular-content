\chapter{ Network Aware Predictive Pre-Loading }

Pre-loading is a strategy baked into the router in Angular, that allows for
modules to pre-loaded when it becomes available. Lazy loading modules, allows 
for modules to be optimized, so that the initial load, only includes the page 
the user is navigating to. This helps to decrease the initial load time. 
However, depending on how expensive including a module is, pre-loading can
save you time. 

\section{ Being Aware of How Much Time Pre-Loading Saves }
You might be curious as to how much time is actually saved with regards to 
pre-loading? I was curious as well. I tried personally, and the amount of 
time saved, to be honest, is negligable. However, I also realize that the 
app I am working on has a minimal amount of modules. I can see that for 
another app, wherein there are multiple modules that are loaded. Therefore, 
let's throw out an arbitrary number. If you have a module that is going to 
use more than 20 imports inside of it's module, then worry about a pre-loading 
strategy. That being said, it is something that you should be aware of, and
here is how to go around following that strategy. 

\section{Pre-Load Everything}
While this strategy will rarely work for any real-world application, there is 
an option to pre-load everything in Angular. To do so, you would do something 
such as the following: 
\begin{lstlisting}
import { RouterModule, PreloadAllModules } from '@angular/router';

@NgModule({
  imports: [
    RouterModule.forRoot(routes, {
      preloadingStrategy: PreloadAllModules,
    }),
  ],
})
class AppRoutingModule {}
\end{lstlisting}

However, what does make more sense, in an enterprise setting, is custom pre-loading
modules. That is, pre-load the more expensive modules, and not pre-load those that 
are less expensive. In addition, make the pre-loading happen at a time more 
convenient for the app. Let's dive into what that means.

\section{ Custom Pre-Loading }
Angular offers the ability to pre-load content. It offers a \lstinline{preload}
method that takes two arguments: 
\begin{enumerate}
  \item route - Route object to tap into, for the load function.
  \item load - Function when run, triggers the module being loaded
\end{enumerate}

\subsection{General Strategy}
If we wanted to pre-load some modules, and did not want to pre-load others, we
would follow the following strategy:
\begin{enumerate}
  \item Give our route some unique data(i.e. \lstinline{preload: true})
   to be used within our custom pre-loading function.
  \item Create custom pre-loading function, that makes use of our unique data. 
  \item Pass in custom pre-loading as a provider to the \lstinline{preloadingStrategy} 
  key.
\end{enumerate}

\subsection{Strategy Exemplified in Code}
\subsubsection{Give Route Unique Data}
\begin{lstlisting}[caption=app.routing.module.ts]
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    RouterModule.forRoot(
      [
        {
          path: 'books',
          loadChildren: () =>
            import('@razroo/razroo/books').then(
              module => module.RazrooBooksModule
            ),
          data: { preload: true }
        },
        {
          path: 'consulting',
          loadChildren: () =>
            import('@razroo/razroo/consulting').then(
              module => module.RazrooConsultingModule
            )
        },
      ],
      {
        initialNavigation: 'enabled',
        relativeLinkResolution: 'corrected'
      }
    )
  ],
  exports: [RouterModule]
})
export class RazrooAppRoutingModule {}
\end{lstlisting}

\subsubsection{Custom Function For Pre-Loading}
\begin{lstlisting}[caption=custom-preloading.ts]
export class PreloadSelectedModulesList implements PreloadingStrategy {
  preload(route: Route, load: Function): Observable<any> {
    return route.data && route.data.preload ? load() : of(null);
  }
}
\end{lstlisting}

It is worthwhile to note that Razroo put's the \lstinline{custom-preloading.ts} 
util file in the \lstinline{libs/common/utils} folder.

\subsubsection{Pass in custom pre-loading as a Provider}
\begin{lstlisting}[caption=app.routing.module.ts]
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { PreloadSelectedModulesList } from '@razroo/common/ui/utils';

@NgModule({
  imports: [
    RouterModule.forRoot(
      [
        // ...routes go here
      ],
      {
        preloadingStrategy: PreloadSelectedModulesList
        //...
      }
    )
  ],
  exports: [RouterModule]
})
export class RazrooAppRoutingModule {}
\end{lstlisting}

\subsection{ How to See That Module Has Indeed Pre-Loaded }
In order to see that your module has pre-loaded, you can go to the JS
tab in your chrome dev tools. There you will see the amount of time it 
took to load. For me personally, it took about 4 ms. So that is the amount 
of time you might be saving for smaller modules. I would imagine that 
larger modules would take longer. 

\section{ Enabling Module Pre-loading on Custom Event }
If we would like to extend the pre-loading architecture one step further, 
tying in custom events with custom pre-loading, will make things even 
more efficient. In particular, when a user hovers over a navigation menu item, 
we can pre-load a module. 

\subsection{ General Strategy }
The general strategy will look somewhat similar custom pre-loading. 
With some modified/added steps.

\begin{enumerate}
  \item Give our route some unique data(i.e. preload: true)
   to be used within our custom-preloading function.
   \item Create a separate service that will be used to trigger a next on the 
   observable contained in the custom-preloading function. 
   \item Create custom pre-loading function, that makes use of our unique data. In addition, 
   give it access to a \lstinline{Subject}, so it can be triggerred, by an outside service. 
   \item Pass in custom pre-loading service as a provider to the \lstinline{preloadingStrategy} 
   key.
  \item Use a mouseover function, that can trigger the service.
\end{enumerate}

\subsection{ Strategy Exemplified in Code }
We will be giving our route the same unique data: 

\subsubsection{Give Route Unique Data}
\begin{lstlisting}[caption=app.routing.module.ts]
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    RouterModule.forRoot(
      [
        {
          path: 'books',
          loadChildren: () =>
            import('@razroo/razroo/books').then(
              module => module.RazrooBooksModule
            ),
          data: { preload: true }
        },
        {
          path: 'consulting',
          loadChildren: () =>
            import('@razroo/razroo/consulting').then(
              module => module.RazrooConsultingModule
            )
        },
      ],
      {
        initialNavigation: 'enabled',
        relativeLinkResolution: 'corrected'
      }
    )
  ],
  exports: [RouterModule]
})
export class RazrooAppRoutingModule {}
\end{lstlisting}

\subsubsection{ Create a Separate Service to Trigger Pre-Loading }
We will be creating a separate service, that will be used within our CustomPreloadingService
to trigger 


\subsubsection{Custom Pre-Loading Service}
\begin{lstlisting}
import { Injectable } from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { EMPTY, Observable, of } from 'rxjs';
import { mergeMap } from 'rxjs/operators';
import { OnDemandPreloadOptions, OnDemandPreloadService } from './on-demand-preload.service';

@Injectable({ providedIn: 'root', deps: [OnDemandPreloadService] })
export class OnDemandPreloadStrategy implements PreloadingStrategy {
  private preloadOnDemand$: Observable<OnDemandPreloadOptions>;

  constructor(private preloadOnDemandService: OnDemandPreloadService) {
    this.preloadOnDemand$ = this.preloadOnDemandService.state;
  }

  preload(route: Route, load: () => Observable<any>): Observable<any> {
    return this.preloadOnDemand$.pipe(
      mergeMap(preloadOptions => {
        const shouldPreload = this.preloadCheck(route, preloadOptions);
        return shouldPreload ? load() : EMPTY;
      })
    );
  }

  private preloadCheck(route: Route, preloadOptions: OnDemandPreloadOptions) {
    return (
      route.data &&
      route.data['preload'] &&
      [route.path, '*'].includes(preloadOptions.routePath) &&
      preloadOptions.preload
    );
  }
}
\end{lstlisting}

\subsubsection{Pass in Custom Pre-loading Service as a Provider}
\begin{lstlisting}[caption=app.routing.module.ts]
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { CustomPreloadingService } from '@razroo/common/services';

@NgModule({
  imports: [
    RouterModule.forRoot(
      [
        // ...routes go here
      ],
      {
        preloadingStrategy: CustomPreloadingService
        //...
      }
    )
  ],
  exports: [RouterModule]
})
export class RazrooAppRoutingModule {}
\end{lstlisting}

\subsubsection{Trigger Service}
In our particular scenario, as would make sense for alot of applications, is trigger 
module pre-loading on mouseover. We can therefore do something such as the following: 
\begin{lstlisting}
<a
  [routerLink]="item.link"
  class="nav-link"
  (mouseover)="preloadBundle('heroes')"
  >heroes</a
>  
\end{lstlisting}

\begin{lstlisting}
preloadBundle(routePath) {
  this.preloadOnDemandService.startPreload(routePath);
}
\end{lstlisting}

\section{Creating a Directive}
Using this method, we can also create a directive to allow the logic for 
preloading to be re-usable. 

\begin{lstlisting}[caption=preload.directive.ts]
import { Directive, ElementRef, HostListener } from '@angular/core';
import { OnDemandPreloadService } from '@razroo/common/services';

@Directive({
  selector: '[razrooPreload]'
})
export class PreloadDirective {

  constructor(private elementRef : ElementRef,
              private onDemandPreloadService: OnDemandPreloadService) {}

  @HostListener('mouseenter')
  onMouseEnter() {
    const pathName = this.elementRef.nativeElement.attributes.routerlink.value;
    this.onDemandPreloadService.startPreload(pathName);
  }
}
\end{lstlisting}

In the above code for the directive we are assuming that there 
is a routerlink, on the a tag we are looking for. If there isn't, the directive 
will return an error. This allows us to now simply add the following: 
\begin{lstlisting}
  <a routerLink="books" razrooPreload>
  </a> 
\end{lstlisting}

When the user mouses over, we will now be able to see in our chrome console,
that the appropriate module has been pre-loaded. 


