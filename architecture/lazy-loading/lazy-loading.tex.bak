
\chapter{ Lazy Loading Modules }
Lazy loading is one of the many overlooked pieces of UI Architecture. The idea of lazy loadin is loading
something as it is required rather than all at once on page load. It's a form of page 'procrastination' if you think of it that way - only do things at the very last moment and as required. When it comes to Angular, lazy loading is part of the routing/module architecture and is heavily tied to routing. 

The main benefit of lazy loading is that on initial load of the web page we drastically decrease the bundle size. This improves user experience. Thankfully, Angular  makes it relatively easy to include a lazy loaded module into the app. 

The Angular CLI even has a command, for easily setting up a lazy loaded route. However, before we go ahead and show the command, that automatically scaffolds lazy loading for us, let's discuss how to add a lazy loaded route if we were to do that process manually. 

\section{Adding a Lazy Loaded Module Using Angular CLI}
\begin{verbatim}
  ng g lib about --routing --lazy --directory=razroo
\end{verbatim}

This command will automatically add a module to our lib. In addition, will modify the route within the about.module.ts, so that it can be used as a lazy loaded route. 

\mybox{An important note is that all the additional --routing --lazy flags will
add is this line: 
RouterModule.forChild([
  /* {path: '', pathMatch: 'full', component: InsertYourComponentHere} */
])

If you are upgrading an existing module to use lazy loading, the following directions will work for you as well. 
}

\section{What We Should Edit Post Generation}
Now that we have generated a route for our "about" page, let's make the two edits required post CLI generation. 

\subsection{Editing app.module.routing.ts File}
Edit one, will be in our main \lstinline{app.module.routing.ts} file:
\begin{lstlisting}
{
  path: 'about',
  loadChildren: () =>  
    import('@razroo/razroo/about').then(
      module => module.RazrooAboutModule
    )
},
\end{lstlisting}
\footnote{Just in case you are familiar with a different syntax, this is the latest syntax for Angular 8+.}

You will notice two things in the above code: 
\begin{enumerate}
  \item A \lstinline{path} key, standard for Angular routing, to specify what 
  module should be loaded when navigating to a specific route. 
  \item A \lstinline{loadChildren} key, which calls a function followed by the 
  standard syntax for importing a module. 
\end{enumerate}

In addition, being that we are using Nrwl Nx (which this book is littered with)
the import path is using our Nx workspaces shortened path. Here that would be the 
\lstinline{razroo-workspace/razroo-lib/lib-name}.

The second edit for us to make, will be in the actual module for our about page: 
\begin{lstlisting}
@NgModule({
  imports: [
    //...
    RouterModule.forChild([
      {path: '', pathMatch: 'full', component: AboutComponent}
    ])
  ],
  declarations: [AboutComponent]
})
export class RazrooAboutModule {}
\end{lstlisting}

\mybox{You will notice that in the above code we are actually using an AboutComponent. This component will need to be generated in addition to module we've already created, and can be done simply by navigating to our libs folder, and runnning \lstinline{ng g component about}.
}

The above is the cookie cutter process involved with creating a lazy loaded module within an Angular application. With Angular, it is relatively painless process for what it is accomplishing. It is architecture that is worth implementing early on in the app. It might save you from circular dependency nightmares later on. 