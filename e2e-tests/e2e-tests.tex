\maketitle{}
\section{ E2E Tests + TDD/BDD }

One of the tricky things with regards to E2E tests, is how it fits into a
TDD/BDD environment. Writing unit tests before we can see anything in our UI
already takes quite a bit of discipline. Adding in an E2E test to the workflow
seems like a bit much? Ok, so let's get into the thick of it. I think we'll all
have a good time!

\subsection{ What is TDD? }

\begin{enumerate}
  \item Start by writing a test
  \item Run the test and any other tests. At this point, your newly added test
   should fail. If it doesnâ€™t fail here, it might not be testing the right
   thing and thus has a bug in it.
  \item Write the minimum amount of code required to make the test pass
  \item Run the tests to check the new test passes
  \item Optionally refactor your code
  \item Repeat from 1
\end{enumerate}

\subsection{ The Benefits of TDD? }
\begin{enumerate}
  \item Higher test coverage. \footnote{Emphasis is put on testing}
  \item Focus
    \begin{enumerate}
      \item Focus one part of issue one of a time.
      \item Allows one to realize when to stop coding.
    \end{enumerate}
  \item Interfaces
    \begin{enumerate}
      \item Allows you to think what is actually being baked into code more
      thoroughly. Allowing for interface to be written from the bottom
      up(behavior, implementation), instead of top down(implementation,
      behavior)
    \end{enumerate}
  \item Living Documentation. \footnote{Not to mention very verbose.}
  \item Enforces Pure Functions - Or re-usable code
    \begin{enumerate}
      \item As pure functions are easier to test, it will cause the developer
      to veer towards writing more pure functions.
      \item If pure functions are not an option, it will nonetheless cause the
      developer to veer towards re-usable code, and re-usable specs. \footnote{
      because this is the developer who is going to have to write tests time
      and time again.
      }
    \end{enumerate}
\end{enumerate}

\subsection{ What is BDD? }
Typically when testing a particular function at a later date, that function can
change it's implementation. For instance, the counter can start at 5, instead of
zero, breaking the expect statement of 1, when it is now 6. In BDD we focus on
the intended behavior, which is adding 1 to a particular value.

First things, first. Which comes first, unit test, or E2E tests? E2E tests will
end up going first, however, we will end up satisfying the unit tests first.

\begin{lstlisting}
// Non BDD
describe('Counter', () => {
  it('tick increases count to 1', () => {
    var counter = new Counter();

    counter.tick();

    expect(counter.count).toEqual(1);
  });
});

// BDD
describe('Counter', () => {
  it('should increase count by 1 after calling tick', () => {
    var counter = new Counter();
    var expectedCount = counter.count + 1;

    counter.tick();

    expect(counter.count).toEqual(expectedCount);
  });
});
\end{lstlisting}

\subsection{ The Benefit of BDD }
If at a later time the counter(as seen above), for instance, has to change
based on requirements(starting at 5, instead of 1), it will not affect the unit
test. That's it plain and simple, almost too simple, hmm... suspicious.
