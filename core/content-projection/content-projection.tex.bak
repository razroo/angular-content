\chapter{ Content Projection }

Any component can technically be re-usable. What makes content projection so great is that it allows the content inside of a component to change based on the need of the application. It also allows us to separate concerns. We can build a component for display and another component built for handling user actions.

\section{ Single Slot Projection }
If we wanted to create a component that allows us to use content projection, it is as simple as adding ng-content inside of our component:
\begin{lstlisting}
<!-- inside reusable component -->
<ng-content></ng-content>

<!-- inside component, consuming the re-usable component -->
<reusable-component> <p>Content goes here</p> </reusable-component>
\end{lstlisting}

Using our <reusable-component> we have the ability to put it wherever we want and change the content based on the parent component consuming it. What if we have two separate places withing our component that we would like to inject content. For instance, let's say we havea card component, and we want there to be different content inside of the headerand main body of the component?

\section{ Multiple Slot Projection }
This is my preferred method of mutliple content projection, by creating bindingcontent projection to class. In particular, because I feel it's a great ofmaking sure content projection is transparent across the entire lifecycle. Wecan now do the following:

\begin{lstlisting}
<div class="header">
<ng-content select=".header"></ng-content>
</header>
<div class="body">
<ng-content select=".body"></ng-content>
</div>
\end{lstlisting}

In our parent component consuming the re-usable component:
\begin{lstlisting}
<reusable-component>
<div class="header">CSS</div>
<div class="body">{{css-data}}</div>
</reusable-component>
\end{lstlisting}

Just like that, we can have our content project in multiple places, into the
re-usable component.

\section{Styling Projected Content}
One of the scenarios that comes up alot with regards to projected content, isattempting to style it. For instance, you might want the content in onecomponent to have a top border, and in others for the text color to be of adifferent style. So how would we do this, being that we are projecting thecontent into a separate component?
\mybox{It should be mentioned that styling in this matter isn't the rightapproach. However, because there are times wherein styling in this fashion isneccesary for the particular use case, this is most definitely usefulmentioning.}
\begin{verbatim}
:host ::ng-deep .header {
  color: blue;
}

:host ::ng-deep .body {
  margin-top: pxl-space-multiplier(1);
}
\end{verbatim}

Just like that, we are able to style the content within our project.

\section{ Interacting with Projected Content }
One more scenario to take into consideration whenworking with projected contentis to interact with it. For instance, let's say that we want to project aninput field into our projected content. In addition, we would like to determinewhen that input field has been clicked on? The following is the best stategy.We will create a directive, that focuses on event handling.
\footnote{Refer back to the chapter on directives. Generally speaking directiveshelp solve two things:
\begin{enumerate}
  \item Event handling
  \item Passing in Values
\end{enumerate}
These two tend to work in tandem with each other. Similarly here, we will beusing directives to pass in a value, and have it work in tandem with eventhandling.}

\subsection{ An Example }
This is a simple directive, that targets the focus and blur of host elementusing the @HostListener element.

\begin{lstlisting}
@Directive({
  selector: '[inputRef]'
})
export class InputRefDirective {
  focus = false;

  @HostListener("focus")
  onFocus() {
    this.focus = true;
  }

  @HostListener("blur")
  onBlur() {
    this.focus = false;
  }
}
\end{lstlisting}

Not we can pass this inputRef directive onto our projected content:
\begin{lstlisting}
<h1>FA Input</h1>
<fa-input icon="envelope">
  <input inputRef type="email" placeholder="Email">
</fa-input>
\end{lstlisting}

Now within our re-usable component, we can use the \lstinline{@ContentChild}decorator to inject the \lstinline{inputRefDirective} within our component. Then,we can use the \lstinline{@HostBinding} decorator to change the class on ourre-usable component, based on the status of the input ref.
\begin{lstlisting}
@Component({
  selector: 'fa-input',
  template: `
    <i class="fa" [ngClass]="classes"></i>
    <ng-content></ng-content>
  `,
  styleUrls: ['./fa-input.component.css']
})
export class FaInputComponent {

  @Input() icon: string;

  @ContentChild(InputRefDirective)
  input: InputRefDirective;

  @HostBinding("class.focus")
  get focus() {
    return this.input ? this.input.focus : false;
  }

  get  classes() {
    const cssClasses = {
      fa: true
    };
    cssClasses['fa-' + this.icon] = true;
    return cssClasses;
  }
}
\end{lstlisting}

\section{ Wrapping Up }
As we have seen, content projection is a very powerful way of re-using contentwithin our component. We have also covered the two stereo-typical uses cases,which we will have to solve in an enterprise app from time to time. I.e. eventhandling for our project content, as well as controlling the styling for ourprojected content.