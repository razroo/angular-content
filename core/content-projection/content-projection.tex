\section{ Content Projection }
\maketitle{}

Any component can technically be re-usable. However, what makes content
projection so great, is that it allows the content inside of a component to
change based on the need of the application. In addition, it allows us to
separate concerns. We can build a component for display, and another component
built for handling user actions.

\subsection{ Single Slot Projection }
If we wanted to create a component wherein we can use content projection, it is
as simple as adding ng-content inside of our component:
\begin{lstlisting}
<!-- inside reusable component -->
<ng-content></ng-content>

<!-- inside component, consuming the re-usable component -->
<reusable-component> <p>Content goes here</p> </reusable-component>
\end{lstlisting}

As we can see, using our <reusable-component>, we have the ability to put it
whereever we want, and change the content based on the parent component
consuming it. However, what if we have two separate places withing our
component that we would like to inject content. For instance, let's say we have
a card component, and we want there to be different content inside of the header
and main body of the component?

\subsection{ Multiple Slot Projection }
This is my preferred method of mutliple content projection, by creating binding
content projection to class. In particular, because I feel it's a great of
making sure content projection is transparent across the entire lifecycle. We
can now do the following:

\begin{lstlisting}
<div class="header">
<ng-content select=".header"></ng-content>
</header>
<div class="body">
<ng-content select=".body"></ng-content>
</div>
\end{lstlisting}

In our parent component consuming the re-usable component:
\begin{lstlisting}
<reusable-component>
<div class="header">CSS</div>
<div class="body">{{css-data}}</div>
</reusable-component>
\end{lstlisting}

Just like that, we can have our content project in multiple places, into the
re-usable component.

\subsection{Styling Projected Content}
One of the scenarios that comes up alot with regards to projected content, is
attempting to style it. For instance, you might want the content in one
component to have a top border, and in others for the text color to be of a
different style. So how would we do this, being that we are projecting the
content into a separate component?
\mybox{It should be mentioned that styling in this matter isn't the right
approach. However, because there are times wherein styling in this fashion is
neccesary for the particular use case, this is most definitely useful
mentioning.}
\begin{verbatim}
:host ::ng-deep .header {
  color: blue;
}

:host ::ng-deep .body {
  margin-top: pxl-space-multiplier(1);
}
\end{verbatim}

Just like that, we are able to style the content within our project.

\subsection{ Interacting with Projected Content }
One more scenario to take into consideration when working with projected content
is to interact with it. For instance, let's say that we want to project an
input field into our projected content. In addition, we would like to determine
when that input field has been clicked on? The following is the best stategy.
We will create a directive, that focuses on event handling.
\footnote{Refer back to the chapter on directives. Generally speaking directives
help solve two things:
\begin{enumerate}
  \item Event handling
  \item Passing in Values
\end{enumerate}
These two tend to work in tandem with each other. Similarly here, we will be
using directives to pass in a value, and have it work in tandem with event
handling.
}

\subsubsection{ An Example }
This is a simple directive, that targets the focus and blur of host element
using the @HostListener element.

\begin{lstlisting}
@Directive({
  selector: '[inputRef]'
})
export class InputRefDirective {
  focus = false;

  @HostListener("focus")
  onFocus() {
    this.focus = true;
  }

  @HostListener("blur")
  onBlur() {
    this.focus = false;
  }
}
\end{lstlisting}

Not we can pass this inputRef directive onto our projected content:
\begin{lstlisting}
<h1>FA Input</h1>
<fa-input icon="envelope">
  <input inputRef type="email" placeholder="Email">
</fa-input>
\end{lstlisting}

Now within our re-usable component, we can use the \lstinline{@ContentChild}
decorator to inject the \lstinline{inputRefDirective} within our component. Then,
we can use the \lstinline{@HostBinding} decorator to change the class on our
re-usable component, based on the status of the input ref.
\begin{lstlisting}
@Component({
  selector: 'fa-input',
  template: `
    <i class="fa" [ngClass]="classes"></i>
    <ng-content></ng-content>
  `,
  styleUrls: ['./fa-input.component.css']
})
export class FaInputComponent {

  @Input() icon: string;

  @ContentChild(InputRefDirective)
  input: InputRefDirective;

  @HostBinding("class.focus")
  get focus() {
    return this.input ? this.input.focus : false;
  }

  get  classes() {
    const cssClasses = {
      fa: true
    };
    cssClasses['fa-' + this.icon] = true;
    return cssClasses;
  }
}
\end{lstlisting}

\subsection{ Wrapping Up }
As we have seen, content projection is a very powerful way of re-using content
within our component. We have also covered the two stereo-typical uses cases,
which we will have to solve in an enterprise app from time to time. I.e. event
handling for our project content, as well as controlling the styling for our
projected content.
