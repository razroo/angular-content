\maketitle{}
\section{ Transitions and Triggers }

It is worth noting that there are a number of transition states. We discussed 
from open to close, and from close to open. There are, however, other states 
that are equally as important to discuss. 

\subsection{ Wildcard Matching }
Using an asterisk in a transition state, will represent any sort of situation. 

For instance, let's say were to use: 
\begin{verbatim}
  open => closed 
  open => *
  * => closed
  * => *
\end{verbatim}
All of the above four, will match when an element's state changes from open to 
anything else. A good rule of thumb, is that similar to routing, wherein the 
asterisk will be a wild card meant to match any remaining use cases, animation
transitions also follow in the same vein. 

\subsection{ Situations where a Wildcard can be Used }
\subsubsection{ Using Wildcard with Styles }
\begin{lstlisting}
transition ('* => open', [
  animate ('1s',
    style ({ opacity: '*' }),
  ),
]),  
\end{lstlisting}

In the above, the transition of animate of 1s, will match whatever it is that
the current stule is. 

\subsubsection{ Combining Wildcard and Void States }
A void state, is a way of causing an animation to occur whenever an element is 
entering, or leaving a page. The proper syntax for letting Angular knowing that 
an element should be animated when leaving, or entering would be to do the 
following: 
\begin{lstlisting}
animations: [
  trigger('flyInOut', [
    //...
    transition('void => *', [
      //...
    ]),
    transition('* => void', [
      //...
    ])
  ])
]
\end{lstlisting}

\subsubsection{ :enter and :leave aliases }

However, Angular allows for the following alias, called \lstinline{:enter} and
\lstinline{:leave}. 

\begin{lstlisting}
animations: [
  trigger('flyInOut', [
    state('in', style({ transform: 'translateX(0)' })),
    transition(':enter', [
      style({ transform: 'translateX(-100%)' }),
      animate(100)
    ]),
    transition(':leave', [
      animate(100, style({ transform: 'translateX(100%)' }))
    ])
  ])
]
\end{lstlisting}

In the above code, when an \lstinline{HTML} element isn't attached to the view, 
we apply a transition. When entering the page, the element will fly in. When 
leaving the page, the element will fly out. 

It is important to note that \lstinline{:enter} and \lstinline{:leave} will
only run, if the element is removed, or added. Therefore, it is required to 
leave an \lstinline{*ngIf} on the div. An example, would be something such as
the following: 
\begin{lstlisting}[caption=insert-remove.component.html]
<div @myInsertRemoveTrigger *ngIf="isShown" class="insert-remove-container">
  <p>The box is inserted</p>
</div>  
\end{lstlisting}

\begin{lstlisting}[caption=insert-remove.component.ts]
trigger('myInsertRemoveTrigger', [
  transition(':enter', [
    style({ opacity: 0 }),
    animate('5s', style({ opacity: 1 })),
  ]),
  transition(':leave', [
    animate('5s', style({ opacity: 0 }))
  ])
]),  
\end{lstlisting}

\mybox{We do not need to use \lstinline{state}, due to the fact that these
transitions are expected to happen in all scenarios.}

\subsection{When a Value Increases, or Decreases}
Angular has a built in transition for when a value increases, or decreases. 
\begin{lstlisting}
  trigger('filterAnimation', [
    transition(':enter, * => 0, * => -1', []),
    transition(':increment', [
      query(':enter', [
        style({ opacity: 0, width: '0px' }),
        stagger(50, [
          animate('300ms ease-out', style({ opacity: 1, width: '*' })),
        ]),
      ], { optional: true })
    ]),
    transition(':decrement', [
      query(':leave', [
        stagger(50, [
          animate('300ms ease-out', style({ opacity: 0, width: '0px' })),
        ]),
      ])
    ]),
  ]),  
\end{lstlisting}


If the above, when the value is incremented, it will cause a transition to 
happen. 

\mybox{You might be wondering what would be the value of something like this 
within an Angular application setting. The value is that if there is something 
like a slider, you are able to bake transitions, into the counter of the 
slider. Now, whenever the slider goes to the next slide, it can cause a 
transition to happen.}

\subsection{ Transitions for Boolean Values }
In many situations, we have the need for, should something be opened, or closed. 
Should it be shown, or hidden? For situations like this, Angular offers the 
ability to create transitions based on booleans: 
\begin{lstlisting}[caption=open-close.component.html]
<div [@openClose]="isOpen ? true : false" class="open-close-container">
</div>
\end{lstlisting}
and
\begin{lstlisting}[caption=open-close.component.ts]
animations: [
  trigger('openClose', [
    state('true', style({ height: '*' })),
    state('false', style({ height: '0px' })),
    transition('false <=> true', animate(500))
  ])
],
\end{lstlisting}

\subsection{ Multiple Animation Triggers }
In an Angular setting, each time an animation is triggered, the parent always
get's priority, and cuts off the ability for child animation to run. In order 
for a child animation to run, a parent element must trigger an 
\lstinline{animateChild} function placed on the child element. 
\begin{lstlisting}[caption=open-close.component.html]
<div [@.disabled]="isDisabled">
<div [@childAnimation]="isOpen ? 'open' : 'closed'"
  class="open-close-container">
  <p>The box is now {{ isOpen ? 'Open' : 'Closed' }}!</p>
</div>
</div>  
\end{lstlisting}
\begin{lstlisting}[caption=open-close.component.ts]
@Component({
  animations: [
    trigger('childAnimation', [
      // ...
    ]),
  ],
})
export class OpenCloseChildComponent {
  isDisabled = false;
  isOpen = false;
}
\end{lstlisting}

\mybox{ In the above html we are using something called \lstinline{@.disabled}.
When it is applied on the parent div, all animations on the element, as well as 
nested animations, are disabled. Likewise, to disable all animations for an 
Angular app, a hostBinding can be applied to the top most Angular component.}

\subsection{ Animation Callbacks }
There are times wherein one might want to tap into a particular time period of
an animation. For instance, let's say there is a slow API request, you might 
want the download button to have some sort of pulsating animation, if it takes
too long. When API request completes, the pulsating can stop. An icon can work 
as well, however, there is some psychology behind if the actual item clicked 
on is the one that animates, as opposed to bringing in an outside icon. So 
let's imagine we are triggering an animation, we can do something such as 
the following: 
\begin{lstlisting}[caption=open-close.component.ts]
@Component({
  selector: 'app-open-close',
  animations: [
    trigger('openClose', [
      // ...
    ]),
  ],
  templateUrl: 'open-close.component.html',
  styleUrls: ['open-close.component.css']
})
export class OpenCloseComponent {
  onAnimationEvent ( event: AnimationEvent ) {
  }
}  
\end{lstlisting}

\begin{lstlisting}[caption=open-close.component.html]
<div [@openClose]="isOpen ? 'open' : 'closed'"
  (@openClose.start)="onAnimationEvent($event)"
  (@openClose.done)="onAnimationEvent($event)"
  class="open-close-container">
</div>
\end{lstlisting}

\subsubsection{ Debugging Animations using Callbacks }
Let's imagine in the above \lstinline{animationEvent}, if we were instead to
use cram our animationEvent with the following: 
\begin{lstlisting}[caption=open-close.component.ts]
export class OpenCloseComponent {
  onAnimationEvent ( event: AnimationEvent ) {
    // openClose is trigger name in this example
    console.warn(`Animation Trigger: ${event.triggerName}`);

    // phaseName is start or done
    console.warn(`Phase: ${event.phaseName}`);

    // in our example, totalTime is 1000 or 1 second
    console.warn(`Total time: ${event.totalTime}`);

    // in our example, fromState is either open or closed
    console.warn(`From: ${event.fromState}`);

    // in our example, toState either open or closed
    console.warn(`To: ${event.toState}`);

    // the HTML element itself, the button in this case
    console.warn(`Element: ${event.element}`);
  }
}  
\end{lstlisting}

In the above, we can now view exactly what is happening within our animation 
and can use this to determine animation if anything is awry. 

\subsection{ Keyframes }
Many animations happen to have a simple two step solution. For instance, show 
and hide component, or maximize height. However, there might be an animation 
that might be more than two steps. For animations of this scale, we will want
to use Angular's \lstinline{keyframe()} function, which is very similar to 
keyframes in CSS \footnote{Keyframes in CSS can be seen 
\href{https://www.w3schools.com/cssref/css3_pr_animation-keyframes.asp.}{here}}.