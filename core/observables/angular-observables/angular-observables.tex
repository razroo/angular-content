
\section{ Angular Observables }
It's important to point out, that there are observables that are unique to 
Angular. It is important to be aware of the fact that internally they are 
using an observable. 

\subsection{ Event Emitter }

\begin{lstlisting}
<zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
\end{lstlisting}

\begin{lstlisting}
@Component({
  selector: 'zippy',
  template: `
  <div class="zippy">
    <div (click)="toggle()">Toggle</div>
    <div [hidden]="!visible">
      <ng-content></ng-content>
    </div>
  </div>`})

export class ZippyComponent {
  visible = true;
  @Output() open = new EventEmitter<any>();
  @Output() close = new EventEmitter<any>();

  toggle() {
    this.visible = !this.visible;
    if (this.visible) {
      this.open.emit(null);
    } else {
      this.close.emit(null);
    }
  }
}
\end{lstlisting}

\subsection{ Async Pipe }
The async pipe, which we will discuss more due to it's high usage within the
app. 

\begin{lstlisting}
@Component({
  selector: 'async-observable-pipe',
  template: `<div><code>observable|async</code>:
       Time: {{ time | async }}</div>`
})
export class AsyncObservablePipeComponent {
  time = new Observable(observer =>
    setInterval(() => observer.next(new Date().toString()), 1000)
  );
}
\end{lstlisting}

The async pipe will subscribe to an observable(,or promise) and returns the 
latest value it has emitted. When new value has been emitted, the pipe marks 
the component to be checked for changes. 

\subsection{ Router }
\subsubsection{Events}
Router events are supplied as an observable. So let's say we want to listen 
in, into when a router event has reached a certain point we would be able to 
do that. 
\begin{lstlisting}
import { Router, NavigationStart } from '@angular/router';
import { filter } from 'rxjs/operators';

@Component({
  selector: 'app-routable',
  templateUrl: './routable.component.html',
  styleUrls: ['./routable.component.css']
})
export class Routable1Component implements OnInit {

  navStart: Observable<NavigationStart>;

  constructor(private router: Router) {
    // Create a new Observable that publishes only the NavigationStart event
    this.navStart = router.events.pipe(
      filter(evt => evt instanceof NavigationStart)
    ) as Observable<NavigationStart>;
  }

  ngOnInit() {
    this.navStart.subscribe(evt => console.log('Navigation Started!'));
  }
}
\end{lstlisting}

\subsubsection{ ActivatedRoute }
\lstinline{ActivatedRoute} "contains the information about a route associated
with a component loaded in an outlet." Specifically, one of the pieces of 
information that the \lstinline{ActivatedRoute} injected router service 
provides is \lstinline{ActivatedRoute.url} which is provided as an observable. 

\begin{lstlisting}
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-routable',
  templateUrl: './routable.component.html',
  styleUrls: ['./routable.component.css']
})
export class Routable2Component implements OnInit {
  constructor(private activatedRoute: ActivatedRoute) {}

  ngOnInit() {
    this.activatedRoute.url
      .subscribe(url => console.log('The URL changed to: ' + url));
  }
}
\end{lstlisting}
Using the above observable, we are able to determine what the url is at any
given time. 

\subsection{ Reactive Forms }
Reactive forms, is another core Angular library that makes use of Observables. 
In particular, the \lstinline{FormControl} \lstinline{valueChanges} property 
contains an observable that determines whenever an event occured. 
\begin{lstlisting}
import { FormGroup } from '@angular/forms';

@Component({
  selector: 'my-component',
  template: 'MyComponent Template'
})
export class MyComponent implements OnInit {
  pxForm: FormGroup;

  ngOnInit() {
    this.logNameChange();
  }
  logNameChange() {
    const rowControl = this.pxForm.get('name');
    rowControl.valueChanges.subscribe(data => {
      console.log('data');
      console.log(data);
    });
  }
}  
\end{lstlisting}

Using valueChanges in the context of formControl can be incredibly useful. 
There might be special effects, or some sort of hurdle you need to come 
across when building out this form, and it helps very much so in this 
regard. 

\mybox{Important to note, that http requests within Angular also support 
Observables. However, Razroo best practices, is that we support the use of 
Apollo Client over Angular's native http request. For that reason, it has been
left out of this chapter.}

\subsection{What is the Point of this??? }
You might be asking yourself, what is the point of knowing specifically that 
there are observables that are baked into the framework? It would seem one 
would be able to just read up on the documentation, and be able to get done 
what you need in that fashion. What value is there in organizing all of the 
Angular observables into one location? 

I think this chapter makes alot of sense. In particular, because it lays out
all the parts of the Angular framework, wherein observables make sense. Very 
smart, and well thought out individuals have built, and continue to build the 
Angular framework. Therefore, it would stand to reason, that one should be 
particularly aware of these four scenarios: 
\begin{enumerate}
  \item Event Emitter
  \item Async Pipe
  \item Router
  \item Forms
\end{enumerate}

In all of them, being aware of the value at any given time, is incredibly 
important. If something has an observable it means: 
\begin{enumerate}
  \item Level of complexity is higher 
  \item Subject to change, and needs higher level of architecture
  \item Interacts with data heavily outside of component instantiation
\end{enumerate}
 
So keep an eye out for the above, next time you work on your Angular 
application.
