
\chapter{ Observables }
Observables are an integral part of any Angular application. There is no way 
around not using observables if using state management within your application. 
In addition, if your backend is using GraphQL + Apollo, which is the 
reccomended way of pulling in data, your application will have to implement 
observables. The reason observables are so popular and it has made it's way
into mainstream Angular, is because it is so intuitive to use. An observable 
will consist of two things: 
\begin{enumerate}
  \item Publisher 
  \item Subscriber
\end{enumerate}

Think of a publisher as a way of saying here is the data, I want you to watch. 
When something does indeed change, pull the data from the subscriber. This 
allows for the publisher to take place in one piece of your code, pass that 
through a facade of sorts, and then consume it in another file. 

\section{ Rxjs - An Observable Example! }
We will be using \lstinline{rxjs} as our library to create Observables. It is 
used internally by many Angular libraries, and for good reason. For starters
It is increcibly intuitive to use. Functions are imported as are any other 
Javascript/Typescript library. Second, rxjs, is a part of the larger ReactiveX 
ecosytem. Knowing how to use rxjs, you will be able to transfer your knowledge
to other frameworks, such as Java, Swift, Python and more!

\begin{lstlisting}
import { from } from 'rxjs';

// Create an Observable out of a promise
const data = from(fetch('/api/endpoint'));
// Subscribe to begin listening for async result
data.subscribe((data) => {
  // emit data returned from endpoint
 console.log(data);
});
\end{lstlisting}

\mybox{from - Turn an array, promise or iterable into an observable}

In the above code, we are using the native rxjs \lstinline{from} function to
turn our code into an observable(this is what we defined earlier as a 
publisher). We then subscribe to the publisher/observable, so that when the 
data request completes, and the data is pulled in, the subscriber will now 
emit the data, and make it available for the app to consume. 

\section{ Operators and Pipes }
One of the most powerful features of rxjs, is that it offers the ability to 
combine operators to allow for sophisticated manipulation of functions. While 
this is not a real world example, it definitely helps in order to better 
understand how pipeable operators work in the real world: 
\begin{lstlisting}
import { filter, map } from 'rxjs/operators';

const nums = of(1, 2, 3, 4, 5);
  
// Create a function that accepts an Observable.
const squareOddVals = pipe(
  filter((n: number) => n % 2 !== 0),
  map(n => n * n)
);  

// Create an Observable that will run the filter and map functions
const squareOdd = squareOddVals(nums);
 
// Subscribe to run the combined functions
squareOdd.subscribe(x => console.log(x));
\end{lstlisting}

\mybox{of - Similar to \lstinline{from}, only \lstinline{of} takes values only,
instead of being passed an array. 
filter - Similar to filter in javascript. Will return all values that pass 
the provided condition. 
map - Similar to map in Javascript. Will apply projection with each value in 
source. 
}
In the above code, we are using two separate operators, and chaining them 
within our pipe. First we pull in odd values using the filter, then we 
multiple files using the map. This can be an extremely powerful way of 
using chained operators within rxjs. In particular, in scenarios like search
rxjs can be extremely powerful. 

\section{ Common Operators }
Rxjs is full of numerous operators. However, there really are only a certain
amount of operators that are used. 
\begin{center}
  \begin{tabular}{@{} l *4c @{}}
    \toprule
    \multicolumn{1}{c}{\color{red}Area} & Operators \\
    \midrule
    Creation       & from, fromEvent, of \\
    Combination    & combineLatest, concat, merge, startWith , withLatestFrom, zip \\
    Filtering      & debounceTime, distinctUntilChanged, filter, take, takeUntil \\
    Transformation & bufferTime, concatMap, map, mergeMap, scan, switchMap \\
    Utility        & tap \\
    Multicasting   & share \\
  \end{tabular}
\end{center}  

\section{ Naming Conventions for Observables }
A very popular convention for writiing observables within Angular, and really
any setting is add a trailing \lstinline{$} to the end of the variable. 
\begin{lstlisting}
import { Component } from '@angular/core';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-stopwatch',
  templateUrl: './stopwatch.component.html'
})
export class StopwatchComponent {

  stopwatchValue: number;
  stopwatchValue$: Observable<number>;

  start() {
    this.stopwatchValue$.subscribe(num =>
      this.stopwatchValue = num
    );
  }
}  
\end{lstlisting}

In the above component, \lstinline{stopwatchValue$} is visibly an observable,
because it has the dollar sign. Why a dollar sign you ask? It's a clever way 
of appending an "S" to the end of a variable, and signifying that it is 
special. The s stands for stream - which is a sequence of values over time.



