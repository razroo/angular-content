\section{ Dependency Injection }


Dependency Injection on it's own a important design pattern. It solves the
following problems in any scenario:
\begin{enumerate}
  \item How can a class be independent of how it's objects are created.
  \item How can way objects are create be specified in different configuration
  files.
  \item How can an application support different configurations?
\end{enumerate}

Angular has adopted dependency injection as part of it's framework since the
inception of AngularJS. When using dependency in real world applications, it
immediately becomes obvious that it is extremely useful for unit testing. Less obvious, but something somewhat intuitive as well, is that it helps keep bundle
sizes compact. In addition, as we discussed above, it allows us to keep our
configurations separate. While the ability to export/import is an option within
Typescript, dependency injection, allows the framework to be completely aware
of everything being used within the framework.

\subsection{ Real World Example }

\subsubsection{ Creating Injectable Service }
The DI(Dependency Injection) Framework, allows for an injectable service class
to be passed to a component. For instance, let's say that we want to create an
Injectable service, we would do the following:
\begin{lstlisting}
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class PxCodeService {
  constructor() { }
}
\end{lstlisting}

This code right here is doing two things:
\begin{enumerate}
  \item It is saying that this service is an Injectable.
  \item It is saying that this injectable should be provided in the root(aka the
  AppModule).
\end{enumerate}

\mybox{Now would be a good time to discuss what the \lstinline{providedIn}
property does. It does two things:
\begin{enumerate}
  \item Angular creates a single, shared instance of the service and injects it
  into any class that asks for it. So, there is no need to insert it as a
  provider for your module, and you can simply pull it into your class whenever
  you want. \footnote{Don't worry if you are not familiar with how to use a
  service in your class, we will get to that soon.}
  \item It also allows Angular to optimize an app, by removing the service from
  the compiled app, if it isn't used. \footnote{Taken from documentation for
  Angular.}
\end{enumerate}
}

\subsubsection{ Including Injectable Service in Component }
Now if we would like to include this service in our component, we would do the
following:
\begin{lstlisting}
// code-box.component.html
<div *ngFor="let codeBox of codeBoxes">
  {{codeBox.data}}
</div>
\end{lstlisting}

\begin{lstlisting}
// code-box.component.ts
import { Component }   from '@angular/core';
import { CodeBox }        from './code-box.interfaces';
import { PxCodeFacade } from './px-code.facade';

@Component({
  selector: 'px-code-box',
  template: './code-box.component.html',
  styles: ['./code-box.component.scss'],
})
export class HeroListComponent {
  codeBoxes: CodeBox[];

  constructor(pxCodeFacade: PxCodeFacade) {
    this.codeBoxes = pxCodeFacade.getCodeBoxes();
  }
}
\end{lstlisting}

\mybox{Now would technically be a good time on discussing how to test these
mocked dependencies, however it get's a little bit complicated. This section is
going to be moved to the bit on Angular architecture.}

\subsection{Services that need other services}
Services can have their own dependencies. If we wanted to inject a service, into
our service, it would be as simple as doing the following:
\begin{lstlisting}
import { Injectable } from '@angular/core';
import { Logger } from '../logger.service';

@Injectable({
  providedIn: 'root',
})
export class PxCodeService {
  constructor(private logger: Logger) { }

  getLog() {
    this.logger.log('getting codeboxes');
  }
}
\end{lstlisting}

As we can see in the above, our injected service, is taking another injected
service. By simply passing it into the constructor, similar to how we do for our
components, we can use it within our application.

\subsection{ Dependency Injection Token }
Internally Angular uses dependency injection tokens for injectable services, to
reference what injectable it is using. Outside of injectable services, we can
use depedency tokens directly within our app. However, we are able to create a
new depedency injection token within our app. There are two different ways of
providing tokens in Angular:
\begin{enumerate}
  \item strings - {provide: ``EmailService'', useClass: MandrillService}
  \item type tokens - {provide: EmailService, useClass: MandrillService}
  \item injection tokens - new InjectionToken{provide: EmailService, useClass:}
  avoids name clashes.
\end{enumerate}

Tokens can be a useful way for providing a default value to be used across the 
app, and then hijacking the value, and providing something else, in the 
scenarios where it is not of use. 
