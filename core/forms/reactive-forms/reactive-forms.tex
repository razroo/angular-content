
\chapter{ Reactive Forms }

Reactive forms are extremely under-rated. As we have discussed before, there are 
many reasons as to why forms are very complicated. Reactive forms are no 
exception to that rule. However, we will discuss them all now. In additionm we
are going to run through all the steps to get from point a to point b, so that
you can constantly reference this, as you create a new reactive form component.

\section{ Registering Reactive Forms }

Importing a reactive module, is no different than your regular module, however,
this is the module to use to when importing reactive forms. 

\begin{lstlisting}
import { ReactiveFormsModule } from '@angular/forms';

@NgModule({
  imports: [
    // other imports ...
    ReactiveFormsModule
  ],
})
export class AppModule { }
\end{lstlisting}

\section{Generating a component, and adding FormControl}
No different than any other scenario: 
\begin{verbatim}
ng generate component grid-form 
\end{verbatim}

In your component simply add a new \lstinline{FormControl}: 

\begin{lstlisting}
import { Component } from '@angular/core';
import { FormControl } from '@angular/forms';

@Component({
  selector: 'px-grid-form',
  templateUrl: './grid-form.component.html',
  styleUrls: ['./grid-form.component.css']
})
export class NameEditorComponent {
  size = new FormControl('');
}
\end{lstlisting}

\section{Registering Control in Template}
\begin{lstlisting}
<label>
  Name:
  <input type="text" [formControl]="name">
</label>
\end{lstlisting}

As mentioned in the previous chapter, FormControl, will allow you to access 
value of form within component, and view. Most importantly, update in view 
or component, and have it affect the other. 

\section{ Displaying Component }
We can now include the component in any other component. E.g. 
\begin{lstlisting}[caption=app.component.html]
<px-grid-form></px-grid-form>  
\end{lstlisting}

\section{ Grouping Form Controls }
A FormControl on it's own has value. Primarily being able set a value, and
accesing it within the template. However, a \lstinline{formControl} is 
incomplete without a \lstinline{formGroup}. A \lstinline{formGroup}, will give us 
access to all of the formControl values, so we can use them all, when 
submitting a form. 

\begin{lstlisting}
import { Component } from '@angular/core';
import { FormGroup, FormControl } from '@angular/forms';
 
@Component({
  selector: 'px-grid-form',
  templateUrl: './grid-form.component.html',
  styleUrls: ['./grid-form.component.css']
})
export class GridFormComponent {
  gridForm = new FormGroup({
    row: new FormControl(''),
    column: new FormControl(''),
  });
}
\end{lstlisting}

\section{ Connecting FromGroup model and view }
\begin{lstlisting}
<form [formGroup]="gridForm">
  <label>
    First Name:
    <input type="text" formControlName="row">
  </label>

  <label>
    Last Name:
    <input type="text" formControlName="column">
  </label>
</form>
\end{lstlisting}
Within our template, we attach the \lstinline{formGroup} directive supplied by
the \lstinline{ReactiveFormsModule}, to our component's \lstinline{new FormGroup}.

\section{Saving Form Data}
The formGroup directive internally has an \lstinline{(ngSubmit)} method, that 
can be used to call whenever you are ready to save data for the entire form, 
and pass it along to the backend. 
\begin{lstlisting}[caption=code-form.component.html]
<form [formGroup]="gridForm" (ngSubmit)="onSubmit()">
\end{lstlisting}

\begin{lstlisting}[caption=grid-form.component.ts]
onSubmit() {
  // this is where data for gridForm is exposed
  console.log(this.gridForm.Value);
}
\end{lstlisting}

\section{ Nested Form Groups }
In Angular, there is the ability to create nested form groups: 

\begin{lstlisting}[caption=px-code-form.component.ts]
import { Component } from '@angular/core';
import { FormGroup, FormControl } from '@angular/forms';

@Component({
  selector: 'px-code-form',
  templateUrl: './code-form.component.html',
  styleUrls: ['./code-form.component.css']
})
export class CodeFormComponent {
  profileForm = new FormGroup({
    row: new FormControl(''),
    column: new FormControl(''),
    address: new FormGroup({
      street: new FormControl(''),
      city: new FormControl(''),
      state: new FormControl(''),
      zip: new FormControl('')
    })
  });
}
\end{lstlisting}

A great way to think of nested form groups, is that it is exactly like creating 
a nested data object. The only different is that any parent, contains formGroup, 
whereas children use formControl. 

\section{ Grouping nested form in the template } 
Now that we have created a nested FormGroup property within a class, lets' go
ahead and show how we would access these values within our template.
\begin{lstlisting}
<div formGroupName="address">
  <h3>Address</h3>

  <label>
    Street:
    <input type="text" formControlName="street">
  </label>

  <label>
    City:
    <input type="text" formControlName="city">
  </label>
  
  <label>
    State:
    <input type="text" formControlName="state">
  </label>

  <label>
    Zip Code:
    <input type="text" formControlName="zip">
  </label>
</div>
\end{lstlisting}

Most notably you will notice that we are using the \lstinline{formGroupName}
directive. The \lstinline{formGroupName} directive, will sync a 
\lstinline{formGroup} to a template. That allows us to access any children of
that \lstinline{formGroup} by simply accessing name, using \lstinline{formControlName}. 

\section{ Partial Model Updates }
We have already discussed in the previous chapter, the ability to update a 
specific \lstinline{formControl} by using the \lstinline{setValue()} option is 
definitely a viable option. However, what if we would like to update multiple 
values at the same time within a \lstinline{formGroup()} Angular provides the 
method called \lstinline{patchValue()}. So for instance, let's say we wanted
to update the \lstinline{firstName}, and street address: 
\begin{lstlisting}
updateProfile() {
  this.profileForm.patchValue({
    firstName: 'Nancy',
    address: {
      street: '123 Drew Street'
    }
  });
}
\end{lstlisting}

\section{ Generating form controls with FormBuilder }
The Angular team realized how excessive it is to constantly include \lstinline{FormControl}'s
and \lstinline{FormGroup}'s everytime one wants to build out a form. Instead
they created something called the \lstinline{FormBuilder}. 
\begin{lstlisting}
  import { Component } from '@angular/core';
  import { FormBuilder } from '@angular/forms';
  
  @Component({
    selector: 'app-profile-editor',
    templateUrl: './profile-editor.component.html',
    styleUrls: ['./profile-editor.component.css']
  })
  export class ProfileEditorComponent {
    profileForm = this.fb.group({
      firstName: [''],
      lastName: [''],
      address: this.fb.group({
        street: [''],
        city: [''],
        state: [''],
        zip: ['']
      }),
    });
  
    constructor(private fb: FormBuilder) { }
  }  
\end{lstlisting}

As we can see in the above, instead of having to attach \lstinline{FormGroup} to the
parents, and attaching \lstinline{FormControl} to every child, we can just use 
\lstinline{fb.group} on every parent. So, so nice!
