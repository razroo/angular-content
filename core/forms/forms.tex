\maketitle{}
\section{ Forms }

Forms to this day, I think is still one of the most complicated pieces of UI,
you will ever come across. Each input in a form, has a unique piece of 
functionality to it. It can be one of the most fustrating pieces of UI, 
because there is no way to make it truly re-usable as a result. In 
addition, it can be very fustrating to explain to business as to why it is 
taking so long, as a form seems truly simple to make. Over the course of this 
book we will discuss why it is that, that is the case, as well. In addition,
we will discuss ways that we can alleviate the pain of forms. In the meantime 
let's discuss the fundementals of forms. 

\subsection{ Let's Get Something Out of the Way }

Angular offers two ways of handling forms: 
\begin{enumerate}
  \item Reactive Forms 
  \item Template-driven Forms
\end{enumerate}

Whether, or not someone should choose reactive forms, or template driven 
forms is a large area of debate in an Angular setting. Personally, I believe 
and this is probably the most debatable point in this book. I strongly 
believe that if you have chosen Angular as your framework, then you are most 
likely a medium, sized, or large sized corporation. In which case, you need 
your forms to be scalable, with the ability to test well. In addition, less 
prone to bugs. There is a fantastic article by a one Netanel Basel, where 
he claims that we need to say goodbye to Angular Template-Driven Forms
\footnote{\href{https://netbasal.com/why-its-time-to-say-goodbye-to-angular-template-driven-forms-350c11d004b}{Why it's Time to Say Goodbye to Angular Template-Driven Forms}}.
There is an equally amazing comment left by a one Ward Bell. It sums in totally the 
following, which I must credit to Deborah Kurata: 

\subsubsection{Template Driven}
\begin{enumerate}
  \item Easy to use
  \item Similar to Angular 1
  \item Two-way data binding -> Minimal component code
  \item Automatically tracks form and input element state
\end{enumerate}

\subsubsection{ Reactive }
\begin{enumerate}
  \item More flexible \textrightarrow{} more complex scenarios
  \item Immutable Data Model
  \item Easier to perform an action on a value change
  \item Reactive transformations \textrightarrow{} DebounceTime or DistinctUntilChanged
  \item Easily add input elements dynamically
  \item Easier Unit Testing
\end{enumerate}

Personally, the easier unit testing would be enough for me to go with 
Reactive Forms. However, there is also the additional reason that 
Netanel Basel mentions, that very much so resonates with me, and that 
is readability. The ability to look at a data object with the ts  file to see 
all of the form related items within the app, is simply fanastic. 

For that reason, I am simply going to mention Reactive forms within this book. 
The truth is, is that the Angular documentation it's self sort of says 
something along the same way. So if you are working on an enterprise app, then 
I would highly reccomend you do stick with using reactive forms. If you do 
want to explore the subject of template driven forms on your own, I invite you
to go ahead and read through the Angular documenation 
\href{https://angular.io/guide/forms-overview#setup-in-template-driven-forms}{here}. 
Now that we have established that we will be using Reactive forms, let's get into 
what they are all about!

\subsection{ Common Foundation of Forms }
\begin{enumerate}
  \item \lstinline{FormControl} - Tracks the value and validation state of an 
  individual form control.
  \item \lstinline{FormGroup} - Tracks the same values and status for a 
  collection of form controls.
\begin{lstlisting}
import { Component } from '@angular/core';
import { FormGroup, FormControl } from '@angular/forms';
 
@Component({
  ...
})
export class CodeEditorComponent {
  codeForm = new FormGroup({
    row: new FormControl(''),
    column: new FormControl(''),
  });
}
\end{lstlisting}
  The codeForm property, now has access to all of the formControls within the
  app.
  \item \lstinline{FormArray} - Tracks the same values and status for an array
  of form controls. 
  \item \lstinline{ ControlValueAccessor } - Creates a bridge between Angular
  FormControl instances, and native DOM elements.
\end{enumerate}

\subsection{ Reactive Forms }
First and foremost, it's important to get a really get handle on what Reactive
means. Reactive means that your code is:
\begin{enumerate}
  \item Asynchronous - An action happens, and something happens right after. 
  Even though this can happen in regular javascript code, ideally if 
  something is asyncrhonous, it is baked into the framework, making it 
  more of a default.
  \item Deterministic -  Given action a happens, always action b, will 
  happen. Reactive forms do this, wherein a user can be sure a certain 
  thing will happen granted an input is affected.
\end{enumerate}

\subsubsection{ Reactive Form Example }
Reactive forms are an embodiment of the above, and I would like to show off an
example that portays this: 

\begin{lstlisting}
import { Component } from '@angular/core';
import { FormControl } from '@angular/forms';
  
@Component({
  selector: 'px-color-picker',
  template: `
    Background Color: <input type="text" [formControl]="backgroundColor">
  `
})
export class pxColorPickerComponent {
  backgroundColor = new FormControl('');
}
\end{lstlisting}

In the above code, the data for the form is controlled by FormControl. Here we
have attached it to a \lstinline{backgroundColor} value accessor. Whenever we 
want to retrieve the value of \lstinline{backgroundColor}, or modify it, we 
can tap into the value for \lstinline{backgroundColor}. 

\subsection{ Reactive Forms - Data Flow }

\subsubsection{View To Model}
In Reactive forms, the data flow is pretty straight forward. As we have already
mentioned, that view is directly related to the component's instance of 
\lstinline{FormControl} in the component. 
\begin{enumerate}
  \item User types into input
  \item Form input emits event with latest value of input
  \item Control value accessor \footnote{Control value accessor is an internal value within the 
  FormControl} listening for events on the form relays value 
  to \lstinline{FormControl} instance. 
  \item \lstinline{FormControl.valueChanges} observable emits new value 
  \item Subscribers to the value changes observable receive new value. 
\end{enumerate}

\subsubsection{ Model To View }
\begin{enumerate}
  \item User calls setValue method on FormControl(e.g. \lstinline{backgroundColor})
  \item \lstinline{FormControl.valueChanges} emits new value
  \item subscribers to FormControl.valueChanges recieve new value
  \item The control value accessor on the form input element, updates the 
  element with the new value. 
\end{enumerate}

\subsection{Form Validation}
Form validation is something that seems like it would belond as the same 
category as unit testing. For instance, let's make sure that nothing wrong 
happens with regards to user submission. However, form validation, i.e. 
making sure the right content is being inputted, before user submits, has a 
very large reason beyond correcting user error. It is to prevent abust my 
malicious users. Of the ways forms can be abused is: 
\begin{enumerate}
  \item Header injection attacks can be used to send email spam from your web 
  server
  \item Cross-site scripting may allow an attacker to post any data to your 
  site
  \item SQL injection may corrupt your database backend
\end{enumerate}

\subsection{ Reactive Form Validation }
Angular offers form validation out of the box. In addition, it gives the
ability to create custom validators. There are two types of validators: 
\begin{enumerate}
  \item Sync Validators
  \item Async Validators
\end{enumerate}

For performance reasons you will only want to use async validators. 

\subsubsection{Built In Validators}

\begin{lstlisting}
ngOnInit(): void {
  this.heroForm = new FormGroup({
    'name': new FormControl(this.hero.name, [
      Validators.required,
      Validators.minLength(4),
      forbiddenNameValidator(/bob/i) // <-- Here's how you pass in the custom validator.
    ]),
    'alterEgo': new FormControl(this.hero.alterEgo),
    'power': new FormControl(this.hero.power, Validators.required)
  });

}

get name() { return this.heroForm.get('name'); }

get power() { return this.heroForm.get('power'); }
\end{lstlisting}

Let's dissect the above code real quick: 

\begin{enumerate}
  \item We use \lstinline{Validators.required} and \lstinline{Validators.minLength(4)}
  and one custom validator \lstinline{forbiddenNameValidator}.
  \item All these validators are all sync validators, you pass them in as the 
  second argument.
  \item You can use multiple validators, by passing in functions as a part of 
  the array
  \item We use getters to access values. Even though we can access values by
  
\end{enumerate}

In addition, we need to add the respective errors within the template, so that
we can view the errors if they so arise. 

\begin{lstlisting}
<input id="name" class="form-control"
  formControlName="name" required >

<div *ngIf="name.invalid && (name.dirty || name.touched)"
  class="alert alert-danger">

  <div *ngIf="name.errors.required">
    Name is required.
  </div>
  <div *ngIf="name.errors.minlength">
    Name must be at least 4 characters long.
  </div>
  <div *ngIf="name.errors.forbiddenName">
    Name cannot be Bob.
  </div>
</div>
\end{lstlisting}

One note to just keep in mind, is that we are using the name getter in the 
components class, to access errors. 

\subsubsection{Custom Validators}
The built in validators, as with anything that is built in, might not always
match the exact use case of your application. 

\subsection{ Testing Reactive Forms }
Testing reactive forms is relatively straight forward: 

\subsubsection{ Testing View To Model }

\begin{lstlisting}[caption=Testing View to Model]
it('should update the value of the input field', () => {
  const input = fixture.nativeElement.querySelector('input');
  const event = createNewEvent('input');

  input.value = 'Red';
  input.dispatchEvent(event);

  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');
});
\end{lstlisting}

In the above code we are doing the following: 
\begin{enumerate}
  \item Query view for form input element, and create custom input event for
  the test.
  \item Set the value for the inout, and dispatch input event.
  \item Asser that component's new value, based on dispatched event, matches
  the value from the input. 
\end{enumerate}

\subsubsection{ Testing Model To View }

\begin{lstlisting}
it('should update the value in the control', () => {
  component.favoriteColorControl.setValue('Blue');

  const input = fixture.nativeElement.querySelector('input');

  expect(input.value).toBe('Blue');
});
\end{lstlisting}

In the above code we are doing the following: 
\begin{enumerate}
  \item Set value on the Form Control instance, to set the new value 
  \item Assign the view for the form input element to a constant
  \item Tap into that constant's value, and assert that it is the new value
\end{enumerate}

