\maketitle{}
\section{ Forms }

Forms to this day, I think is still one of the most complicated pieces of UI,
you will ever come across. Each input in a form, has a unique piece of 
functionality to it. It can be one of the most fustrating pieces of UI, 
because there is no way to make it truly re-usable as a result. In 
addition, it can be very fustrating to explain to business as to why it is 
taking so long, as a form seems truly simple to make. Over the course of this 
book we will discuss why it is that, that is the case, as well. In addition,
we will discuss ways that we can alleviate the pain of forms. In the meantime 
let's discuss the fundementals of forms. 

\subsection{ Let's Get Something Out of the Way }

Angular offers two ways of handling forms: 
\begin{enumerate}
  \item Reactive Forms 
  \item Template-driven Forms
\end{enumerate}

Whether, or not someone should choose reactive forms, or template driven 
forms is a large area of debate in an Angular setting. Personally, I believe 
and this is probably the most debatable point in this book. I strongly 
believe that if you have chosen Angular as your framework, then you are most 
likely a medium, sized, or large sized corporation. In which case, you need 
your forms to be scalable, with the ability to test well. In addition, less 
prone to bugs. There is a fantastic article by a one Netanel Basel, where 
he claims that we need to say goodbye to Angular Template-Driven Forms
\footnote{\href{https://netbasal.com/why-its-time-to-say-goodbye-to-angular-template-driven-forms-350c11d004b}{Why it's Time to Say Goodbye to Angular Template-Driven Forms}}.
There is an equally amazing comment left by a one Ward Bell. It sums in totally the 
following, which I must credit to Deborah Kurata: 

\subsubsection{Template Driven}
\begin{enumerate}
  \item Easy to use
  \item Similar to Angular 1
  \item Two-way data binding -> Minimal component code
  \item Automatically tracks form and input element state
\end{enumerate}

\subsubsection{ Reactive }
\begin{enumerate}
  \item More flexible \textrightarrow{} more complex scenarios
  \item Immutable Data Model
  \item Easier to perform an action on a value change
  \item Reactive transformations \textrightarrow{} DebounceTime or DistinctUntilChanged
  \item Easily add input elements dynamically
  \item Easier Unit Testing
\end{enumerate}

Personally, the easier unit testing would be enough for me to go with 
Reactive Forms. However, there is also the additional reason that 
Netanel Basel mentions, that very much so resonates with me, and that 
is readability. The ability to look at a data object with the ts  file to see 
all of the form related items within the app, is simply fanastic. 

For that reason, I am simply going to mention Reactive forms within this book. 
If you do want to explore the subject of template driven forms on your own, I 
invite you to go ahead and read through the Angular documenation 
\href{https://angular.io/guide/forms-overview#setup-in-template-driven-forms}{here}. 
Now that we have established that we will be using Reactive forms, let's get into 
what they are all about!

\subsection{ Common Foundation of Forms }
\begin{enumerate}
  \item \lstinline{FormControl} - Tracks the value and validation state of an 
  individual form control.
  \item \lstinline{FormGroup} - Tracks the same values and status for a 
  collection of form controls.
  \item \lstinline{FormArray} - Tracks the same values and status for an array
  of form controls. 
  \item \lstinline{ ControlValueAccessor } - Creates a bridge between Angular
  FormControl instances, and native DOM elements.
\end{enumerate}

\subsection{ Reactive Forms }
First and foremost, it's important to get a really get handle on what Reactive
means. Reactive means that your code is:
\begin{enumerate}
  \item Asynchronous - An action happens, and something happens right after. 
  Even though this can happen in regular javascript code, ideally if 
  something is asyncrhonous, it is baked into the framework, making it 
  more of a default.
  \item Deterministic -  Given action a happens, always action b, will 
  happen. Reactive forms do this, wherein a user can be sure a certain 
  thing will happen granted an input is affected.
\end{enumerate}

\subsubsection{ Reactive Form Example }
Reactive forms are an embodiment of the above, and I would like to show off an
example that portays this: 

\begin{lstlisting}
import { Component } from '@angular/core';
import { FormControl } from '@angular/forms';
  
@Component({
  selector: 'px-color-picker',
  template: `
    Background Color: <input type="text" [formControl]="backgroundColor">
  `
})
export class pxColorPickerComponent {
  backgroundColor = new FormControl('');
}
\end{lstlisting}

In the above code, the data for the form is controlled by FormControl. Here we
have attached it to a \lstinline{backgroundColor} value accessor. Whenever we 
want to retrieve the value of \lstinline{backgroundColor}, or modify it, we 
can tap into the value for \lstinline{backgroundColor}. 

\subsection{ Reactive Forms - Data Flow }

\subsubsection{View To Model}
In Reactive forms, the data flow is pretty straight forward. As we have already
mentioned, that view is directly related to the component's instance of 
\lstinline{FormControl} in the component. 
\begin{enumerate}
  \item User types into input
  \item Form input emits event with latest value of input
  \item Control value accessor \footnote{Control value accessor is an internal value within the 
  FormControl} listening for events on the form relays value 
  to \lstinline{FormControl} instance. 
  \item \lstinline{FormControl.valueChanges} observable emits new value 
  \item Subscribers to the value changes observable receive new value. 
\end{enumerate}

\subsubsection{ Model To View }
\begin{enumerate}
  \item User calls setValue method on FormControl(e.g. \lstinline{backgroundColor})
  \item \lstinline{FormControl.valueChanges} emits new value
  \item subscribers to FormControl.valueChanges recieve new value
  \item The control value accessor on the form input element, updates the 
  element with the new value. 
\end{enumerate}

\subsection{Form Validation}

