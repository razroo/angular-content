
\chapter{ Template Syntax }

\section{ Difference between Property and Attribute in HTML }

First, and foremost, it is important to understand the difference between HTML 
attributes and properties. I know myself, when writing this chapter, I realized
that I did not fully understand the difference between an HTML attribute, and
an HTML property. So I thought, why no re-iterate here, and hopefully it will
make this subject a bit easier to understand. First let's dive into what the 
computer science definition of a property, and an attribute would be. 

Property - Something that can be read and written. Within a typescript setting, 
this would be something that would be translated into a \lstinline{get} and  
\lstinline{set} within Typescript. 

Attribute - More correctly should be considered as a metadata. Something that
is a property of a property, describing what the parent property is doing. 

In HTML, the above definitions are a bit obscured. For instance, let's say
that we are defining the type of input field, as well as it's value. 
\begin{lstlisting}
<input type="text" value="Name:">  
\end{lstlisting}

The \lstinline{type} and \lstinline{value} are attributes, as they are 
explaining what the \lstinline{input} property is doing (aka metadata).
However, once the browser parses the code, it will turn it into an 
\lstinline{HTMLInputElement} object. This contains dozens of properties, like 
\lstinline{className}, \lstinline{clientHeight}, and methods, such as 
\lstinline{click()}. The browser will create a new sort of property based on 
the type of native html element it is creating. 

\mybox{\lstinline{<script>} tags in Angular, unlike modern html are forbidden!
It will result in an error. This is done to prevent from script injections.}

\section{ Property Binding (In Angular) }
In Angular, property binding is a way to set properties of a particular 
element. In addition, it is a way to set \lstinline{@Input()} decorators set 
on the actual directive. 

\begin{lstlisting}
<img [src]="itemImageUrl">
\end{lstlisting}

You might be wondering why this is called property binding instead of 
attribute binding. \lstinline{src} is actually an attribute. The reason behind1
this, is that Angular's engine will actually first initialize the component, 
and then change the property set by the browser. In addition, Angular will 
compile the component, as an object, and therefore internally is setting 
objects, i.e. properties. I just thought it was a fun fact, and is actually 
what led me to research the above re: attributes and properties. Another great
proof of this, is that if we were to modify the column span for a table by 2
it would be: 
\begin{lstlisting}
<tr><td [colSpan]="2">Span 2 columns</td></tr>
\end{lstlisting}

You will notice that the above syntax for \lstinline{colSpan} is camel cased 
as oppoed to the lowercased \lstinline{colspan}. This is because we are using
Angular's internal property binding engine to set the value. It is instead of 
using the native lowercased attribute \lstinline{colspan}. 

\mybox{You might be wondering why Angular decided to choose brackets for 
property binding. Without delving too much, in Javascript, wrapping an array 
around a value, signifies that it is property. Angular is just borrowing from
that syntax.}

\subsection{ Remembering Brackets }
If you omit the brackets \lstinline{[]}, then Angular will treat the value
provided as a constant. Which means for the most part, you should be using
brackets. There are threee situations wherein omitting brackets make sense. 
\begin{enumerate}
  \item Target property actually uses a string. For instance, the text for 
  the header title. 
  \item Value of initialization never changes.
\end{enumerate}

\section{ Attribute Binding }
As we discussed earlier, there is a very distinct difference between 
attributes and properties. Setting a property is always preferable 
simply because the syntax is more straight forward. However, there are many 
Javascript properties that simply arent't available as properties. A great
example of this is SVG's and ARIA labels. In a scenario like this , we can bind 
to an attribute by doing something like the following: 
\begin{lstlisting}
<!-- create and set an aria attribute for assistive technology -->
<button [attr.aria-label]="actionName">{{actionName}} with Aria</button>  
\end{lstlisting}

So we can bind to attributes similarly to how we bind to properties. Depending
on the nature of your application, it may not, or not happen on a frequent 
basis.

\section{ Event Binding }
Event binding, is an event listening mechanism built into Angular. Whenever 
something such a keyboard button pressed(keystrokes), mouse moves, clicks etc. 
it will be able to trigger the appropriate function at that time. The syntax 
for doing something like this is as follows: 
\begin{lstlisting}
<button (click)="onSave($event)">Save</button> 
\end{lstlisting}

In the above code, we are telling Angular, when a user clicks on the button 
emit the method contained within our respective component called 
\lstinline{onSave}. 

\mybox{You might be wondering why Angular chose to use parenthesis for handling 
event handlers. To me of all the different sorts of syntaxes, it always made 
the most sense, because parenthesis is remniscient of functions. Event handling
always results in functions. So that is what the syntax is telling us. Which 
function would you like to trigger based on the handling of this event.}

\section{\$event}
In addition, we are supplying it with \lstinline{$event} which is Angular's way
of internally passing data for that particular component. Depending on the 
target event, it will change what is returned by \lstinline{$event}. For 
instance, if it is a native DOM element event, then \lstinline{$event} will be 
a DOM event object. If it is not a native DOM element, and instead something 
such as an event emitter, then event will contain the value passed on through 
the event emitter. 

\section{NgClass}
\lstinline{NgClass} is a special way to add, or remove multiple CSS classes 
at the same time. More importantly, it gives you the ability to add a class 
conditionally based on whether, or not a value is true. 
\begin{lstlisting}
<!-- toggle the "special" class on/off with a property -->
<button (click)="!isOpen">Toggle</button>
<div [ngClass]="isOpen ? 'open' : ''">This div is special</div>
\end{lstlisting}

In the above code, we are toggling the class active based on the status of 
the toggle. So when the toggle button is clicked on, \lstinline{isOpen} will 
now be true, and as a result, "open" class will now be active. 
\lstinline{isActive}. 

\mybox{The question mark(?) and colon (:), is the standard syntax for ternary
operator in Javscript. Meaning if value is true, perform operation after
 \lstinline{?} i.e. \lstinline{'open'}. If value is not true, then perform 
 operation after \lstinline{:}} i.e. \lstinline{''}. 

 \section{ NgStyle }
This one is debatable if I want to include in the book. Let's discuss at a
later period of time. 

\section{ NgModel }
Let's look into and see if this is something that we want, and decide if we 
want to get back to this. 

\section{ NgSwitch }
\lstinline{NgSwitch} is Angular's template version of a Javascript 
\lstinline{switch} statement. Like switch statements in Javascript, there are 
very few use cases wherein it makes sense. In addition, in data heavy 
applications, in general, using something like GraphQL, you will be able to 
choose what data should come back based on a certain response. However, there 
are scenarios, where keeping lstinline{NgSwitch} in your arsenal will be 
useful. \lstinline{NgSwitch} consists of three directives: 
\begin{enumerate}
  \item \lstinline{NgSwitch} - The switch in which to compare case statements against. 
  \item \lstinline{NgSwitchCase} - The case statement, in which to display 
  value, if match is truthy. 
  \item \lstinline{NgSwitchDefault} - The default value, if none of the other
  case values are matched. 
\end{enumerate}

\begin{lstlisting}
<div [ngSwitch]="code.type">
  <px-css-item    *ngSwitchCase="'css'"    [item]="currentItem"></px-stout-item>
  <px-scss-item   *ngSwitchCase="'scss'"     [item]="currentItem"></px-device-item>
  <px-javascript-item     *ngSwitchCase="'javascript'"  [item]="currentItem"></px-javascript-item>
  <!-- . . . -->
  <px-unknown-item  *ngSwitchDefault           [item]="currentItem"></px-unknown-item>
</div>
\end{lstlisting}

\section{ Template Reference Variables }
Template reference variables are incredibly useful within an application, and 
are commonly used within Angular. The reason for this, is that it is 
referencing the:
\begin{enumerate}
  \item DOM element within the template
  \item Directive/Component
  \item \lstinline{TemplateRef}
  \item Web Component
\end{enumerate}

In order to reference a partcular template, use the hash symbol, and a name of 
your choosing. 

\begin{lstlisting}
<input #row placeholder="code" />  

<button (click)="initiateGrid(row.value)">Initiate Grid</button>
\end{lstlisting}

In the above, using our \lstinline{ref} value, we are able to retrieve the 
text entered into our input DOM element(i.e. row.value). Based on the scenario, 
ref values have their use cases. 

\section{ Safe Navigation Operator }
Many times when retrieving data, it might come back as null, or undefined. In
scenario like this, doing the following: 
\begin{lstlisting}
<p>Hello {{user.name}}! How can we help you today?</p>  
\end{lstlisting}

In the above, if user returns as null, or undefined, the browser will return 
an error: 
\begin{lstlisting}
TypeError: Cannot read property 'name' of null.  
\end{lstlisting}

However, if we use the safe navigation operator: 
\begin{lstlisting}
  <p>Hello {{user?.name}}! How can we help you today?</p>  
\end{lstlisting}

(notice the addition of the question mark, appended to our parent variable), 
Angular will stop evaluating as soon as it hits the first \lstinline{null}
value. It will therefore render without any erorrs.

This also works with longer property paths. For instance: 
\begin{lstlisting}
<p>Hello {{user?.admin?.name}}! How can we help you today?</p>    
\end{lstlisting}

In any data heavy enterprise app, you can expect to use the safe navigation
operator quite often. If you want, you can call it the elvis operator. 
