\chapter{ Custom Type Definitions }

\section{Understanding Custom Type Definitions}
Before we describe what a custom type definiton is, let's walk through the food chain so to speak in Typescript. 

\subsection{Type Annotation}
First, there is what we quite frequently see within a Typescript application called a type annotation. That looks something like this: 
\begin{verbatim}
const userName: string;  
\end{verbatim}

In the above, we are using Typescript's internal framework, to inform that compiler, that the type of this constant is a string. 

\subsection{Typescript Interface}
Moving on, the next level would be an interface. A Typescript interface can be used to describe an entire object, such as the following user interface: 
\begin{lstlisting}[caption=Typescript User Interface]
export interface User {
  password: string;
  userName: string;
  email: string;
}
\end{lstlisting}

Now, in our application, if we plan on having user data, we can annotate that object with our interface. A common enterprise example of this: 
\begin{lstlisting}[caption=user.reducer.ts]
export interface UserState {
  list: User; // list of Users; analogous to a sql normalized table
  selectedId?: string | number; // which User record has been selected
  loaded: boolean; // has the User list been loaded
  error?: any; // last none error (if any)
}  
\end{lstlisting}

In the above interface for UserState, our list, which is where our reducer is going to place user data, has the type annotation for the \lstinline{User} interface.

\subsection{What is a Type Definition? Modules and Namespaces}
In order to understand type definitions in Typescript, we need to understand modules and namespaces in Typescript. 
\subsubsection{Modules in Typescript}
A module in Typescript is any file containing: 
\begin{enumerate}
  \item Values 
\begin{verbatim}
// e.g.  
export const person: Person;  
\end{verbatim}  
\item Functions
\begin{verbatim}
// e.g. 
export function square(n: number) {
  return n * n;
}
\end{verbatim}
\item Classes (e.g. export const person: Person;)
\begin{verbatim}
// e.g.
@Component({
  selector: 'razroo-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent {
  constructor() {}
}
\end{verbatim}
\end{enumerate}

A great example of using a module in Typescript is a classic \lstinline{import}. It's so commonplace that you've undoubtedly come across of it, and when you read this code example will say, "ooooh, that's a module, i know what that is" \lstinline{module}
\begin{lstlisting}
import { add } from "./math";
\end{lstlisting}

\^ the above would be a module in Typescript.

\subsubsection{Namespaces in Typescript}
Similarly, you most likely have come across a namespace in Typescript as well. It looks somthing like this:
\begin{lstlisting}
import * as math from "./math";
\end{lstlisting}
A namespace in Typescript is a way to group features(e.g. interfaces, functions etc.) and objects that share common relationships. So in the above, if we access now anything within the math file, all we would have to do is:
\begin{verbatim}
this.math.add(2, 3);
// 5  
\end{verbatim}

A great way to better understand namespaces, is to think of it as an internal module system. In this way, interfaces, classes, functions, and variables are all included into the internal Typescript compiler. (we will get to how we can create a global namespace later).

\subsubsection{Global in Typescript - The Last Piece}
There is just one last missing foundational piece in order to understand what and how a type definition is created. In Typescript, there is the ability to 
create global variables, functions, and namespaces. For instance, if we want to create a variable called \lstinline{car} and have it available across our entire app, we can use something really cool called \lstinline{declare}: 

\begin{verbatim}
declare let razrooAssetsBaseURL = 'assets/logo';  
\end{verbatim}

Now that we have this global variable within our app, we can use it anwhere we want. 
\begin{lstlisting}[caption=useless.component.ts]
console.log('razrooAssetsBaseURL');
console.log(razrooAssetsBaseURL);
\end{lstlisting}

We can also create a global namespace, without the need of using a import/export. We would do this by writing: 
\begin{verbatim}
declare namespace myLib {
  function makeGreeting(s: string): string;
  let numberOfGreetings: number;
}  
\end{verbatim}

\subsubsection{What is a Type Definition}
A type definition in Angular 

First and foremost, a type annotation, is what you will quite frequently see within typescript. For instance, something specifying that a 


Typescript by default actually includes type definitions for all of core
Javascript. Any time you are using a core javascript method, typescript
within it's core framework has a typing for it. However, any time you
plan on using something not a part of core Typescript, you will have to
create a type definition. 

\section{Example Scenario}
For instance, in another chapter, we reccomend using the native Network 
Information API. Because it is experimental(at the time of this writing),
as is the case in all scenarios, the Typescript team has not included 
type definitions for it. So, we need to go ahead, and create our own 
custom type definitions. 

In addition, there will be times within your Angular application, wherein 
due to the requirements of your organization, you might need to create your 
own custom type definition. Whether it be new technology, or simply security
concerns. 

The following is the cookie cutter process for creating a custom type 
definition within Typescript in Angular. 

\section{Create a Custom Type Definition File}
A custom type definition file, is a file that Typescript will automatically 
pull out. By default adding the type definition \lstinline{*.d.ts} suffix to
the app, will cause Typescript to know to use this type definition.

It is also important to note that as of Typescript 2.* and greater, the
tsconfig.json has two properties available: 
\begin{enumerate}
  \item \lstinline{typeRoots}
  \item \lstinline{types}
\end{enumerate}

\subsection{Type Roots}
Specifies the folder in which the Typescript transpiler should look for type 
definitions. This simplifies the process of being able to install npm packages.
Any typescript definition, can be created as an npm package underneath \lstinline{@types}.

\subsection{types}
Now that we have specified our \lstinline{typeRoots}, installed our type, into 
the \lstinline{@types} folder, all we need to do is specify it in our 
tsconfig.json file which types we want to use. Specifically within an Nrwl Nx 
setting, and it's mono-repo approach, there is a separate tsconfig.json file 
for every lib. That is where we will specify the types that we would like to 
use. 

\section{Example Code as is in Nrwl Workspace}
In the root \lstinline{tsconfig.json} file, the Angular CLI/Nrwl Nx has automatically
specify the root \lstinline{typeRoots} config for use, which is \lstinline{node_modules/@types}.
If we wanted, we could create our own package, and specify another 
\lstinline{typeRoots} to be used within Typescript. 
\begin{lstlisting}[caption=tsconfig.json]
{
  "compileOnSave": false,
  "compilerOptions": {
    "typeRoots": ["node_modules/@types"],
    "types": [],
    ...
  }
  "exclude": ["node_modules", "tmp"]
}
\end{lstlisting}

and then inside of our tsconfig.json file, Nrwl Nx will automatically generate
for us the types that we will be using within our lib. 
\begin{lstlisting}[caption=libs/common/services/tsconfig.json]
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "types": ["node", "jest"]
  },
  "include": ["**/*.ts"]
} 
\end{lstlisting}

\section{Adding Our Own Custom Type NPM Package}
There are very few scenarios within Angular, wherein we would add our own 
custom types. I am of the opinion, that if you do find yourself having to 
add a custom type, let's make it available to everyone. I.e. let's open source 
our package, and make it something everyone can use. So let's run through the 
steps of creating our own NPM package. 

\subsection{Creating a Github Repo}
We have created a github repo entitled \lstinline{network-information-types}. 
We checked the box for initializing with a README, a .gitignore file for Node,
and a MIT license. We clone it locally by running: 
\begin{verbatim}
git clone git@github.com:razroo/network-information-types.git
\end{verbatim}

\subsection{Running npm init}
Next, we navigate to our newly cloned repo, and run: 
\begin{verbatim}
npm init -y
\end{verbatim}
The \lstinline{-y} tells the \lstinline{package.json} that we want to use all
default options. 
\begin{lstlisting}[caption=package.json]  
{
  "name": "project-name",
  "version": "0.0.1",
  "description": "Project Description",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "the repositories url"
  },
  "author": "your name",
  "license": "N/A"
}
\end{lstlisting}

\subsection{Install Typescript and modify tsconfig.json}
First, let's go and install Typescript as a dev dependency: 
\begin{verbatim}
npm i typescript -D  
\end{verbatim}

Next, let's create a \lstinline{tsconfig.json} file and make it look like this:
\begin{lstlisting}
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "declaration": true,
    "outDir": "./dist",
    "strict": true
  }
}  
\end{lstlisting}

\section{Adding a index.d.ts File}
When creating a custom type definition file, generally we will follow a four
step process:
\begin{enumerate}
  \item Create Private Types
  \item Create Private Interfaces
  \item Create Public Interface 
  \item Extend Public Interface, to be Used/Consumed by Typescript
\end{enumerate}

In our scenario, we are creating an interface around navigator. So: 
\begin{lstlisting}[caption=index.d.ts]
// W3C Spec Draft http://wicg.github.io/netinfo/
// Edition: Draft Community Group Report 20 February 2019

// http://wicg.github.io/netinfo/#navigatornetworkinformation-interface
declare interface Navigator extends NavigatorNetworkInformation {}
declare interface WorkerNavigator extends NavigatorNetworkInformation {}

// http://wicg.github.io/netinfo/#navigatornetworkinformation-interface
declare interface NavigatorNetworkInformation {
  readonly connection?: NetworkInformation;
}

// http://wicg.github.io/netinfo/#connection-types
type ConnectionType =
  | 'bluetooth'
  | 'cellular'
  | 'ethernet'
  | 'mixed'
  | 'none'
  | 'other'
  | 'unknown'
  | 'wifi'
  | 'wimax';

// http://wicg.github.io/netinfo/#effectiveconnectiontype-enum
type EffectiveConnectionType = '2g' | '3g' | '4g' | 'slow-2g';

// http://wicg.github.io/netinfo/#dom-megabit
type Megabit = number;
// http://wicg.github.io/netinfo/#dom-millisecond
type Millisecond = number;

// http://wicg.github.io/netinfo/#networkinformation-interface
interface NetworkInformation extends EventTarget {
  // http://wicg.github.io/netinfo/#type-attribute
  readonly type?: ConnectionType;
  // http://wicg.github.io/netinfo/#effectivetype-attribute
  readonly effectiveType?: EffectiveConnectionType;
  // http://wicg.github.io/netinfo/#downlinkmax-attribute
  readonly downlinkMax?: Megabit;
  // http://wicg.github.io/netinfo/#downlink-attribute
  readonly downlink?: Megabit;
  // http://wicg.github.io/netinfo/#rtt-attribute
  readonly rtt?: Millisecond;
  // http://wicg.github.io/netinfo/#savedata-attribute
  readonly saveData?: boolean;
  // http://wicg.github.io/netinfo/#handling-changes-to-the-underlying-connection
  onchange?: EventListener;
}  
\end{lstlisting}[index.d.ts]

\section{Creating our own NPM Package (Continued...)}
\subsection{Adding Ability to Build Typescript}

We are going to be using Pika/pack within our application. As of now, I have found 
it to be the easiest tool to use to build an npm library. In particular, it greatly 
eases out of the box the need for building a package.json file. 

We are going to tap into Typescript to build our application. Let's add a build 
script to our \lstinline{package.json} file.
\begin{verbatim}
"build": "tsc"
\end{verbatim}

Next, we are going to add some NPM scripts to our app, so that we can go ahead
and build/test our type definitions. 

More content needs to be written here: 

\section{Publishing Our NPM Package}
