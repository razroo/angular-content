\maketitle{}
\section{ Data Access Interface }
In the previous chapter we discussed having a data access folder to manage
the various parts of our data. One of the primary benefits of such an
architecture, is that it can be enforced that there is to be one interface. This
interace can be used for service, component, state, and respective files.

\subsection{ The Beauty of a Singular Data Access Interface }
By having a singular data access interface, we can ensure that the data is
being formatted in the same way across the service, component, and state. In
addition, and perhaps more valuable, it allows us to mock all of specs. By
having a singular interface used across the app, it forces the mocked
functioanlity to be in sync with our specs.

\subsection{ Singleton Interface - An Example }
Just for clarity sake, let's run through singleton interface.
\begin{lstlisting}
export interface User {
  id: string;
  name: string;
  location: string;
}

//user.service.ts file
getAllUsers(sort: object): Observable<AllBuyers> {
    const query = AllUsersQuery;
    const variables = {
      projectId: this.projectFacade.projectId,
      sort,
    };

    const allUserss$ = this.apollo
      .query<any>({ query, variables })
      .pipe(pluck('data'), pluck('allBuyers'));

    return combineLatest(allBuyers$, (allUsers: User[]) => allUsers);
  }

//user.reducer.ts
  case UserTypes.UserLoaded: {
      const user = <User>action.payload;

      return {
        ...state,
        user,
      };
    }

// user.effect.ts
@Effect()
loadUser$ = this.dataPersistence.fetch(UserTypes.LoadUser, {
  run: (action: LoadUser, state: UserStateModelState) => {
    const userId: string = action.payload;
    return this.service
      .getAllUsers(userId)
      .pipe(map((users: User[]) => new UserLoaded(user)));
  },

  onError: (action: LoadUser, error) => {
    console.error('Error', error);
  },
});

// user-page.component.ts
loadUser() {
  this.userSevice.allUsers();
}

// user-page.component.spec.ts
generateMockUsers(data): User[] {
  return {
    ...data
  }
}

mockUserService() {
  allUsers() {
    return users;
  }
}
\end{lstlisting}

We have gone through all the files which will touch data with type annotations
in the data access folder, for clarity sake. As we can see, having the same
interface for all of them will ensure we are using the same data. This is a no
brainer as it is what interfaces are, and what they do. However, there are two
things that we are doing that which isn't neccesarily considered as intuitive:
\begin{enumerate}
  \item We have one singular interface for the entire project
  \item We are making sure that we use the same interface for our specs.
\end{enumerate}

\subsubsection(Why this Seems so Flawless)
If you were to read the above you might think that this is something which is
obvious. However, only by grouping together all of our data-access elements
together in the same folder, and keeping with one interface is it obvious. In
many other repos, they will put them all in different folers, and maintain
different interfaces, causing the entire project to not be in sync. 
