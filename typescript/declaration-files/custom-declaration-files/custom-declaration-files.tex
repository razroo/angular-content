\chapter{ Custom Declaration Files }
Earlier we described what a declaration file is, and went through all the steps to fully understand what a declaration file is.

\section{Example Scenario}
For instance, in another chapter, we reccomend using the native Network 
Information API. Because it is experimental(at the time of this writing),
as is the case in all scenarios, the Typescript team has not included 
type definitions for it. So, we need to go ahead, and create our own 
custom type definitions. 

In addition, there will be times within your Angular application, wherein 
due to the requirements of your organization, you might need to create your 
own custom type definition. Whether it be new technology, or simply security
concerns. 

The following is the cookie cutter process for creating a custom type 
definition within Typescript in Angular. 

\section{Create a Custom Type Definition File}
A custom type definition file, is a file that Typescript will automatically 
pull out. By default adding the type definition \lstinline{*.d.ts} suffix to
the app, will cause Typescript to know to use this type definition.

It is also important to note that as of Typescript 2.* and greater, the
tsconfig.json has two properties available: 
\begin{enumerate}
  \item \lstinline{typeRoots}
  \item \lstinline{types}
\end{enumerate}

\subsection{Type Roots}
Specifies the folder in which the Typescript transpiler should look for type 
definitions. This simplifies the process of being able to install npm packages.
Any typescript definition, can be created as an npm package underneath \lstinline{@types}.

\subsection{types}
Now that we have specified our \lstinline{typeRoots}, installed our type, into 
the \lstinline{@types} folder, all we need to do is specify it in our 
tsconfig.json file which types we want to use. Specifically within an Nrwl Nx 
setting, and it's mono-repo approach, there is a separate tsconfig.json file 
for every lib. That is where we will specify the types that we would like to 
use. 

\section{Example Code as is in Nrwl Workspace}
In the root \lstinline{tsconfig.json} file, the Angular CLI/Nrwl Nx has automatically
specify the root \lstinline{typeRoots} config for use, which is \lstinline{node_modules/@types}.
If we wanted, we could create our own package, and specify another 
\lstinline{typeRoots} to be used within Typescript. 
\begin{lstlisting}[caption=tsconfig.json]
{
  "compileOnSave": false,
  "compilerOptions": {
    "typeRoots": ["node_modules/@types"],
    "types": [],
    ...
  }
  "exclude": ["node_modules", "tmp"]
}
\end{lstlisting}

and then inside of our tsconfig.json file, Nrwl Nx will automatically generate
for us the types that we will be using within our lib. 
\begin{lstlisting}[caption=libs/common/services/tsconfig.json]
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "types": ["node", "jest"]
  },
  "include": ["**/*.ts"]
} 
\end{lstlisting}

\section{Adding Our Own Custom Type NPM Package}
There are very few scenarios within Angular, wherein we would add our own 
custom types. I am of the opinion, that if you do find yourself having to 
add a custom type, let's make it available to everyone. I.e. let's open source 
our package, and make it something everyone can use. So let's run through the 
steps of creating our own NPM package. 

\subsection{Creating a Github Repo}
We have created a github repo entitled \lstinline{network-information-types}. 
We checked the box for initializing with a README, a .gitignore file for Node,
and a MIT license. We clone it locally by running: 
\begin{verbatim}
git clone git@github.com:razroo/network-information-types.git
\end{verbatim}

\subsection{Running npm init}
Next, we navigate to our newly cloned repo, and run: 
\begin{verbatim}
npm init -y
\end{verbatim}
The \lstinline{-y} tells the \lstinline{package.json} that we want to use all
default options. 
\begin{lstlisting}[caption=package.json]  
{
  "name": "project-name",
  "version": "0.0.1",
  "description": "Project Description",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "the repositories url"
  },
  "author": "your name",
  "license": "N/A"
}
\end{lstlisting}

\subsection{Install Typescript and modify tsconfig.json}
First, let's go and install Typescript as a dev dependency: 
\begin{verbatim}
npm i typescript -D  
\end{verbatim}

Next, let's create a \lstinline{tsconfig.json} file and make it look like this:
\begin{lstlisting}
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "declaration": true,
    "outDir": "./dist",
    "strict": true
  }
}  
\end{lstlisting}

\section{Adding a index.d.ts File}
When creating a custom type definition file, generally we will follow a four
step process:
\begin{enumerate}
  \item Create Private Types
  \item Create Private Interfaces
  \item Create Public Interface 
  \item Extend Public Interface, to be Used/Consumed by Typescript
\end{enumerate}

In our scenario, we are creating an interface around navigator. So: 
\begin{lstlisting}[caption=index.d.ts]
// W3C Spec Draft http://wicg.github.io/netinfo/
// Edition: Draft Community Group Report 20 February 2019

// http://wicg.github.io/netinfo/#navigatornetworkinformation-interface
declare interface Navigator extends NavigatorNetworkInformation {}
declare interface WorkerNavigator extends NavigatorNetworkInformation {}

// http://wicg.github.io/netinfo/#navigatornetworkinformation-interface
declare interface NavigatorNetworkInformation {
  readonly connection?: NetworkInformation;
}

// http://wicg.github.io/netinfo/#connection-types
type ConnectionType =
  | 'bluetooth'
  | 'cellular'
  | 'ethernet'
  | 'mixed'
  | 'none'
  | 'other'
  | 'unknown'
  | 'wifi'
  | 'wimax';

// http://wicg.github.io/netinfo/#effectiveconnectiontype-enum
type EffectiveConnectionType = '2g' | '3g' | '4g' | 'slow-2g';

// http://wicg.github.io/netinfo/#dom-megabit
type Megabit = number;
// http://wicg.github.io/netinfo/#dom-millisecond
type Millisecond = number;

// http://wicg.github.io/netinfo/#networkinformation-interface
interface NetworkInformation extends EventTarget {
  // http://wicg.github.io/netinfo/#type-attribute
  readonly type?: ConnectionType;
  // http://wicg.github.io/netinfo/#effectivetype-attribute
  readonly effectiveType?: EffectiveConnectionType;
  // http://wicg.github.io/netinfo/#downlinkmax-attribute
  readonly downlinkMax?: Megabit;
  // http://wicg.github.io/netinfo/#downlink-attribute
  readonly downlink?: Megabit;
  // http://wicg.github.io/netinfo/#rtt-attribute
  readonly rtt?: Millisecond;
  // http://wicg.github.io/netinfo/#savedata-attribute
  readonly saveData?: boolean;
  // http://wicg.github.io/netinfo/#handling-changes-to-the-underlying-connection
  onchange?: EventListener;
}  
\end{lstlisting}[index.d.ts]

\section{Creating our own NPM Package (Continued...)}
\subsection{Adding Ability to Build Typescript}

We are going to be using Pika/pack within our application. As of now, I have found 
it to be the easiest tool to use to build an npm library. In particular, it greatly 
eases out of the box the need for building a package.json file. 

We are going to tap into Typescript to build our application. Let's add a build 
script to our \lstinline{package.json} file.
\begin{verbatim}
"build": "tsc"
\end{verbatim}

Next, we are going to add some NPM scripts to our app, so that we can go ahead
and build/test our type definitions. 

More content needs to be written here: 

\section{Publishing Our NPM Package}
