\chapter{Declaration Files}
Declaration files have an integral part of the Angular/Typescript ecosystem. They happen to not make their way into the day to day of our applications because most major libraries have them bundled in already. In addition, there is a 5,000+ open source library that creates types for non-typed libraries. However, it is nonetheless integral to understanding how it works. Every application usually has a one off use case that makes it special. When that time arrives, knowing how a declaration file works is going to come in handy.

\section{Type Annotation}
First, there is what we quite frequently see within a Typescript application called a type annotation. That looks something like this: 
\begin{verbatim}
const userName: string;  
\end{verbatim}

In the above, we are using Typescript's internal framework, to inform that compiler, that the type of this constant is a string. 

\section{Typescript Interface}
Moving on, the next level would be an interface. A Typescript interface can be used to describe an entire object, such as the following user interface: 
\begin{lstlisting}[caption=Typescript User Interface]
export interface User {
  password: string;
  userName: string;
  email: string;
}
\end{lstlisting}

Now, in our application, if we plan on having user data, we can annotate that object with our interface. A common enterprise example of this: 
\begin{lstlisting}[caption=user.reducer.ts]
export interface UserState {
  list: User; // list of Users; analogous to a sql normalized table
  selectedId?: string | number; // which User record has been selected
  loaded: boolean; // has the User list been loaded
  error?: any; // last none error (if any)
}  
\end{lstlisting}

In the above interface for UserState, our list, which is where our reducer is going to place user data, has the type annotation for the \lstinline{User} interface.

\section{Modules in Typescript}
A module in Typescript is any file containing: 
\begin{enumerate}
  \item Values 
\begin{verbatim}
// e.g.  
export const person: Person;  
\end{verbatim}  
\item Functions
\begin{verbatim}
// e.g. 
export function square(n: number) {
  return n * n;
}
\end{verbatim}
\item Classes (e.g. export const person: Person;)
\begin{verbatim}
// e.g.
@Component({
  selector: 'razroo-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent {
  constructor() {}
}
\end{verbatim}
\end{enumerate}

A great example of using a module in Typescript is a classic \lstinline{import}. It's so commonplace that you've undoubtedly come across of it, and when you read this code example will say, "ooooh, that's a module, i know what that is" \lstinline{module}
\begin{lstlisting}
import { add } from "./math";
\end{lstlisting}

\^ the above would be a module in Typescript.

\section{Namespaces in Typescript}
Similarly, you most likely have come across a namespace in Typescript as well. It looks somthing like this:
\begin{lstlisting}
import * as math from "./math";
\end{lstlisting}
A namespace in Typescript is a way to group features(e.g. interfaces, functions etc.) and objects that share common relationships. So in the above, if we access now anything within the math file, all we would have to do is:
\begin{verbatim}
this.math.add(2, 3);
// 5  
\end{verbatim}

A great way to better understand namespaces, is to think of it as an internal module system. In this way, interfaces, classes, functions, and variables are all included into the internal Typescript compiler. (we will get to how we can create a global namespace later).

\section{Global in Typescript - The Last Piece}
There is just one last missing foundational piece in order to understand what and how a type definition is created. In Typescript, there is the ability to 
create global variables, functions, and namespaces. For instance, if we want to create a variable called \lstinline{car} and have it available across our entire app, we can use something really cool called \lstinline{declare}: 

\begin{verbatim}
declare let razrooAssetsBaseURL = 'assets/logo';  
\end{verbatim}

Now that we have this global variable within our app, we can use it anwhere we want. 
\begin{lstlisting}[caption=useless.component.ts]
console.log('razrooAssetsBaseURL');
console.log(razrooAssetsBaseURL);
\end{lstlisting}

We can also create a global namespace, without the need of using a import/export. We would do this by writing: 
\begin{verbatim}
declare namespace razrooLib {
  function makeGreeting(s: string): string;
  let numberOfGreetings: number;
}
\end{verbatim}

\section{What is a Declaration File?}
Defined concisely: 
\begin{quote}
\say{A declaration file in Typescript is simply a way of transferring over a Javascript library to Typescript}
\end{quote}

There is a bit to unpack in this definition, as it's not immediately apparent why a Javascript library would need to be converted over to Typescript? 

\subsection{Fantastic Moment.js Example }
The Moment.js library, is an extremely popular library used for dates. For me personally, in the past 10 years working on applications, it is the only library to consistenly be used in every application. The actualy library is written in Javscript. However, in order for the Typescript compiler to understand the function, and to make sure the application you are working on is type safe, the moment core contributers have created their own typescript definition files \footnote{github.com/moment/moment/blob/0aae7249928ae0dacad94de30d68434cabc03844/moment.d.ts}.  

One of the most commonly use \lstinline{Moment} functions is format.
\begin{lstlisting}[caption=moment.d.ts]
declare namespace moment {
  //..
  interface Moment extends Object {
    format(format?: string): string;
    //..
  }
  //..
}
\end{lstlisting}

There are three things that have been done here, in order for this type to take hold:
\begin{enumerate}
\item We created a global namespace called moment. Whenever Typescript feeds into the Javascript moment library, it immediately taps into the types for \lstinline{Moment}
\item We create a type annotation all of our methods. Here we are showing one of the more commonly used one's format. Wherein the library specifies that it can optionally take in string parameter, and returns a string.
\item The actual file has the suffix \lstinline{.d.ts}. When a file has a suffix of \lstinline{.d.ts}, the Typescript compiler will not immediately know of it's existence. Instead of reference file similar to: 
\begin{verbatim} 
///<reference path="path/to/file.d.ts" />
\end{verbatim} 
Will have to be created, so typescript knows it exists. The current practice is to place all reference paths in an \lstinline{index.d.ts} file, and then feed that one \lstinline{index.d.ts} file into your application.
\end{enumerate}