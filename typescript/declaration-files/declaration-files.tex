\chapter{Declaration Files}
Declaration files have an integral part of the Angular/Typescript ecosystem. However, if you haven't worked with declaration files, it's because most major libraries have them bundled with library already. In addition, there are 5,000+ typings created by the open source library DefinitelyTyped. Nonetheless, granted this is the reality of present day Angular development, it is nonetheless integral to understand how it works. Every application usually has a one-off use case that makes it special. When that time arrives, knowing how a declaration file works is going to come in handy. Most likely because you will need to create one yourself.

Declaration files, however, happen to be very involved. They need understanding of numerous prior Typescript concepts. Let's go through that now, as efficiently we can.

\section{Type Annotation}
First, there is what we quite frequently see within a Typescript application called a type annotation. That looks something like this: 

\begin{verbatim}
const userName: string;  
\end{verbatim}

In the above, we are inform the Typescript compiler, that the type of this constant is a string. This is for a single value. Let's move onto the next step in the ladder, type annotating an object.

\section{Typescript Interface}
A Typescript interface can be used to describe an entire object, such as the following \lstinline{User} interface: 
\begin{lstlisting}[caption=Typescript User Interface]
export interface User {
  password: string;
  userName: string;
  email: string;
}
\end{lstlisting}

Now, in our application, if we plan on having user data, we can (type) annotate that object with our interface. A common enterprise example of this: 
\begin{lstlisting}[caption=user.reducer.ts]
import { User } from '@razroo/data-models/user';

export interface UserState {
  list: User; // list of Users; analogous to a sql normalized table
  selectedId?: string | number; // which User record has been selected
  loaded: boolean; // has the User list been loaded
  error?: any; // last none error (if any)
}  
\end{lstlisting}

In the above \lstinline{UserState} interface, our \lstinline{list}, which is where our reducer is going to place \lstinline{user} data, has the type annotation for the \lstinline{User} interface.

\subsection{The Multiple Interface Dilemma}
Ok, great, so now we know that we can create an interface, and use that to type annotate our object. However, what if wanted to use 10, or so interfaces from the \lstinline{user.models.ts} file(the file where our user interfaces are located), is there are a more efficient way to import them all at once, instead of doing something like this:? 

\begin{lstlisting}[caption=user.reducer.ts]
import { User, UserTable, UserSettings, UserForm, UserProject, UserCorporate, UserConsumer } from '@razroo/data-models/user';

// let's pretend that all imports are being used in this file, for the sake of
// brevity.. 
export interface UserState {
  list: User; // list of Users; analogous to a sql normalized table
  //..
}  
//..
\end{lstlisting}

Typescript's answer to this came in form of the next two core concepts we shall discuss:
\begin{enumerate}
  \item Modules
  \item Namespaces
\end{enumerate}

\section{Modules in Typescript}

\subsection{What is a Module}
A module in Typescript is any file containing: 
\begin{enumerate}
  \item Values 
\begin{verbatim}
// e.g.  
export const person: Person;  
\end{verbatim}  
\item Functions
\begin{verbatim}
// e.g. 
export function square(n: number) {
  return n * n;
}
\end{verbatim}
\item Classes
\begin{verbatim}
// e.g.
@Component({
  selector: 'razroo-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent {
  constructor() {}
}
\end{verbatim}
\end{enumerate}

\subsection{Example of Module in Typescript}
A great example of using a module in Typescript is the classic \lstinline{import}. It's so commonplace that you've undoubtedly come across it, and when you read this code example (probably) will say, "Ooooh, that's a module, I know what that is!".
\begin{lstlisting}
import { add } from "./math";
\end{lstlisting}

\^ the math file is a module in Typescript.

\section{Namespaces in Typescript}
You most likely have come across a namespace in Typescript as well. A local namespace looks something like this:

\begin{lstlisting}
import * as math from "./math";
\end{lstlisting}

wherein math is the namespace for the \lstinline{math} module. Now that we have our namespace, we can tap into any method within the namespace, using classic dot notation:

\begin{verbatim}  
math.add(2, 3);
// 5  
\end{verbatim}

A namespace put simply, is a way of grouping all Typescript interfaces, classes,  functions, and variables under one single name. Similar to what we did above \^ for the \lstinline{math} namespace. The benefits of this are two-fold: 
\begin{enumerate}
  \item Simplify process of import.
  \item Create a respective Typescript interface overlay \textrightarrow{} for a non-Typescript Javascript library(something we will get to momentarily). 
\end{enumerate}

\section{Global in Typescript - The Last Piece}
There is just one last missing foundational piece in order to understanding a declaration file is.Â 

In Typescript, there is the ability to create global variables, functions, and namespaces. For instance, if we want to create a variable called \lstinline{razrooAssetsBaseURL}and have it be available across our entire app, we can use something really cool called \lstinline{declare}:

\begin{verbatim}
declare let razrooAssetsBaseURL = 'assets/logo';  
\end{verbatim}

Now that we have this global variable within our app, we can use it anywhere we want.

\begin{lstlisting}[caption=useless.component.ts]
console.log('razrooAssetsBaseURL');
console.log(razrooAssetsBaseURL);
\end{lstlisting}

\subsection{Creating a Global Namespace}
We can also create a global namespace, without the need of using an import/export. We would do this by coding:

\begin{verbatim}
declare namespace razrooLib {
  function makeGreeting(s: string): string;
  let numberOfGreetings: number;
}
\end{verbatim}

Now we are all set to finally jump into what a declaration file is.

\section{What is a Declaration File?}
Defined concisely: 
\begin{quote}
\say{A declaration file in Typescript is simply a way of transferring over a Javascript library to Typescript}
\end{quote}

There is a bit to unpack in this definition, as it's not immediately apparent why a Javascript library would need to be converted over to Typescript? In addition, how exactly would a declaration file covert a Javascript library to Typescript?

\subsection{ Fantastic Moment.js Example }
The \lstinline{Moment.js} library, is an extremely popular library used for dates. (For me personally, in the past 10 years working on applications, it is the only library to consistently be used in every application.) The actual library is written in Javascript. However, in order for the Typescript compiler to understand the Moment library, it is necessary to create a declaration file.

Lucky for us, the Moment.js core contributors have created their own typescript definition files. These definition files are bundled with the moment npm package. Lets look at the moment definition file:

\begin{lstlisting}[caption=moment.d.ts currently at the time of writing 736 lines long chockfull with interfaces for the Moment library]
declare namespace moment {
  //..
  interface Moment extends Object {
    format(format?: string): string;

    startOf(unitOfTime: unitOfTime.StartOf): Moment;
    endOf(unitOfTime: unitOfTime.StartOf): Moment;
    //..
  }
  //..
}
\end{lstlisting}
\footnote{github.com/moment/moment/blob/0aae7249928ae0dacad94de30d68434cabc03844/moment.d.ts}.  

There are three things that have been done here, in order for this type to take hold:
\begin{enumerate}
\item We created a global namespace called moment. Whenever Typescript feeds into the Javascript moment library, it immediately taps into the types for \lstinline{Moment}
\item We create a type annotation all of our methods. Here we are showing one of the more commonly used one's format. Wherein the library specifies that it can optionally take in string parameter, and returns a string.
\item The actual file has the suffix \lstinline{.d.ts}. When a file has a suffix of \lstinline{.d.ts}, the Typescript compiler will not immediately know of it's existence. Instead of reference file similar to: 
\begin{verbatim} 
///<reference path="path/to/file.d.ts" />
\end{verbatim} 
Will have to be created, so typescript knows it exists. The current practice is to place all reference paths in an \lstinline{index.d.ts} file, and then feed that one \lstinline{index.d.ts} file into your application.
\end{enumerate}