
\chapter{ Typescript - Getting and Setting  }
Creating a getter and setter is a common occurance in OOP paradigm. When using
a class, Typescript offers an internal getter and setter. It is important to
note that within the Typescript documenation, a large part of the reason why
they create setters and getters, is to give a way of intercepting the setting
of a particular element. \footnote{typescriptlang.org\/docs\/handbook\/classes\.html}
For instance, let's say that you want to give people the ability for it to
error out if it doesn't actually contain one, or two strings. Doing something
like that with a setter is great.

\section{ Typescript - Why create a getter and setter? }
Another important point, is the syntactic sugar for two reasons.
\begin{enumerate}
  \item Getting and setting is a integral part of OOP programming. Before redux
  came around, it was literally a part of every component without a doubt.
  Having a functiin pegged with a get, or set directly before the function, helps
  specify the intent of the getter, or setter.
  \item While yes it is true, that one would be able to specifiy a function that
  will act as a setter or getter, it is syntactically, a bit awkward within an
  OOP setting. If I may:
  \begin{verbatim}
    getDinerText()
  \end{verbatim}

  \begin{verbatim}
    Diner.text
  \end{verbatim}
\end{enumerate}

So yes, can you set and get, without using the internal setter and getter that
Typescript has to offer like everything else, yes. However, the syntactic sugar
will make it seem like you are natively setting and getting. In addition,
putting emphasis on whenever an item is getted, or setted.

\section{ Valuable getting and setting within an ngrx/store setting }
So the question then becomes, if you are using ngrx/store within your app, for
what reason would you hvae value for getting and setting. For the most part, the
values that you have will either be set through @Input's within Angular, or
accessed through your @ngrx/store. There is one in particular very valuable
reason. That would be if within your Typescript component you have deep nested
data. Having a getter and setter within a component would be very useful. For
instance:
\begin{lstlisting}
get numberOfDocuments(): number {
  try {
    return this.userLog.user.documents.length;
  } catch (e) {
    return 0;
  }
}
\end{lstlisting}
Now we have a getter with logic, that says that if it doesn't exist, then it
will return something 0. We can then do something like the following:
\begin{verbatim}
<span> Number of Documents: {{ numberOfDocuments }} </span>
\end{verbatim}
in your html.
