\maketitle{}
\section{ Component Inheritance }

Anyone who has worked with Javascript before frameworks became popular, is well
versed with prototypes in javascript. Arguably the most complicated part of the
language. In short, it allowed for objects(containing whatever you can think of)
, to be inherited by other prototypes. Thereby, allowing one to use classes in
Javascript without explicitly using classes.

When it comes to inheritance, JavaScript only has one construct: objects.
Each object has an internal link to another object called its prototype. That
prototype object has a prototype of its own, and so on until an object is
reached with null as its prototype. null, by definition, has no prototype, and
acts as the final link in this prototype chain.

\subsection{ Extending Classes }
In Typescript land, we have the ability to use a class to extend a parent class.
A classic example of this is let's say we have the following parent component:

\lstinputlisting{./typescript/component-inheritance/base.component.ts}

If we were to try and inherit it, using the following child component:

\lstinputlisting{./typescript/component-inheritance/child.component.ts}

We would unfortunately have to pass all parent providers into the child
component to extend it.

\subsection{ Creating a Class to Store Injector }
What we can do, is create a class to store our store injector. For instance:
\lstinputlisting{./typescript/component-inheritance/app-injector.service.ts}

We are then able to inject this into the AppInjector:
\lstinputlisting{./typescript/component-inheritance/main.ts}

\subsection{ New and Improved Base Component }
Our base component now uses the injector service in order to retrieve all
dependencies. \marginpar{Something that I think we need to do better in this
chapter, is go through how dependency injection works. It was a bit unclear
in this instance}

\lstinputlisting{./typescript/component-inheritance/updated-base.component.ts}
