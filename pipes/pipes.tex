\section{ Pipes }


Angular offers the ability to use something called a pipe out of the box. The
idea behind a pipe is to get data, transform it, and show new transformed data
to users. It is a very common task, and Angular, rightfully so, decided to
include it in it's framework. The easiest way to think about it, is a way
to put a function in your html template!

A pipe might look something like this:

\begin{lstlisting}
import { Component } from '@angular/core';

@Component({
  selector: 'app-data-table',
  templateUrl: './data-table.component.html',
  styleUrls: [./data-table.component.scss],
})
export class HeroBirthdayComponent {
  transaction = new Date(1988, 3, 15); // April 15, 1988
}
\end{lstlisting}

begin{lstlisting}
<!--data-table.html-->
<Div>Data of transaction {{ transaction | date }}</p>
end{lstlisting}

The above would display:
\begin{verbatim}
April 15, 1988
\end{verbatim}

The pipe in this instance, will transform transaction, from a Date object, and
transform it to a readable date.

\subsection{ The Uniqueness of Pipe }
The unique part about an Angular pipe, is that it is something that will be
defined as a function, but actually be in your html. Any classic way of
thinking of a function can similarly be applied to a pipe.

\subsection{Chaining Pipes}
If you want, you can chain multiple pipes together, similar to function
composition, to allow for multiple effects on your html.

\begin{lstlisting}
The chained transaction date is:
{{ transaction | date | uppercase}}
\end{lstlisting}

Would display
\begin{verbatim}
APRIL 15, 1988
\end{verbatim}

Chaining pipes, walla!

\subsection{Parameters for Pipes}
Pipes also take parameters, similar to how functions take parameters. For
instance, if we want to add a parameter to the default Angular pipe. For
instance, let's say that we wanted to show the day of the week, in addition to
actual week we can provide the pipe the following param:

\begin{lstlisting}
The chained + formatted transaction date is:
{{ transaction | date: "full" | uppercase}}
\end{lstlisting}

Having such dates in one's application obviously makes it very easy to go ahead
and transform data throughout one's app. Here we are also chaining pipes, so
that the transformed data that comes back in addition to being transformed, is
also capitalized.

\subsection{ Dis-section of Angular Built in Pipes }
I think it's important to show that Angular actually has a relatively limited
amount of built in pipes:
\begin{center}
\begin{tabular}{ c c c }
 AsyncPipe & CurrencyPipe & DatePipe \\
 DecimalPipe & i18nPluralPipe & i18nSelectPipe \\
 JsonPipe & KeyValuePipe & LowerCasePipe \\
 PercentPipe & SlicePipe & TitleCasePipe \\
 UpperCasePipe
\end{tabular}
\end{center}

The reason behind it, is that truly the beauty behind pipes, is that you have
the ability to create your own. The community, for instance, has created a vast
amount of pipes beyond that of the built in one's Angular has created.

\subsubsection{ Understanding Angular's Change Detection }
This is a good time to interject and get into the nitty gritty of angular's
change detection. As we discussed in the earlier chapter on change-detection,
change detection in Angular works from the top down. That is, if a specific set
of data changes within a component, then the entire component will update as a
result of new data. Angular pipes, however, change how that it is done, by
changing content directly on the object, and only updating that one specific
part. By using pipes, it allows one's component to be more performant.

\subsection{ When to Use Pipes }
Pipes cover alot of ground. Within our architecture, one of the pipes that will
be used more so that others is the async pipe. However, now is not the place
to put that here. What is important, is that pipes can be used transform data.
Should they always be used whenever one is transforming data? Personally,
I like to think of pipes as unique to html. They have a way of dealing of
performance when working with html templates. However, within a component
itself it is questionable. To be honest this can go either way. However, from a
maintainability perspective, whenever data is being transformed within html it
should be a pipe. If it is data being transformed within the component, it
should be done through a service.

\mybox{
There is the ability to create an impure pipes that one can potentially do. This
usually has little to do with transforming data. The async pipe, for instance,
is something that would be considered an impure pipe, that has less to do with
transforming data, and more so with making the data available. However, I have
not seen the need to create an impure pipe with the architecture given.
}
