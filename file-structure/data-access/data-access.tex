\maketitle{}
\section{ Data Access }
When working within a GraphQL app, having a manageable way of accessing data
is important.

\subsection{ Data Access Folder/File Structure}
\begin{verbatim}
buyers
  state
    src
      lib
        data-access
          buyer.interface.ts
          buyers.service.spec.ts
          buyers.service.ts
          buyers.fragments.ts
          buyers.mutations.ts
          buyers.queries.ts
        +state
          buyers.actions.ts
          buyers.effects.spec.ts
          buyers.effects.ts
          buyers.facade.spec.ts
          buyers.facade.ts
          buyers.reducer.spec.ts
          buyers.reducer.ts
          buyers.selectors.spec.ts
          buyers.selectors.ts
        buyers-state.module.ts
    index.ts
\end{verbatim}
\subsection{ Data Access Deep Dive}
There are really four parts in one with regards to this folder/file structure.
They are
\begin{enumerate}
  \item GraphQL
  \item Models
  \item Service/Facade
  \item State
\end{enumerate}

\subsection{ The Data Access Life-Cycle}
First, one is to specify fragments and queries for the GraphQL request. At this
time, one is to specify the the interface, which is a UI carbon copy of the
fragment. Next, one is to create a service that will be used for the GraphQL
request. It will supply the proper params for the GraphQL request. Then depending
on the type of compoennt that the data will be used for. Creating an effect
that will be used in conjuction with the facade for providing data, that can be
used across the app is appropriate.

This is a cookie cutter process with regards to loading data, that allows for
repeating the process time and time across the app.
