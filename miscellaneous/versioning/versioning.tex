\chapter{ Versioning }

\textit{A thank you, to a one Chris Bautista and Bobbie Barker for helping me formulate this strategy. In addition, thank you to a highly respected colleague Allan Goncalves. May you all be in good health.}
\section { Git }
It goes without saying that you should be using Git for version control. Just to re-iterate the benefits of \href{https://git-scm.com/}{Git}, are as follows: 
\begin{enumerate} 
  \item Islolated Environments - I.e. every developer on your team works on the code base without affected others. 
  \item Pull Requests - Allows other developers to approve your code before officially being merged in. 
  \item Faster Release Cycle - Stability, distribution, pull requests, and community is streamlined. 
\end{enumerate} 

Git should play as a foundational piece in your application. In addition, such a thing as Git architecture exists, especially within the context of an Angular application. Let's dive into that now. 

\section { Integration with JIRA }
In any JIRA ticket, if one has the proper webhooks setup with Github, or if one
is using BitBucket, then it will automatically hook up the commit into the
ticket as a comment. All that is neccesary, is for the the commit message to include the ticket name. Will into this at another time. While this might not seem like architecture, in the sense of coding, this is actually the point of Git. Allow an immediate hook from your agile workflow into your versin control, by using the concept of feature branches. So first and foremost, make sure you have this integration set up. 

\section { Branching Name Convention }
Understanding the different types of branches is equally just as important. In addition, what a branch name can accomplish. More specifically a Git branch can:

\begin{enumerate}
  \item Inform the developer about the type of branch. These are:
    \begin{enumerate}
      \item feature
      \item hotfix
      \item bugfix
      \item refactor
      \item cleanup
      \item e2e
    \end{enumerate}
  \item Inform the developer of ticket being worked on.
  \item Inform the developer of abstract of ticket.
\end{enumerate}

Let's imagine our project is called \say{Pixe}. We have a ticket called PIXE-113, which is responsible for adding a pixel color picker to our Pixel Illustrator app. We would create our branch as following:

\begin{verbatim}
  feature/PIXE-113-details-and-actions
\end{verbatim}

\begin{enumerate}
  \item \say{feature} is issue type, all lowercase, followed by forward slash.
  \item \say{PIXE-113} is the name of ticket in all caps, followed by a dash
  \item details-and-actions is abstract of ticket.
\end{enumerate}

Now, anyone looking through the current branch, can immediately find out the intent of the branch. It's a relatively low levle way of 

\section { Git Client }
When it comes to using an IDE, I strongly believe that every team member should
have the freedom to use whatever they want. It is very important, in general,
that all team members feel free to use whatever they want. In this same vein
they should feel comfortable in using a client if they would like. However, I personally prefer using the terminal. With regards to Git, I truly do feel it is what will ultimately let you work most efficiently.

\section { Fork and Pull Workflow }
There are numerous different Git workflows, however, the one I think is ideal, is a Fork and Pull Workflow. Your workflow will evolve on time, but this core will not change, and therefore I can confidently suggest it within this book. The workflow I am going to suggest is the fork and pull workflow. I am going to lightly describe what it is, it's benefits, and then delve more specifically into what it is.

\subsection{What is a Fork and Pull Workflow}
A traditional git workflow, is that each developer shares the same repository, it's just that they have different branches. In a fork and pull workflow, developers in addition to having their own branch, also have their own repository.

\subsection{Benefits of a Fork and Pull Workflow}
\begin{enumerate}
  \item Allows for a single maintainer to accept commits from any developer without giving them write access to the official codebase. 
  \item No need to clean up git branches, as it is on each user's local repository.
  \item Promotes developers to contribute to open source, being that this pattern is the defacto for open source projects. 
  \item A hidden one that I found myself doing, is doing side projects without worrying about it cluttering the main app.
  \item If using a Mono Repo architecture, a fork and pull workflow is absolutely neccesary. At Razroo, we think a Mono Repo architecture is ideal, and have seen first hand, how it alleviates many things. 
\end{enumerate}

At Razroo, we use a Fork and Pull workflow, even when using private repositories. It allows for a cleaner workflow, and works better especially within a mono repo setting. Something we aspire to one day. 

\subsection { Setting up a Fork and Pull Workflow with Github }
With Github, setting up a Fork and Pull workflow is as simple as: 
\begin{enumerate}
  \item Clicking on the fork button.
  \item Clone your forked repo.
  \item Sync repo with upstream 
\begin{verbatim}
git remote add upstream {forked from repo goes here}
\end{verbatim}
Now whenever you would like to pull from upstream dev branch can simply do: 
\begin{verbatim}
git pull upstream dev   
\end{verbatim}
  \item push to your branch as usual
  \item Pull branch from forked repo, while in original repo 
\end{enumerate}

\section{Trunk Based Development}
\textit{There are many version control strategies within Git. For this one, I've actually spoken in person to a number of highly respected software enginers. Trunk based development is what we all agreed on, is the ideal approach, granted you have an automated QA environment.}

\subsection{What is Trunk Based Development?}
Trunk based development is that as opposed to the alternative of multiple branches for a repository, everyone commits to a core master branch. 

\section { Squash and Merge }
Github, is our preferred client. However, git itself, as well as all other major 3rd party vendors, give the option to squash all other commits before merged. Some will offer the option to re-base as well. (If you are in a very Fortune 50 setting, and are working within a company wide Mono Repo, most likely you will want to re-base.) However, our reccomended aproach is to squash and merge, so you can maintain the integrity of the commits that happened along the way. 

\section{Ending Off}
So there you go, the next time your team is wondering about what standards they should follow for Git, show them this. In the next chapter, we are going to dicusss, a proper Git workflow. I.e. master, dev, and test. We will get to that soon. 