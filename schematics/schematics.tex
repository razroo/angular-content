\maketitle{}
\section{ Setting up Schematics Using Angular CLI }

In any project, one is ineviatbley going to have their architecture. It would
be extremely beneficial for one to create their own schematics. Primarily so,
that with a singular command line input, one would be able to generate all of
the files they need.

\subsection{ Setting up Schematic }

Schematics can be used to easily introduce and enforce project wide conventions.
This will easily ramp up time for new developers, as well as diminish time
spent on project for current developers.

\subsection{ Download Schematics Globally }
\begin{lstlisting}
  npm install -g @angular-devkit/schematics-cli
\end{lstlisting}

\subsection{ Create a file-directory Schematics }
\begin{lstlisting}
  schematics blank --name=my-component
\end{lstlisting}

\subsection{ Understanding Rules and Trees }
A Tree is a data structure that contains a base \footnote{A set of files that already exists}
and a staging area \footnote{A list of changes to be applied to the base}.

A Rule is a function that takes a Tree and returns another Tree. A RuleFactory
are functions that create a Rule.

The blank RuleFactory that we have so far:

\begin{lstlisting}
import { Rule, SchematicContext, Tree } from '@angular-devkit/schematics';


// You don't have to export the function as default. You can also have more than one rule factory
// per file.
export function nwrlDirectory(options: any): Rule {
  return (tree: Tree, _context: SchematicContext) => {
    return tree;
  };
}
\end{lstlisting}

\mybox{
The options argument is an object that can be seen as the input of the factory.
From the CLI, it is the command line arguments the user passed. From another
schematic, itâ€™s the options that were passed in by that schematic.
}

\subsubsection{ Tree Deepdive}
There are four methods that directly create a change in a Tree:
\begin{enumerate}
  \item create
  \item delete
  \item rename
  \item overwrite
\end{enumerate}
