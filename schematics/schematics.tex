\maketitle{}
\section{ Setting up Schematics Using Angular CLI }

In any project, one is ineviatbley going to have their architecture. It would
be extremely beneficial for one to create their own schematics. Primarily so,
that with a singular command line input, one would be able to generate all of
the files they need.

Schematics can be used to easily introduce and enforce project wide conventions.
This will easily ramp up time for new developers, as well as diminish time
spent on project for current developers.

\subsection{ Download Schematics Globally }
\begin{lstlisting}
  npm install -g @angular-devkit/schematics-cli
\end{lstlisting}

\subsection{ Create a file-directory Schematics }
While the application we are building specifically for this book is a pixel
illustrator, in practice the conventions we set up for this app, will be used
across the app. In a previous chapter we mentioned we mentioned the following
folder/file structure:
\\
\\
\begin{forest}
  [libs
    [common
      [animations
      ]
      [assets
      ]
      [core
       [auth]
       [guards]
       [pipes]
       [validators]
      ]
      [models
      ]
      [testing
      ]
      [ui
      ]
      [utils
      ]
      [styles
      ]
      [vendor
      ]
    ]
  ]
\end{forest}

If we do not enforce this using schematics, it can very difficult for other
teams to follow this folder structure. In addition, it will take quite a bit of
time to solve at high level.


\begin{lstlisting}
  schematics blank --name=px-schematics
\end{lstlisting}

\subsection{ Understanding Rules and Trees }
A Tree is a data structure that contains a base \footnote{A set of files that already exists}
and a staging area \footnote{A list of changes to be applied to the base}.

A Rule is a function that takes a Tree and returns another Tree. A RuleFactory
are functions that create a Rule.

The blank RuleFactory that we have so far:

\begin{lstlisting}
  import { Rule, SchematicContext, Tree } from '@angular-devkit/schematics';

  // You don't have to export the function as default. You can also have more
  // than one rule factory per file.

  export function pxSchematics(options: any): Rule {
    return (tree: Tree, _context: SchematicContext) => {
      tree.create(options.name || 'hello', 'world');
      return tree;
    };
  }

\end{lstlisting}

\mybox{
The options argument is an object that can be seen as the input of the factory.
From the CLI, it is the command line arguments the user passed. From another
schematic, itâ€™s the options that were passed in by that schematic.
}

\subsubsection{ Tree Deepdive}
There are four methods that directly create a change in a Tree:
\begin{enumerate}
  \item create
  \item delete
  \item rename
  \item overwrite
\end{enumerate}

Similar to how we used create as an example above, to create a file, we also
have the option to use the schematic to delete, rename, or overwrite a file.

\subsubsection{ Generating a Folder using Schematics }
We are able to create a series of folders using schematics. However, it is
important to keep in mind two things. In any git setting a folder is only
committed if it contains a file. In addition, within the Angular schematics
it follows the same general guideline. Wherein, by choosing a file to be in a
particular file path. If no folder currently exists that is name as such, it
will be created nonetheless.
