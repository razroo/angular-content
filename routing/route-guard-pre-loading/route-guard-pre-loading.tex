\maketitle{}
\section{ Pre-loading with Route Guards }

In Angular, a RouteGuard is an interface that can be implemented to determine if
a given route request should be fulfilled or not. The core purpose of a
RouteGuard is, as the name implies, to protect a route by applying
authorization to it. However, we can use a Route Guard for another purpose:
pre-loading data for a view.

\subsection{ Motiviation }
The reason for doing this is to change where in the request process the loading
of data happens. Instead of determining the route, rendering view,
and then loading data, we find the route, load the data we need, and then render
the view with the data already in hand. (Question as to why we want to do this
though?)

For clarity sake, we would change the order from A to B.

We want to change the data loading order from Figrue 1, to Figure 2.

\subsection{ How It Works }
In addition to providing hooks for determining authorization, RouteGuards
provide a means for pre-fetching and caching data in the store. This is an
effect of the place that Route Guards occupy in the processing of requests.
Here's a look at a very simple Route Guard:

The canActivate() method is called by Angular to determine if the route in
question is allowed, based on the boolean return value. If we were really using
it for authorization, we could call out to a AuthService to check a token or
similar.

This simple version always allows the route to be activated.

\begin{lstlisting}
// Listing 1
import { Injectable } from '@angular/core';
import { Router, CanActivate } from '@angular/router';

@Injectable()
export class StoreLoadingGuardService implements CanActivate {
  constructor(public auth: AuthService, public router: Router) {}

  canActivate(): boolean {
    return true;
  }

}
\end{lstlisting}

If we were concerned with authorization here, the .canActivate() method would
reach out to an authentication service to make it's determination. For our
purposes, though, let's use this code in Listing 1 to see how to plug the Route
Guard into our app architecture.

\begin{lstlisting}
  // Listing 2
import { Routes, CanActivate } from '@angular/router';
import { ExampleComponent } from './example/example.component';
import {
  StoreLoadingGuardService as LoadingGuard
} from './auth/loading-guard.service';

export const ROUTES: Routes = [
  //...
  {
    path: 'example',
    component: ExampleComponent,
    canActivate: [LoadingGuard]
  }
  //...
];

\end{lstlisting}

What Listing 2 says, is: when the route example is called, invoke the
LoadingGuard.canActivate() method we defined before. Right now, all that will
do is allow the route with a default return value of true. However, we can do
something more interesting by pre-loading our store.

\subsection{ The Action }
Pre-loading data depends on the store being a central and persistent object that
holds application state. When modifying this state, we use ngrx Actions, a la
Redux.  Below in Listing 3 is a simple Action for loading data. This simple
action allows for a load action and a load success action for a Song data type.
(Yes, that is correct, we are pre-tending that we are building a music
application, right now.)

\begin{lstlisting}
export const LOAD_ALL = '[Song] Load All';
export const LOAD_ALL_SUCCESS = '[Song] Load All Success';

export class LoadAllAction implements Action {
  readonly type = LOAD_ALL;
  constructor(public payload?: any) { }
}
export class LoadAllSuccessAction implements Action {
  readonly type = LOAD_ALL_SUCCESS;
  constructor(public payload: string[]) { }
}
\end{lstlisting}

\subsection{The Store}
Our central state might look like the following:

\begin{lstlisting}
  export interface State {
  songs: string[];
}

export const initialState: State = {
  songs: [];
};

export function reducer(state = initialState, action: song.Actions) {
  switch (action.type) {
    case song.LOAD_ALL_SUCCESS: {
      return Object.assign({}, state, {
        songs: action.payload
      });
    }

    // ...
  }
}
\end{lstlisting}

This reducer simply applies the loaded songs to the state upon a successful
load.  We will rely on this reducer to merge the data returned by the action
into the state.

\subsection{The Effect}
In the ngrx/store style pattern, we use Effects to handle async calls:

\begin{lstlisting}
@Effect()
loadAll$: Observable = this.actions$
.ofType(song.LOAD_ALL)
.switchMap(() => {
  return this.service.getAll()
  .map(songs => new song.LoadAllAction(songs))
  .catch(() => of(new song.LoadAllFailAction()));
});
\end{lstlisting}
