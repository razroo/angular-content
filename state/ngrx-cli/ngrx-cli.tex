
\section{ Ngrx CLI }

Of one of the better reccomendations I can give with regards to using Angular
within you app, is using the Nrwl Nx cli. If you are using Nrwl Nx already,
which you should, and have a mono repo setup within your organization, then
it should be readily available. If you haven't already, please refer to the
chapter on Nrwl Nx setting it up.

\subsection{ Why Use a CLI? }
One of the benefits of using a CLI, is that it subtly enforces the entire
team to use a particular convention. With the Nx CLI for ngrx, this is doubly
true, as it strongly enforces conventions to be used as to how ngrx works. In
addition, within the ngrx arena, it strongly enforces how certain files should
be built.

\subsection{ Why use a CLI for ngrx }
Without a doubt the most fustrating thing about Angular before the CLI came
around, is the amount of boilerplate that would be required in order to work
with Angular \footnote{As an example, having to create a scss + html + action +
reducer + effect and respective spec file for each next component created }.
The Nrwl Nx for the most part solves this. In addition, there is much more that
can be done on top of this in the future. Think of automatically generating code
based on instance, but I digress.

\subsection{The two stages of Nx ngrx cli}
There are going to be two stages with regards to using the Nx ngrx cli. One of
them is to create root state. This is going to be empty, and it is just there to
hold the feature reducers of the rest of the app. The 2nd stage, which will be
repeated time and time again, is creating a feature reducer. (Creating a root
reducer is something that you would only have to worry about if you are the one
responsible for creating the project for the first time). I think it would
beneficial to running through the steps of how you would create state with the
@ngrx/cli, if you are not familiar with it already.

\subsection{Creating a Root State}
\mybox{At this point, the Definitive Guide assumes that you have already setup
your space as an Nx Workspace. If you haven't please do. It will not negatively
impact your app in any which way, and will only positively improve the way your
codebase works and your day to day happiness.}

The whole idea of state in ngrx/store, is that there is a single object, and
all subsequent pieces of state are sub piece of state. Therefore all pieces of
state will be contained in a single object. In order to have this done in your
code, you will need to set up state for your root, so that subsequent peices of
state can be added as child object(feature), to the root state. This will only
have to be done once.

In order to create a root reducer:
\begin{lstlisting}[language=Bash]
  ng generate ngrx app --module=apps/<app-name>/src/app/app.module.ts --onlyEmptyRoot
\end{lstlisting}

Note, we have passed in the flag for onlyEmptyRoot, so that none of the files
for actions, reducers, and effects are created. We simply want a module
generated that we can use to import other modules for state.

This will produce the following files /marginpar{Re-visit when we get back to
the app}

\subsection{Creating Feature State}
\mybox{We will be going into detail, into when one should create feature state
management, versus using a service. Or, when it might be considered overkill, or
suprisingly the right thing to do. Please refer to the chapter on data access
architecture, to learn more about when would be the proper time to generate
state for your component.}


\begin{enumerate}
  \item libs/<libname>/src/+state/products.actions.ts
  \item libs/<libname>/src/+state/products.effects.ts
  \item libs/<libname>/src/+state/products.effects.spec.ts
  \item libs/<libname>/src/+state/products.reducer.ts
  \item libs/<libname>/src/+state/products.reducer.spec.ts
\end{enumerate}

There is also the option to add a facade, which is highly reccomended. In
addition, creating a seperate selector file is extremely valuable.
