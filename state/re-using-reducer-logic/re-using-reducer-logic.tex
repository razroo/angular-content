\maketitle{}
\section{ Re-using Reducer Logic }

In any state management setting, many times an individual will come across
business logic that is repeated many times throughout one's feature state. For
instance, let's say that we hava fileUpload service that is going to be used in
our app. The purpose of this service, is to upload a file, and return a
FileMetadataId to be used in another api.

The logic for this state manangement workflow will be the same for actions,
facade, reducer, and effects. The question is how can we make our state
re-usable so that it we can use it in multiple reducers without having to
re-write logic?

\subsection{ Strategy }

The strategy for how we would create a re-usable state is as follows. We would
have a facade/action that would pass in an actionTypeName along with the
regular payload. The effect would be passed this unique actionTypeNamem which
would then call the appropriate facade/action for when data is uploaded, using
re-usable service. We would then pass in uploaded data from the action.payload
into the reducer. However, to make sure that reducer logic can be re-used, we
pass a special param for the reducer function called actionTypeName. We then
compare the actionNameIdentifier passed in from the action.paylod to the
actionTypeName passed in from the reducer. If they are equal to each other, then
we allow for the reducer logic to happen. Let's deepdive on this approach.

\subsection{Creating a re-usable Facade and Action}
Our UploadFile action will pass the following:
\begin{itemize}
  \item actionNameIdentifier - For allowing us to re-use reducer
  \footnote{Will Discuss this in more detail}
  \item entityId - Primarily for allowing us to use the ngrx/entity api
  \footnote{Will discuss this in more detail}
  \item file - Using the name html input api, File is what will be passed in
  through from the input.
\end{itemize}
For our uploadFile action, we can have the following:
\begin{lstlisting}
export class UploadFile implements Action {
  readonly type = UploadActionTypes.UploadAttachment;
  constructor(public payload: { actionNameIdentifier: string, entityId: string;
     file: File; name: string}) {}
}
\end{lstlisting}
\footnote{In a real world application, normally I would include a param for name
of the file. However, for the simplicity of this chapter, I decided to leave
it out.}

In our Facade, we would have the following:

\begin{lstlisting}
uploadFile(actionType: string, file: File, entityId: string): void {
    this.store.dispatch(
      new UploadFile({ actionNameIdentifier, entityId, file })
    );
  }
\end{lstlisting}

We create an action and facade that allows us to pass in an
actionNameIdentifier.

\subsection{Higher Order Reducers}

It is important to note that higher order functions are:
\mybox{
Functions that operate on other functions, either by taking them as arguments or
by returning them, are called higher-order functions.
}
We can now go to our reducer, and re-use this logic. Let's
go ahead and create a reducer for uploading attachments:

\begin{lstlisting}
export function attachmentReducer(
  state: UploadState = initialState,
  action: UploadAction,
  actionTypeName: string,
): UploadState {
  const { actionNameIdentifier } = action;
  if (actionNameIdentifier !== actionTypeName) return state

  switch (action.type) {
    case DraftActionTypes.UploadAttachments: {
      return attachmentsAdapter.addAll(action.payload, {
        ...state,
        loaded: true,
      });
    }
  }

  return state;
}
\end{lstlisting}

You will notice that in the above code, we have created a param for
actionTypeName in our reducer. In our action, we are passing what we are calling
actionNameIdentifier. We then are able to re-use this action, and reducer in any
given situation.

\subsection{Combining Higher Order Reducer with Feature State Reducer }

Higher order reducers are fantastic. However, many times, the higher order
reducer only solves one specific problem of state with regards to a particular
component. So, without us being able to combine multiple higher order reducers
within the app, a higher order reducer would be worthless. That being said, we
would be able combine reducers by doing the following:

\begin{lstlisting}
import { reducers } from './reducers';
@NgModule({
  imports: [
    ...
    StoreModule.forFeature('userModule', {
      userReducer,
      attachments: attachmentReducer,

    })
  ],
  ...
})
export default class UserModule { }
\end{lstlisting}

Now, any action that is made that matches the name for feature state we are
working on, will update the state for the respective reducer.

\subsection{Re-Using Effects}
\begin{lstlisting}
@Effect()
  uploadAttachment$ = this.dataPersistence.fetch(
    DraftActionTypes.UploadAttachment,
    {
      run: (action: UploadAttachment, state: UploadState) => {
        const { actionNameIdentifier } = action;
        return this.filesService
          .uploadFile(action.payload, FileLocation.ATTACHMENTS)
          .pipe(
            map((file: FileMetadata) => {
              return new AttachmentUploaded({
                id: action.payload.id,
                file,
                actionNameIdentifier,
              });
            })
          );
      },

      onError: (action: UploadDraftAttachment, error) => {
        console.error('Error', error);
      },
    }
  );
\end{lstlisting}

In the above effect, we are passing in the actionNameIdentifier, that is being
passed in from actionNameIdentifier. Using this pattern, we are able to create a
re-usable action, facade, reducer, and effect for uploading file, and making
sure that it is properly called based on feature state it is being used for.
