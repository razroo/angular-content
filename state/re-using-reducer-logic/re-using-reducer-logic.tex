\maketitle{}
\section{ Re-using Reducer Logic }

In an Angular setting, when using side effects heavily for one's app, the action
name becomes heavily tied to the way an application is intended to be used. For
instance, let's say that we hava fileUpload service that is going to be used in
our app, in an number of settings. What the file upload allows does, is allow
for file to be uploaded and then retreive the metadata for the file that has
been uploaded. However, we might use this file upload service to upload the
file to different places. However, the logic for all of them is the same. When
file is uploaded, ids are returned to be used as attachments.

However, the logic is the same for both for the actions, facade, reducer, and
effects. Is there a way that we can re-use logic within our app?

In order to re-use logic, we can do the following.

\subsection{Creating a re-usable Facade and Action}
For our uploadFile action, we can have the following:
\begin{lstlisting}
export class UploadAttachment implements Action {
  readonly type = UploadActionTypes.UploadAttachment;
  constructor(public payload: { id: string; file: File; name: string, actionType }) {}
}
\end{lstlisting}

In our Facade we would have the following:

\begin{lstlisting}
uploadAttachment(actionType: string, file: File, id: string = 'GENERIC'): void {
    this.store.dispatch(
      new UploadAttachment({ id, file, name: file.name, actionNameIdentifier })
    );
  }
\end{lstlisting}

We create an action and facade that allows us to pass in an
actionNameIdentifier.

\subsection{Higher Order Reducers}

It is important to note that higher order functions are:
\mybox{
Functions that operate on other functions, either by taking them as arguments or
by returning them, are called higher-order functions.
}
We can now go to our reducer, and re-use this logic. Let's
go ahead and create a reducer for uploading attachments:

\begin{lstlisting}
export function attachmentReducer(
  state: UploadState = initialState,
  action: UploadAction,
  actionTypeName: string,
): UploadState {
  const { actionNameIdentifier } = action;
  if (actionNameIdentifier !== actionTypeName) return state

  switch (action.type) {
    case DraftActionTypes.UploadAttachments: {
      return attachmentsAdapter.addAll(action.payload, {
        ...state,
        loaded: true,
      });
    }
  }

  return state;
}
\end{lstlisting}

You will notice that in the above code, we have created a param for
actionTypeName in our reducer. In our action, we are passing what we are calling
actionNameIdentifier. We then are able to re-use this action, and reducer in any
given situation.

\subsection{Combining Higher Order Reducer with Feature State Reducer }

Higher order reducers are fantastic. However, many times, the higher order
reducer only solves one specific problem of state with regards to a particular
component. So, without us being able to combine multiple higher order reducers
within the app, a higher order reducer would be worthless. That being said, we
would be able combine reducers by doing the following:

\begin{lstlisting}
import { reducers } from './reducers';
@NgModule({
  imports: [
    ...
    StoreModule.forFeature('userModule', {
      userReducer,
      attachments: attachmentReducer,

    })
  ],
  ...
})
export default class UserModule { }
\end{lstlisting}

Now, any action that is made that matches the name for feature state we are
working on, will update the state for the respective reducer.

\subsection{Re-Using Effects}
\begin{lstlisting}
@Effect()
  uploadAttachment$ = this.dataPersistence.fetch(
    DraftActionTypes.UploadAttachment,
    {
      run: (action: UploadAttachment, state: UploadState) => {
        const { actionNameIdentifier } = action;
        return this.filesService
          .uploadFile(action.payload, FileLocation.ATTACHMENTS)
          .pipe(
            map((file: FileMetadata) => {
              return new AttachmentUploaded({
                id: action.payload.id,
                file,
                actionNameIdentifier,
              });
            })
          );
      },

      onError: (action: UploadDraftAttachment, error) => {
        console.error('Error', error);
      },
    }
  );
\end{lstlisting}

\mybox{
Would it be possible to just use ngrx/entity for the above? In other words, we
might be able to pass in a unique set of data to a particular id, and then call
data using that pattern.
}
