\maketitle{}
\section{ Facade Pattern }

\subsection{ What is the Facade Pattern? }
The facade pattern is a classic. Anyone who has read the GoF book \footnote{
which if you haven't you should probably take a look.} knows that it is a
mainstay of computer science. Quoting from the GoF book:

\say{A facade is an object that provides a simplified interface to a larger body
 of code, such as a class library.}

\subsection{ A Look at your Typical Non Facade State Pattern  }
This pattern is particularly advantageous when it comes to ngrx actions. If I
may, let's imagine we have the following action:

\begin{lstlisting}
  // choose-size.actions.ts
export class LoadChooseSize implements Action {
  readonly type = ChooseSizeActionTypes.LoadChooseSize;
  constructor(public payload: any) {}
}
\end{lstlisting}

Now any time that we have to call an action we have to do two things:
\begin{enumerate}
  \item Have a store select within the component.
  \item Call a dispatch.
\end{enumerate}

\begin{lstlisting}
  chooseSize: Observable<any>;
  // choose-size.component.ts
  import { Store } from '@ngrx/store';
  constructor(private store: Store<any>) {
      this.chooseSize = store.select('chooseSize');
  //..
  merge(
    this.updateSize\$.pipe(
      map((value: any) => new ChooseSizeUpdated(value))
    )
  ).subscribe(action => {
    store.dispatch(action);
  });
\end{lstlisting}

Obviously, this is quite a bit of overhead. Using the facade pattern let's see
if we can simplify this process

\subsection{ Create the Facade Service  }

With a facade pattern, we have the ability to take the following two items:
\begin{enumerate}
  \item Store select
  \item Call a dispatch.
\end{enumerate}

and put them into the into our facade.

The facade should be treated as a service, and we will create a service folder
for our facade to go into.

Now in our

The facade pattern looks like the following:
\begin{lstlisting}
export class ChooseSizeFacade {
 constructor(private store: Store<any>) {}

 chooseSize$ = this.store.select('chooseSize');

 UpdateChooseSize(ChooseSizeFormPayload): void {
   this.store.dispatch(new ChooseSizeUpdated(ChooseSizeFormPayload));
 }
}
\end{lstlisting}

\subsection{ Hooking Facade Into Component }
Now if we would like to hook our facade into our action, all we have to do is
call the class ChooseSizeFacade service, and appropriate action.

\mybox{
\subsection{ Why Even Bother Creating a Facade? }
It might seem like a bit of overhead working towards creating an additional
file as a facade for our actions. However, it keeps our component clean, and
removes the need of keeping overhead of the different stores that our component
is using.
}
