\maketitle{}
\section{ Aggregation Pattern }

Many times within any web setting, numerous apis will be feeding into a singular
request. An example would be in an e-commerce setting wherein data for a
particular item, might come from numerous locations. The data for the pants
might come from one api, the analytics api might update, and then a third api
along the lines of data persistence will be called at that time as well.

In a backend setting, usually we try and keep a singular api request for the
business logic of a particular use case. However, there are many times wherein
this will be beyond the power of the developer. In can be in antiquated apis,
or in unique use cases.

\subsection{ The Unique Challenge with Ngrx/effects}
In an ngrx/effects use case, when a user is hitting a single service, and
returning a single action, it is relatively straight forward. This will look
something like the following:
\begin{lstlisting}
@Effect()
getProductInformation$ = this.dataPersistence.fetch(
  ProductTypes.getProductInformation, {
  run: (action: GetProductInformation, state: ProductModelState) => {
    const { userId, productId } = action.payload;

    return this.service
      .getProductInformation(userId, productId)
      .pipe(
        map((product: Product) => new ProductLoaded(product))
      );
  },

  onError: (action: GetProductInformation, error) => {
    console.error('Error', error);
  },
});
\end{lstlisting}

In this example we fire off a service, and return the data from that one
service. We might even have the option to turn the map into a switchMap, that
can be used for numerous actions, originating from a singular service. However,
it immediatly becomes a problem once we start to have a singular effect call
numerous services, wherein one action is expected to have all of it's data.

\subsection{Using the Aggregator Pattern}

\mybox{Before we introduce the aggregator pattern, it is important to make one
note. In any situation with numerous actions, we are going to want to include a
correlation id within our app. It is important to do this, so that as we have
numerous actions coming in at a time, the request is being done for the proper
item at that time.}

\subsubsection{Defining Types for Actions}
\begin{lstlisting}
export type AggregatableAction = Action & { correlationParams?: CorrelationParams };

export type FailActionForAggregation = Action & { error?: Error, correlationParams?: CorrelationParams };
\end{lstlisting}

First we define the types for our different actions. Both will be a standard
action with the addition of correlationParams, which we will use to make sure
that we are indded calling the correct action.

export function aggregate<T extends AggregatableAction,
    TAction1 extends AggregatableAction,
    TAction2 extends AggregatableAction,
    TFailAction extends FailActionForAggregation>
(
    action1$: Observable<TAction1>,
    action2$: Observable<TAction2>,
    failAction$: Observable<TFailAction>
): OperatorFunction<T, [TAction1, TAction2]> {

    const filterAction = (sourceAction: AggregatableAction, t: AggregatableAction) =>
        t.correlationParams && sourceAction.correlationParams &&
        t.correlationParams.correlationId === sourceAction.correlationParams.correlationId &&
        t.correlationParams.parentActionType === sourceAction.type;

    const getAggregatedActions = (sourceAction: AggregatableAction): Observable<[TAction1, TAction2]> => {
        let a1$ = action1$
            .pipe(
                filter(a => {
                    return filterAction(sourceAction, a);
                }),
                first()
            );
        let a2$ = action2$
            .pipe(
                filter(a => {
                    return filterAction(sourceAction, a);
                }),
                first()
            );

        let f$ = failAction$
            .pipe(
                filter(a => {
                    return filterAction(sourceAction, a);
                }),
                first(),
                switchMap(b => {
                    return Observable.throw(b.error);
                })
            );

        return race(forkJoin([a1$, a2$]), f$);
    };

    return (source: Observable<AggregatableAction>) => source.pipe(
        switchMap(sourceAction => getAggregatedActions(sourceAction))
    );
}
