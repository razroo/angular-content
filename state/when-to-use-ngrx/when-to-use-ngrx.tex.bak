\chapter{When to Use @ngrx/store}
When to use @ngrx/store is an opinionated topic. 

State is a single data object that can be accessed anywhere within the app. How this happens changes from one state management framework to another but the core is the same. However, the difficulty is that state, being that it exists outside of the component, can contain quite a bit of bloat.

\mybox{It is interesting to note, that the original implementation of Flux was created by Facebook back in 2014. This \href{https://www.youtube.com/watch?v=nYkdrAPrdcw}{video} talks about this. It was because they had a bug with chat that just kept on coming back.

It would mention that a user did not read a message but that wasn't true. Flux was the architecture they came up with in order to solve this bug. It's important to understand the history of where Flux came from, when trying to understand how to move forward using it. Flux solved it due to it's straight forward way of handling multiple components interacting with each other.

It is important to remember, that a store is about creating an in-memory client side database, which is a user-specific slice of the database, and use that
data to device View Models from it on the client.
}

\section{Redux as evolution on Flux}
Redux solved the same problem Flux did. 

However it simplified the process.

\includegraphics[width=9.1cm, height=6cm]{./state/when-to-use-ngrx/flux_v_redux}

It also more importantly standardized the Flux architecture as a library.

\section{@ngrx/store - Integrated Reactive Programming with the Store}
@ngrx/store took redux one step further, and integrated observable with the store. There is a fantastic founding paper on the benefits of Real Time: \href{http://www-sop.inria.fr/members/Gerard.Berry/Papers/Berry-IFIP-89.pdf}{Programming}

In it, it discusses two main benefits of Reactive Programming:
\begin{enumerate}
  \item Asynchronous
  \item Detemrinistic
\end{enumerate}

Andre Staltz stated the following: "Reactive Programming raises the level of abstraction of your code so you can focus on  the interdependence of events that define the business logic\ldots". \footnote{https://gist.github.com/staltz/868e7e9bc2a7b8c1f754\#why-should-i-consider-adopting-rp}

State is generally changed with events and being able to abstract the level of state makes complete sense. It greatly abstracts, and simplifies the process.

\mybox{As a side note, ngrx was actually created to solve performance issues with change detection in Angular2. It from that point onward has morphed into a good idea, allowing the store to be automatically hooked into state: https://github.com/ngrx/store/issues/16\#issuecomment-172027797}

\section{ An Example of an @ngrx/store }

For instance, let's say that we have a user-settings data-access feature. Our folder file structure might look like the following:
% Commented out for now, as causing an hbox error:
% \input{./state/when-to-use-ngrx/user-settings-tree-structure}

This, of course, would be in an enterprise setting which honestly this book is geared towards. However, it definitely strikes home a very good point. There is a ton of bloat to creating a store.

\section{Understanding the Reality of State}
I think that looking at the above folder/file structure, it is very important to realize that state has gone so far beyond what it was originally intended to do. You will notice effects, a facade pattern. In addition, quietly sitting inside of our reducer, is @ngrx/entity. The whole suite of @ngrx is so robust that it deals with the entire life cycle, of pulling in data, and integrating it with the client side. In fact, if it wasn't for the bloat that it introduced, it would be able to solve every single situation. However, we are trying to carry over data into the client side in a scalable and maintainable fashion.

\section{ Addressing the Problems State Alleviates }
Problems that state solves:
\begin{enumerate}
  \item Avoiding Multiple Actors
  \item Avoid Extraneous @Inputs
  \begin{enumerate}
    \item Pass down multiple levels to child, and send change back to parent
    \item Siblings in a tree, might have to pass up and over
  \end{enumerate}
  \item Stops Event Bussing /marginpar{Look more into this one}
  \item Decouples component interaction. Component does not know what changed, only knows what changed it.
  \item Allows for Component interaction via the Observable Pattern
  \item Client Side Cache if needed.
  \item Place to Put Temporary UI State
\end{enumerate}

These are 7 things that state has to offer. If a component were to be able to interact with another component on that page, by altering it's data, it should have state.

\subsection{ Addressing Additional two Offered by @ngrx/store }
Added into your classic @nrwl/nx ecosystem, is:
\begin{enumerate}
  \item @ngrx/entity
  \item Facade pattern for single
  \item Effects for asynchronous programming
\end{enumerate}

\section{The Mesmerism of @ngrx/store}

So, as mentioned before, the @ngrx/store ecosytem has grown into a beast. In fact, an Angular developer working on an enterprise and data heavy application might spend 60\% to 70\%(rough estimate) of their time working within @ngrx/store. 

I was a little bit curious as to how this repetition might psychologically affect the way that we as software engineers develop. In particular, if we can introduce services that accomplish what @ngrx/store does, albeit less bloat, is it worth it for the team?

I found an interesting book, called, "On Repeat: How Music Plays the Mind". It discusses a very interesting topic, of how we as humans interact with music. In it, it discusses something known as "The Exposure Effect".

It's something that we have all experienced with regards to music. You will hear some music on the radio that you are not particularly fond of. However, you will here it again the grocery store, movie theater, and then the store corner once again!

By this time, you are hooked.

As the book discusses, as you are used to the repetition of the song, you are already expecting the next piece of song, by the time you working on the beginning of it. Repetition, allows for us as the book argues, to look at a passage as a whole.

Arguably, the point can be made for software as well.

Within the application you are working on, the more you use that pattern the more accustomed you are to it. In addition, and I can personally attest to this, by the time, I am working on the facade, I am already thinking of the effect that is going to tie into our service, and how I am going to tie it into the component. Jumping out of this repetition can counter-productive, even if there is less code involved by creating a service.

\section{ Attachments Service - Story Time }
There are some very unique cases, where perhaps state shouldn't be used on an objective level. I for one always felt that state has a bit of bloat. However, after discussing with team members, I have begun to see the way they think. 

This particular situation was about a feature for attachments that the app needed. In particular, multiple components on the same page, would have attachments that would be uploaded to a server. Then, when the api using the attachment would make a request, it would pull attachment from the server, using it's id. If a service or @ngrx/store was not used, there would be a lot of repetition across the app. This led to the dilemma, should a service, or @ngrx/store be used.

\section{ Business Requirements }
One, is that multiple components on the same page were to use this attachments service. Second, is that we want to show the user when a certain attachment is loading, and when it is no longer loading.

\section{ Argument for using a Service }
In truth, the attachments were meant to be self contained within a singular component. This would have made the service as very simple. However, based on the business requirements, we would have had to create a double nested correlation id. This means that a double nested correlation id pattern had to be  created. 

One, to make sure that different components do not affect each other. Two, the id produced on the front end, is different than the id produced on the backend. We need to create an id that can be used by both. This is done by creating a second Uuid, that is nested within the first one. I.e. a dictionary inside of a dictionary.

So, really in this situation, there is arguably nothing that the store has to offer. However, what has happened, using "The Exposure Effect" is that we are now comfortable with the API for @ngrx/entity. 

Comfortable isn't accurate actually. 

We are able to predict, @ngrx/store as a whole. Any developer who worked and will work within the app, can pick up on the code base easier than a service, being that it is predictable. In addition, we have a single place where we expect all of our data to be. 

Creating a service like this might make sense for the person spending the time thinking through the problem. However, for any other person, it will be an incredibly uncomfortable experience reading through your code. @ngrx/store therefore at this point takes on it's new life as a way to make sure code is consistent, even if it isn't the right choice for your app.

\section{ What Comes Out From Our Back and Forth }
Truly, any enterprise situation, wherein a data request is made from the back end, it should be handled using @ngrx/store and not services. This is simply because, in any enterprise setting, the majority of situations is more properly handled using @ngrx/store.
\begin{enumerate}
  \item It allows for a cookie cutter api, that is used time and time again. The code bloat it creates, is alleviated by use of Nrwl Nx.
  \item Your application's performance will not affected as a result.
  \item From personal experience, business requirment change quite a bit. The odds of your service now being needed to re-written to accomodate it being
used in multiple components, is also quite high.
\end{enumerate}

\section{ Final Note }
If you are building an enterprise app from the beginning and are building a team, put this as part of the conventions right away. It will make your life easier. If you have a team, and you haven't fully agreed on this one, send them this article and start a conversation. 
