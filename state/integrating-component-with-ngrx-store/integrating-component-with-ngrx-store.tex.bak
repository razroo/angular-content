\chapter{ Integrating a Component with @ngrx/store }

Another chapter has been dedicated solely to integrating a component with @ngrx/store. This is because it is a standardized process. Observables are notoriously known for abstracting events, and therefore allow the same code to be repeated. The following is what can be expected to be repeated in your application, after initially generating files.

Just for redundancy sake, there are six steps that go into setting up state with any given component that are handled by the nx ngrx cli:
\begin{enumerate}
  \item Store
  \item Action
  \item Reducer
  \item Initial State (In some other framework it might be constants)
  \item Effects
\end{enumerate}

All that is left is for us to now to do three things component side:

\begin{enumerate}
  \item Set ups actions in view layer (i.e. HTML) + action type.
  \item Select store, so that it can be used in component.
  \item Setup subject in component, so that it can be used with actions in view layer.
  \item Setup reducer in component, so that it can be used with
  \item Set up subscribe in component(to transfer model to controller) \footnote{A subscriber is rarely setup in the smae component setting up the store to begin with}
\end{enumerate}

This is pretty standard and this will be done in every standard application. It is this simple and will follow this formula. 

(And yes, you should be in shock in how seamless integrating state management technology is at this point, because I am.)

\section{ Re-iterating purpose of book }

The point of this book, is to go through the architecture of the entire angular ecosystem. So that someone can read this book and have the confidence that they are building their Angular app the proper way, and that they do not have to look elsewhere. That being said, I will not be going into the whole code base of what is happening. However, I would like to show an example of along the lines of what will end up happening.

\section{ Set up action }
For our action, we are going to create an action type, and simple action, that is taking in a payload. Your action should not be doing anything fancy, and if it does, then you are not doing it right.

\begin{lstlisting}
ChooseSizeUpdated = '[ChooseSize] Data Updated'

export class ChooseSizeUpdated implements Action {
  readonly type = ChooseSizeActionTypes.ChooseSizeUpdated;
  constructor(public payload: any) {}
}
\end{lstlisting}

\section{ Set up store }
In any given component, we must setup a select for our store, in order to tell @ngrx/store, how we plan on interacting with it. The following is standard code, like the rest of this chapter, that will be repeated throughout any @ngrx/store process.

\begin{lstlisting}
this.chooseSize = store.select('chooseSize');
\end{lstlisting}

\section{ Creating a subject }

What is a subject? It is both an observable and an observer?
\begin{enumerate}
  \item Observer — It has the next, error, and complete methods.
  \item Observable — It has all the Observable operators, and you can subscribe
  to him.
\end{enumerate}

Therefore, in an Angular setting, using @ngrx/store, subjects are our friends. It allows us to have a singular event handler, to be used by all html event handlers within component. In addition, it gives us a subscribe. The general pattern in an Angular app will be as follows:
\begin{enumerate}
  \item Create subject in component
  \item Setup ElementRefs in Component HTML
  \item Merge subjects into singular subscribe
  \item Setup Reducer for action
\end{enumerate}

\section{ Creating a Subject - Code Dive }

\subsection{ Creating Subject - In Component }
\begin{lstlisting}
  import { Subject } from 'rxjs/Subject';

  updateSize$ = new Subject();
\end{lstlisting}

\subsection{ Setup ElementRefs in Component HTML }
\begin{lstlisting}
  <input matInput placeholder="Columns" #columns>
  <input matInput placeholder="Rows" #rows>
  <input matInput placeholder="Pixel Size" #pixelSize>
  <button (click)="updateSize$.next({columns: columns.value, rows: rows.value,
    pixelSize: pixelSize.value})"
\end{lstlisting}

We are now going to feed our updateSize subject into an rxjs merge, and map, to make it future proof.

\subsection{ Merge Subjects into Singular Subscribe }

\begin{lstlisting}
merge(
  this.updateSize$.pipe(
    map((value: any) => new ChooseSizeUpdated(value))
       )
    ).subscribe(action => {
      store.dispatch(action);
  });
\end{lstlisting}

\section{ Setting up a Reducer for our App }
\begin{lstlisting}
  case ChooseSizeActionTypes.ChooseSizeUpdated: {
    return { ...state, ...action.payload };
  }
\end{lstlisting}

\section{ Wrapping up }
We have gone through the full gamut, of what it is going to look like adding new elements of state into your app. This is the one part with regards to state that will have to be done manually. Who knows, maybe down the line, we will have more sophisticated technology, that will allow us to have a command line interface similar to what we have now using the Angular CLI.

Next let's talk unit testing.
