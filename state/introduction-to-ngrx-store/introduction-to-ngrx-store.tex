
\chapter{ Introduction to @ngrx/store }

As discussed in the chapter on the History of State Management, there has
been quite a series of progression with regards to state management. Redux, is
the mature concept of state management including actions, reducers, and a single
application store. \footnote{This is a footnote for more information on state management}.
Angular's @ngrx/store, which is not front and center, is where redux meets Rxjs.
Rxjs is the Javascript library for using observables
\footnote{More on Observables can be read here}.

\section{What Makes @ngrx/store Different than Redux?}
When considering this question, it is more important to consider what is
reactive programming. Reactive programming in particular introduces two concepts
\footnote{http://www-sop.inria.fr/members/Gerard.Berry/Papers/Berry-IFIP-89.pdf}:

\begin{enumerate}
  \item Asynchronous \footnote{Meaning one event fires after the previous one is
  complete, unlike synchronous which means they all fire at the same time, and
  might complete out of order.}
  \item Deterministic \footnote{Always produces the same results. As a side
  effect of this, code becomes very much so cookie cutter, which is great in
  an enterprise setting, as it allows for greater re-use.}
\end{enumerate}

\subsection{Asynchronous}
With regards to asynchronous programming, observables are not neccesarily 
reactive in the strictest sense. This is because the client is working 
separate from the server. Events with observables are most definitely reactive
, and help, but many applications are data heavy, and the immediate value of
observables are cut short. In addition, actual UI events from a browser 
perspective are put in a call stack, and are asynchronous by nature. What 
does help, is that baked into the framework is effects. Which does allow the
UI to be asynchronous, but it's not like it's anything crazy. This is 
something which could easily be done with promises. However, @ngrx/store does
tie it nicely into the store as a whole, allowing client state management, 
without going into detail.

\subsection{Deterministic}
With regards to determinstic, this generally means in computer science, that
with one particular input, you will alwyas have the same output. However, when
the term is used loosely, it generally means that the code is cookie cutter.
That is, that it can be re-used time and time again.

\section{Wrapping Up}
This is really what @ngrx/store tries to produce over other frameworks. It
offers the ability to re-use patterns time and time again. In addition, by
hooking it into the Rxjs lifecycle by using observables it allows patterns and
for code to be cookie cutter. This is really the beauty of @ngrx/store, is that
it offers a end to end solution to for state management. In particular, in the
form of effects, and observables.
