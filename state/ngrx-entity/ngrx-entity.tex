
\section{ Ngrx Entity }

The Ngrx repo until recently had many similar functionalities to your regular
redux app. It included actions, reducers, selectors. However, there has been
efforts to go ahead and create libraries for aspects of ngrx that can perhaps
be re-usable. One of these is @ngrx/entity.

\subsection{ Ngrx Entity at a High Level }
At it's core, ngrx entity is an API for manipulating and querying entity
collections. In particular:
\begin{enumerate}
  \item Reduce boilerplate for creating reducers that manage a collection of
  models.
  \item Providing performant CRUD operations for managing entity collections.
  \item Extensible type-safe adapters for selecting entity information.
\end{enumerate}

This architecture works really well when creating data as a single source of
truth. For instance, let's say in your application, you have a data table on
every page that pulls in data. Throughout every page, you have a way of
manipulating this data. Using ngrx/entity will allow for this architecture to
be fluid, and have all manipulation of data be within a singular area.

\subsection{ Example of Ngrx Entity }
Within our app we the ability to illustrate a pixelated charachter using pixels.
Every time that a pixel within the grid is selected, we are going to add it to
our store. This store is going to be used to display the code version of the
app. In addition, we are going to have to remove the pixel when clicked on
within our store. In addition, if we have selected a new color, and we select a
new pixel with that color, that pixel should be updated with the proper color.
What we have just described is a perfect CRUD app.

\subsection{ Installing ngrx/enity }
\begin{verbatim}
  npm install @ngrx/entity --save
\end{verbatim}

\subsection{ ngrx/entity - A Step Back }
Let's step back for the time being and look into what ngrx/entity actually does.
Ngrx/entity will create a list of ids and a dictionary of entities. Let's brush
up on entity, list, and dictionary:
\mybox{
entity: In relation to a database , an entity is a single person, place, or
thing about which data can be stored.\footnote{https://whatis.techtarget.com/definition/entity}

List: AKA an array.

Dictionary: Collection which is unordered, changeable and indexed.
}

That being said, a sample ngrx/entity data structure will look like this:
\begin{lstlisting}
  ids: [
    '3QOZBAAAQBAJ',
    'y4nmOe0-WD0C',
    'lS5SAQAAIAAJ',
  ],
  entitites: {
    '3QOZBAAAQBAJ': {
      name: 'Lebron',
      id: '3QOZBAAAQBAJ'
    },
    'y4nmOe0-WD0C': {
      name: 'Kyle',
      id: 'y4nmOe0-WD0C'
    },
    'lS5SAQAAIAAJ': {
      name: 'Sarah',
      id: 'lS5SAQAAIAAJ'
    }
  }

\end{lstlisting}

\subsection{ Adapter Pattern - A Primer  }
Before we go ahead and discuss what an ngrx/entity adapter is, let's go through
a quick primer on the adapter pattern in general. Per the GoF book
\footnote{A.K.A. Design Patterns: Elements of Reusable Object-Oriented Software}
an adapter pattern:

\say{is a software design pattern (also known as Wrapper, an alternative naming
shared with the Decorator pattern) that allows the interface of an existing
class to be used as another interface. It is often used to make existing
classes work with others without modifying their source code.}

\subsection{ Introducing Ngrx/entity adapter }
The ngrx/entity adapter, similarly, will take in data, and wrap it inside of ids
and entities. So the adapter can be considered as something that will modify
the data. The default adapter that comes with ngrx/entity, takes two default
values:
\begin{itemize}
  \item selectId: A method for selecting the primary id for the collection.
  \item sortComparer: A compare function used to sort the collection. The
  comparer function is only needed if the collection needs to be sorted before
  being displayed. Set to false to leave the collection unsorted, which is more
  performant during CRUD operations.
\end{itemize}

The selectId is the more important default value. This will be the default UUID
that will be used within the app. The general idea is that some sort of id will
be returned by the database for that particular item. One will then be able to
use that id for all crud operations. In addition, most likely pass in that id
for your Rest Service, or GraphQL query.

\subsection{ Ngrx/entity Adapter Example }
Creating an example adapter, might look something like the following:
\begin{lstlisting}
  export const adapter: EntityAdapter<any> = createEntityAdapter<any>({
  selectId: (emailStore: any) => emailStore.id,
  sortComparer: false,
});
\end{lstlisting}

There will then be a series of adapter methods returned by ngrx/entity. Without
going into them in detail, here they are:
\begin{itemize}
  \item addOne: Add one entity to the collection
  \item addMany: Add multiple entities to the collection
  \item addAll: Replace current collection with provided collection
  \item removeOne: Remove one entity from the collection
  \item removeMany: Remove multiple entities from the collection
  \item removeAll: Clear entity collection
  \item updateOne: Update one entity in the collection
  \item updateMany: Update multiple entities in the collection
  \item upsertOne: Add or Update one entity in the collection
  \item upsertMany: Add or Update multiple entities in the collection
\end{itemize}

\subsection{ addOne example }
In our app we will be using a series of different ngrx/entity methods. However,
we will be using addMany as for the most part many of the methods are very
similar.

Let's focus on a specific reducer section within our app.
\begin{verbatim}
  case gridTypes.added {
    return {
      adapter.addOne(action.payload, state)
    }
  }
\end{verbatim}

That would really be it \^. It will insert a unique id for that specific pixel.
In addition, it will go ahead and new entity within the entities object.

\subsection{ Identifying Different Entity Selectors }
So far ngrx/entity has given us an adapter, which allows us to choose the id
we would like to use for our entity dictionary, as well as our id list. However,
what if we wanted to retrieved all of our ids, or all of our entities? It can
be a bit cumbersome. So thankfully enough, you saw it coming, ngrx/entity
offers entity selectors out of the box.

\begin{lstlisting}
// get the selectors
const { selectIds, selectEntities, selectAll, selectTotal } = adapter.getSelectors();

// select the array of user ids
export const selectUserIds = selectIds;

// select the dictionary of user entities
export const selectUserEntities = selectEntities;

// select the array of users
export const selectAllUsers = selectAll;

// select the total user count
export const selectUserTotal = selectTotal;
\end{lstlisting}

It is important to recognize that these selectors will not actually produce
state on their own. What they do is return a function when used in
conjuction with the createSelector function, will return the appropriate
entity.

\subsection{ How to use getSelectors }
These selectors are then meant to be used with the createSelector function.
The following is an example:
\begin{verbatim}
export const selectUserIds = createSelector(
  selectUserState,
  fromUser.selectUserIds
);
\end{verbatim}

Now one will have a state that specifically returns ids for a specific list.

\subsection{ Using updateOne }
Just to show how convenient ngrx/entity is. Let's say in your app you wanted to
update a specific field. For instance, in our app it is going to be the color
for a specific pixel.] All you would need to do is the following:
\begin{verbatim}
  case gridTypes.updated {
    return {
      adapter.updateOne(action.payload.id, state)
    }
  }
\end{verbatim}

The only difference between the signature for addOne and updateOne, is that with
updateOne, you are just supplying the id to be updated.

\subsection{ Wrapping Up }
Suffice to say that using ngrx/entity will greatly increase the efficiency of
your app. Being able to use a CRUD app in this fashion, will simplify the
architcture across the app, wherein this state can be used in numerous places.
