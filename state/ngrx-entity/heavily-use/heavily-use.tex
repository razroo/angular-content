\maketitle{}
\section{ The Case for Heavily Using Ngrx/entity }

\subsection{ A Brief History of Normalization}


\subsection{Using Ngrx/entity}
Ngrx/entity for me personally, is the most exciting part of ngrx/entity. Simply
because it is a library based on comp sci fundementals of building an ngrx/store
database. In SQL databases, there is a concept of database normalization. For
instance, let's imagine we have a set of data. In our table, and we would like
to retrieve data from it. The data in JSON formate can look something like this:
\begin{lstlisting}
  interface codeBox {
    id: string;
    color: string;
    xPosition: number;
    yPosition: number;
  }
\end{lstlisting}

Now, let's imagine we have a an array of these codeBox types that we would like
use, that look something like this:
\begin{lstlisting}
  interface codeBoxCollection {
    codebox: codeBox[]
  }
\end{lstlisting}

Now this means, that if we want to select a certain piece of data within our
database table, things can be a little bit tricky. In order to access, for
instance, a certain section of our table, we would need to loop through all of
the data, and then find the appropriate set of data with id that we want.

Instead, what would make out data table more efficient, is if we have a table
of ids that corresponds directly to our table of data. This way, we can simply
say the data that we would like in our database, and correlate that directly to
the data that we are working on.

\subsection{ngrx/entity follows this pattern}
Ngrx/entity is a library which follows this pattern, so that data used within
ngrx/store is normalized. This means, within the context of using JSON data,
that we have a dictionary, combined with an array of ids. The index of the ids
directly correlates with the key/value in the dictionary. This is very powerful,
and I will prove it by bringing up a couple of situations.

\subsubsection{The Power of Ngrx/Entity Deep Dive}
Scenario One:
Updating one dictionary data set. Let's imagine that we were to load for our
pixel illustrator a set of coordinates to populate the pixe illustrator. However,
let's say we wanted to update one particular piece of that data set, by only
a smaller portion of data, when loading entire data set, and then a larger portion
when expanding details for particular data set. Ngrx/entity allows us to maintain
the same store, but simply update the once piece of data in the dictionary.

Scenario Two:
Let's say we have two indepedent components pulling data from the same store,
but we do not want them to interact with each other. For instance, let's say they
both accept attachments for a user. We would need to create a unique id for both
that would allow us to follow this pattern. ngrx/entity naturally would allow us
to do that in addition, to feeding the data back into the backend. This is such a
powerful pattern.

Scenario Three:
Let's say we have a data table, and we would like to know which set's of data
we have selected. We have the ability to pass in id, into another section of
data store, called selectedIds, and then have the freedom to choose any other
data set within those subsets.

Scenario Four:
Let's say we want to delete, update, or upsert a certain subset of data. Being
able to pass in the id only, makes this process infinitely easier, and more
efficient.

These are just four real worlds scenarios.

\subsection{Choosing Ngrx/entity as the Default}
This leads to the point this chapter is trying to make. In any situation with
data, odds are that you are going to update, delete, upsert, or pull in more
data for a specific subset of data. This means, that anytime that you are going
to use more data, using ngrx/entity as the default makes sense. The Nrwl cli
for ngrx/store follows this pattern, and it is highlt reccomended.
