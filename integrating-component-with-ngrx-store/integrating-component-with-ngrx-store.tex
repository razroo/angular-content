\maketitle{}
\section{ Integrating a Component with @ngrx/store }

Another chapter has been dedicated solely to integrating a component
with @ngrx/store. This is because it is a cookie cutter process. Observables
are notoriously known, for abstracting events, and therefore allowing the same
code to be repeated time, and time again. The following is what can be expected
to be repeated time and time again in your application, after initially
generating files.

Just for redundancy sake, there are six steps, that go into setting up state
with any given component, that are handled by the nx ngrx cli:
\begin{enumerate}
  \item Store
  \item Action
  \item Store
  \item Reducer
  \item Initial State/Enums\footnote{In some other framework it might be constants}
  \item Effects
\end{enumerate}

All that is left, is for us to now to do three things component side:

\begin{enumerate}
  \item Set ups actions in view layer (i.e. HTML) + action type.
  \item Select store, so that it can be used in component.
  \item Setup subject in component, so that it can be used with actions in view layer.
  \item Setup reducer in component, so that it can be used with
  \item Set up subscribe in component(to transfer model to controller) \footnote{A subscriber is rarely setup in the smae component setting up the store to begin with}
\end{enumerate}

This is pretty standard, and this will be done in every standard application.
It is this simple, and will follow this formula, and yes, you should be in shock
in how seamless integrating state management technology is at this point,
because I am.

\subsection{ Re-iterating purpose of book }

I would just like to re-iterate, that the point of this book, is to go through
the architecture of the entire angular ecosystem. So that someone can read this
book and have the confidence that they are building their Angular app the proper
way, and that they do not have to look elsewhere. That being said, I will not be
going into the whole code base of what is happening. However, I would like to show
an example of along the lines of what will end up happening.

\subsection{ Set up action }
\begin{lstlisting}
export class ChooseSizeUpdated implements Action {
  readonly type = ChooseSizeActionTypes.ChooseSizeUpdated;
  constructor(public payload: any) {}
}
\end{lstlisting}

\subsection{ Creating a subject }

To re-iterate, what is a subject? It is both an observable and an observer?
\begin{enumerate}
  \item Observer — It has the next, error, and complete methods.
  \item Observable — It has all the Observable operators, and you can subscribe
  to him.
\end{enumerate}

Therefore, in an Angular setting, using @ngrx/store, subjects are our friends. It
allows us to have a singular event handler, to be used by all html event handlers
within component. In addition, it gives us a subscribe. The general pattern in
an Angular app will be as follows:
\begin{enumerate}
  \item Create subject in component
  \item Setup ElementRefs in Component HTML
  \item Merge subjects into singular subscribe
  \item Setup Reducer for action
\end{enumerate}

\subsection{ Creating a Subject - Code Dive }

\subsubsection{ Creating Subject - In Component }
\begin{lstlisting}
  import { Subject } from 'rxjs/Subject';

  updateSize$ = new Subject();
\end{lstlisting}

\subsubsection{ Setup ElementRefs in Component HTML }
\begin{verbatim}
  <input matInput placeholder="Columns" #columns>
  <input matInput placeholder="Rows" #rows>
  <input matInput placeholder="Pixel Size" #pixelSize>
  <button (click)="updateSize$.next({columns: columns.value, rows: rows.value,
    pixelSize: pixelSize.value})"
\end{verbatim}

We are now going to feed our updateSize subject into an rxjs merge, and map,
to make it future proof.

\subsubsection{ Merge Subjects into Singular Subscribe }

\begin{lstlisting}
merge(
  this.updateSize$.pipe(
    map((value: any) => new ChooseSizeUpdated(value))
       )
    ).subscribe(action => {
      store.dispatch(action);
  });
\end{lstlisting}

\subsubsection{ Merge Subjects into Singular Subscribe }
