\chapter{Understanding Rendering}

Rendering within Angular is a really important thing to understand. Primarily, because of it's nature as a framework, the default way of doing things, can be a bit slower than needed. As an engineer, as you get to understand the framework better, you will find that there are performance boosts baked into the framework, to make your app more performant. Rendering within Angular is definitely one of those topics. Therefore, let's dive into the different ways of rendering on the web, so we can bring that over to Angular. 

\section{Terminology}

\begin{center}
  \begin{tabular}{@{} l *4c @{}}
    \toprule
    {{\color{red}Rendering} and {\color{blue}Performance} Terminology}\\
    \toprule
    {\color{red}Rendering} & {\color{blue}Performance} \\
    \midrule
    SSR           & TTFB \\
    CSR           & FP \\
    Rehydration   & FCP \\
    Prerendering  & TTI \\
  \end{tabular}
\end{center}  

\subsection{Rendering}
\begin{enumerate}
  \item SSR: Server-Side Rendering - Rendering a client-side, or universal app to HTML on the server
  \item CSR: Client-Side Rendering - Rendering an app in a browser, generally using the DOM.
  \item Rehydration: "Booting up" Javascript views on the client such that they re-use the server-rendered HTML's DOM tree and data
  \item Pre-rendering: Rinning a client-side application at build time, to capture it's initial state as static HTML.
\end{enumerate}

\subsection{Performance}
\begin{enumerate}
  \item TTFB: Time to First Byte - seen as the time between clicking a link and the first bit of content coming in.
  \item FP: First Paint - The first time any pixel becomes visible to the user.
  \item FCP: First Contentful Paint - The time when request content (body, header etc.), becomes visible. 
  \item TTI: Time to Ineractive - The time at which a page becomes interactive (events wired up, etc.)
\end{enumerate}

\section{ Setting Proper Frame of Mind - When Rendering Happens }
For me personally, when trying to understand how rendering worked, I realized that one of the things holding me back was that I wasn't quite fully aware when I happened. When I was able to put into perspective that it happens in two scenarios: 
\begin{enumerate}
  \item Navigation 
  \item Events
\end{enumerate}

I was then able to continue on with my understanding of rendering. So I just wanted to part this tidbit of information to you the reader.

\section{Server Rendering}
Server rendering will generate all of the html for page based on navigation. It's important to keep in mind the two scenarios above, and that server side rendering only happens for the navigation side of things. Events will still have the client side render changes. 

This will produce a fast first paint, and a fast first contentful paint. In addition, it allows for a fast time to interactive. The one draw back with regards to this approach, is the Time to First Byte. Being that we have to generate all of the content in the server first, it takes longer than usual to generate the page. Within the Angular context, it has something called Universal, which is a bit of a mix and much between server and client. Something that we will discuss momentarily. 

\section{Static Rendering}
Static rendering, is where we generate the full set of html content ahead of time. This checks all boxes with regards to performance i.e. 
\begin{enumerate}
  \item Fast TTFB, fast FP, fast FCP, fast TTI. 
  \item Fast FP
  \item Fast FCP
  \item Fast TTI  
\end{enumerate}

You might be familiar with tools like Jekyl, Gatsby, or Hugo that accomplish this. The main drawback with this approach, is that if we have dynamic content that we don't know ahead of time what the html page is going to look like, static sites are not able to accomplish this task. 

\mybox{A really good rule of thumb to find out if your site can be used as a static site, go ahead and disable Javascript. If you site is still able to operate, then you site can be turned into a static site.}

\section{Server vs. Static Rendering}
So let's say that you are coming across a situation wherein you cannot use static rendering. You would like to use static rendering. The only issue in this regard, is that you have a page that is dynamic. Even in this instance, server side rendering is not an end all be all solution. There will need to be some sort of caching solution offered in this regard, for server side rendering to be truly effective. 

\section{ Client Side Rendering }
Client side rendering is what usually happens by default in an Angular applciation. 
\begin{enumerate}
  \item logic 
  \item Data fetching
  \item Templating 
  \item Routing 
\end{enumerate}

Will all happen on the client side. There are a couple of downsides when it comes to rendering client side. One of the more notable downsides is as follows: 
\begin{enumerate}
  \item Performance concerns for mobile
\end{enumerate}

\marginpar{Irrelevant within an Angular setting}

\section{Universal Rendering - Server + Client Side}
Universal rendering is the happy medium between server side and client side rendering. Navigation requests(full page loads + reloads) are accomplished by the server side. The actual HTML is delivered by the server. The Javascript and data needed is embedded into the document. The one downside to SSR, is that it might look like it is fully loaded, but a user will not be able to interact with until the Javascript is fully embedded. On devices such as mobile, this can take a couple of seconds. The one outlier with regards to SSR, is that if you can find a use case wherein the content will be highly cacheable, then SSR might be a good candidate. 

\section{Up and Coming Technologies}
There are some technologies that are on the horizon that are useful to keep an eye on. There are two in particular, streaming server rendering + progressive rehydration.

\subsection{Streaming Server Rendering}
This allows for you to send HTML in chunks, so that the browser can progressively render as it's recieved. 

\subsection{Progressive Rehydration}
With this approach, individual pieces of an application are booted up over time as opposed to an entire application. This will help reduce the amount of Javascript required for an application as it is aware of what it is that the user specifically needs. This also helps prevent one of the major concerns of SSR rehydration, wherein a server rendered DOM tree rebuilds itself. 

\mybox{
\subsection{Notable Mention}
The idea behind this approach is for the browser to understand what parts of an actual application are being used. If some part of the application is not being used, then the browser will turn it into an inert HTML/decorative Javascript.
}

